"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const require$$1$2 = require("electron");
const node_module = require("node:module");
const node_url = require("node:url");
const path$6 = require("node:path");
const os$1 = require("node:os");
const fs = require("node:fs");
const require$$0 = require("path");
const require$$0$1 = require("util");
const require$$1 = require("fs");
const require$$0$3 = require("crypto");
const require$$0$2 = require("assert");
const require$$5 = require("events");
const require$$1$1 = require("os");
const require$$0$5 = require("net");
const require$$1$3 = require("stream");
const require$$4 = require("child_process");
const require$$0$4 = require("buffer");
const require$$0$6 = require("http");
const require$$1$5 = require("https");
const require$$2$1 = require("tls");
const require$$2 = require("dns");
const require$$1$4 = require("zlib");
const node_child_process = require("node:child_process");
const node_util = require("node:util");
var _documentCurrentScript = typeof document !== "undefined" ? document.currentScript : null;
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var source = { exports: {} };
var isObj$1 = (value) => {
  const type2 = typeof value;
  return value !== null && (type2 === "object" || type2 === "function");
};
const isObj = isObj$1;
const disallowedKeys = /* @__PURE__ */ new Set([
  "__proto__",
  "prototype",
  "constructor"
]);
const isValidPath = (pathSegments) => !pathSegments.some((segment) => disallowedKeys.has(segment));
function getPathSegments(path2) {
  const pathArray = path2.split(".");
  const parts = [];
  for (let i = 0; i < pathArray.length; i++) {
    let p = pathArray[i];
    while (p[p.length - 1] === "\\" && pathArray[i + 1] !== void 0) {
      p = p.slice(0, -1) + ".";
      p += pathArray[++i];
    }
    parts.push(p);
  }
  if (!isValidPath(parts)) {
    return [];
  }
  return parts;
}
var dotProp = {
  get(object, path2, value) {
    if (!isObj(object) || typeof path2 !== "string") {
      return value === void 0 ? object : value;
    }
    const pathArray = getPathSegments(path2);
    if (pathArray.length === 0) {
      return;
    }
    for (let i = 0; i < pathArray.length; i++) {
      object = object[pathArray[i]];
      if (object === void 0 || object === null) {
        if (i !== pathArray.length - 1) {
          return value;
        }
        break;
      }
    }
    return object === void 0 ? value : object;
  },
  set(object, path2, value) {
    if (!isObj(object) || typeof path2 !== "string") {
      return object;
    }
    const root = object;
    const pathArray = getPathSegments(path2);
    for (let i = 0; i < pathArray.length; i++) {
      const p = pathArray[i];
      if (!isObj(object[p])) {
        object[p] = {};
      }
      if (i === pathArray.length - 1) {
        object[p] = value;
      }
      object = object[p];
    }
    return root;
  },
  delete(object, path2) {
    if (!isObj(object) || typeof path2 !== "string") {
      return false;
    }
    const pathArray = getPathSegments(path2);
    for (let i = 0; i < pathArray.length; i++) {
      const p = pathArray[i];
      if (i === pathArray.length - 1) {
        delete object[p];
        return true;
      }
      object = object[p];
      if (!isObj(object)) {
        return false;
      }
    }
  },
  has(object, path2) {
    if (!isObj(object) || typeof path2 !== "string") {
      return false;
    }
    const pathArray = getPathSegments(path2);
    if (pathArray.length === 0) {
      return false;
    }
    for (let i = 0; i < pathArray.length; i++) {
      if (isObj(object)) {
        if (!(pathArray[i] in object)) {
          return false;
        }
        object = object[pathArray[i]];
      } else {
        return false;
      }
    }
    return true;
  }
};
var pkgUp = { exports: {} };
var findUp$1 = { exports: {} };
var locatePath$1 = { exports: {} };
var pathExists$1 = { exports: {} };
const fs$4 = require$$1;
pathExists$1.exports = (fp) => new Promise((resolve2) => {
  fs$4.access(fp, (err) => {
    resolve2(!err);
  });
});
pathExists$1.exports.sync = (fp) => {
  try {
    fs$4.accessSync(fp);
    return true;
  } catch (err) {
    return false;
  }
};
var pathExistsExports = pathExists$1.exports;
var pLimit$2 = { exports: {} };
var pTry$2 = { exports: {} };
const pTry$1 = (fn, ...arguments_) => new Promise((resolve2) => {
  resolve2(fn(...arguments_));
});
pTry$2.exports = pTry$1;
pTry$2.exports.default = pTry$1;
var pTryExports = pTry$2.exports;
const pTry = pTryExports;
const pLimit$1 = (concurrency) => {
  if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
    return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
  }
  const queue = [];
  let activeCount = 0;
  const next = () => {
    activeCount--;
    if (queue.length > 0) {
      queue.shift()();
    }
  };
  const run = (fn, resolve2, ...args) => {
    activeCount++;
    const result = pTry(fn, ...args);
    resolve2(result);
    result.then(next, next);
  };
  const enqueue = (fn, resolve2, ...args) => {
    if (activeCount < concurrency) {
      run(fn, resolve2, ...args);
    } else {
      queue.push(run.bind(null, fn, resolve2, ...args));
    }
  };
  const generator = (fn, ...args) => new Promise((resolve2) => enqueue(fn, resolve2, ...args));
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue.length
    },
    clearQueue: {
      value: () => {
        queue.length = 0;
      }
    }
  });
  return generator;
};
pLimit$2.exports = pLimit$1;
pLimit$2.exports.default = pLimit$1;
var pLimitExports = pLimit$2.exports;
const pLimit = pLimitExports;
class EndError extends Error {
  constructor(value) {
    super();
    this.value = value;
  }
}
const testElement = (el, tester) => Promise.resolve(el).then(tester);
const finder = (el) => Promise.all(el).then((val) => val[1] === true && Promise.reject(new EndError(val[0])));
var pLocate$1 = (iterable, tester, opts) => {
  opts = Object.assign({
    concurrency: Infinity,
    preserveOrder: true
  }, opts);
  const limit2 = pLimit(opts.concurrency);
  const items2 = [...iterable].map((el) => [el, limit2(testElement, el, tester)]);
  const checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);
  return Promise.all(items2.map((el) => checkLimit(finder, el))).then(() => {
  }).catch((err) => err instanceof EndError ? err.value : Promise.reject(err));
};
const path$5 = require$$0;
const pathExists = pathExistsExports;
const pLocate = pLocate$1;
locatePath$1.exports = (iterable, options) => {
  options = Object.assign({
    cwd: process.cwd()
  }, options);
  return pLocate(iterable, (el) => pathExists(path$5.resolve(options.cwd, el)), options);
};
locatePath$1.exports.sync = (iterable, options) => {
  options = Object.assign({
    cwd: process.cwd()
  }, options);
  for (const el of iterable) {
    if (pathExists.sync(path$5.resolve(options.cwd, el))) {
      return el;
    }
  }
};
var locatePathExports = locatePath$1.exports;
const path$4 = require$$0;
const locatePath = locatePathExports;
findUp$1.exports = (filename, opts = {}) => {
  const startDir = path$4.resolve(opts.cwd || "");
  const { root } = path$4.parse(startDir);
  const filenames = [].concat(filename);
  return new Promise((resolve2) => {
    (function find(dir) {
      locatePath(filenames, { cwd: dir }).then((file) => {
        if (file) {
          resolve2(path$4.join(dir, file));
        } else if (dir === root) {
          resolve2(null);
        } else {
          find(path$4.dirname(dir));
        }
      });
    })(startDir);
  });
};
findUp$1.exports.sync = (filename, opts = {}) => {
  let dir = path$4.resolve(opts.cwd || "");
  const { root } = path$4.parse(dir);
  const filenames = [].concat(filename);
  while (true) {
    const file = locatePath.sync(filenames, { cwd: dir });
    if (file) {
      return path$4.join(dir, file);
    }
    if (dir === root) {
      return null;
    }
    dir = path$4.dirname(dir);
  }
};
var findUpExports = findUp$1.exports;
const findUp = findUpExports;
pkgUp.exports = async ({ cwd } = {}) => findUp("package.json", { cwd });
pkgUp.exports.sync = ({ cwd } = {}) => findUp.sync("package.json", { cwd });
var pkgUpExports = pkgUp.exports;
var envPaths$1 = { exports: {} };
const path$3 = require$$0;
const os = require$$1$1;
const homedir = os.homedir();
const tmpdir = os.tmpdir();
const { env } = process;
const macos = (name) => {
  const library = path$3.join(homedir, "Library");
  return {
    data: path$3.join(library, "Application Support", name),
    config: path$3.join(library, "Preferences", name),
    cache: path$3.join(library, "Caches", name),
    log: path$3.join(library, "Logs", name),
    temp: path$3.join(tmpdir, name)
  };
};
const windows = (name) => {
  const appData = env.APPDATA || path$3.join(homedir, "AppData", "Roaming");
  const localAppData = env.LOCALAPPDATA || path$3.join(homedir, "AppData", "Local");
  return {
    // Data/config/cache/log are invented by me as Windows isn't opinionated about this
    data: path$3.join(localAppData, name, "Data"),
    config: path$3.join(appData, name, "Config"),
    cache: path$3.join(localAppData, name, "Cache"),
    log: path$3.join(localAppData, name, "Log"),
    temp: path$3.join(tmpdir, name)
  };
};
const linux = (name) => {
  const username = path$3.basename(homedir);
  return {
    data: path$3.join(env.XDG_DATA_HOME || path$3.join(homedir, ".local", "share"), name),
    config: path$3.join(env.XDG_CONFIG_HOME || path$3.join(homedir, ".config"), name),
    cache: path$3.join(env.XDG_CACHE_HOME || path$3.join(homedir, ".cache"), name),
    // https://wiki.debian.org/XDGBaseDirectorySpecification#state
    log: path$3.join(env.XDG_STATE_HOME || path$3.join(homedir, ".local", "state"), name),
    temp: path$3.join(tmpdir, username, name)
  };
};
const envPaths = (name, options) => {
  if (typeof name !== "string") {
    throw new TypeError(`Expected string, got ${typeof name}`);
  }
  options = Object.assign({ suffix: "nodejs" }, options);
  if (options.suffix) {
    name += `-${options.suffix}`;
  }
  if (process.platform === "darwin") {
    return macos(name);
  }
  if (process.platform === "win32") {
    return windows(name);
  }
  return linux(name);
};
envPaths$1.exports = envPaths;
envPaths$1.exports.default = envPaths;
var envPathsExports = envPaths$1.exports;
var dist$1 = {};
var consts = {};
Object.defineProperty(consts, "__esModule", { value: true });
consts.NOOP = consts.LIMIT_FILES_DESCRIPTORS = consts.LIMIT_BASENAME_LENGTH = consts.IS_USER_ROOT = consts.IS_POSIX = consts.DEFAULT_TIMEOUT_SYNC = consts.DEFAULT_TIMEOUT_ASYNC = consts.DEFAULT_WRITE_OPTIONS = consts.DEFAULT_READ_OPTIONS = consts.DEFAULT_FOLDER_MODE = consts.DEFAULT_FILE_MODE = consts.DEFAULT_ENCODING = void 0;
const DEFAULT_ENCODING = "utf8";
consts.DEFAULT_ENCODING = DEFAULT_ENCODING;
const DEFAULT_FILE_MODE = 438;
consts.DEFAULT_FILE_MODE = DEFAULT_FILE_MODE;
const DEFAULT_FOLDER_MODE = 511;
consts.DEFAULT_FOLDER_MODE = DEFAULT_FOLDER_MODE;
const DEFAULT_READ_OPTIONS = {};
consts.DEFAULT_READ_OPTIONS = DEFAULT_READ_OPTIONS;
const DEFAULT_WRITE_OPTIONS = {};
consts.DEFAULT_WRITE_OPTIONS = DEFAULT_WRITE_OPTIONS;
const DEFAULT_TIMEOUT_ASYNC = 5e3;
consts.DEFAULT_TIMEOUT_ASYNC = DEFAULT_TIMEOUT_ASYNC;
const DEFAULT_TIMEOUT_SYNC = 100;
consts.DEFAULT_TIMEOUT_SYNC = DEFAULT_TIMEOUT_SYNC;
const IS_POSIX = !!process.getuid;
consts.IS_POSIX = IS_POSIX;
const IS_USER_ROOT = process.getuid ? !process.getuid() : false;
consts.IS_USER_ROOT = IS_USER_ROOT;
const LIMIT_BASENAME_LENGTH = 128;
consts.LIMIT_BASENAME_LENGTH = LIMIT_BASENAME_LENGTH;
const LIMIT_FILES_DESCRIPTORS = 1e4;
consts.LIMIT_FILES_DESCRIPTORS = LIMIT_FILES_DESCRIPTORS;
const NOOP = () => {
};
consts.NOOP = NOOP;
var fs$3 = {};
var attemptify = {};
Object.defineProperty(attemptify, "__esModule", { value: true });
attemptify.attemptifySync = attemptify.attemptifyAsync = void 0;
const consts_1$4 = consts;
const attemptifyAsync = (fn, onError = consts_1$4.NOOP) => {
  return function() {
    return fn.apply(void 0, arguments).catch(onError);
  };
};
attemptify.attemptifyAsync = attemptifyAsync;
const attemptifySync = (fn, onError = consts_1$4.NOOP) => {
  return function() {
    try {
      return fn.apply(void 0, arguments);
    } catch (error2) {
      return onError(error2);
    }
  };
};
attemptify.attemptifySync = attemptifySync;
var fs_handlers = {};
Object.defineProperty(fs_handlers, "__esModule", { value: true });
const consts_1$3 = consts;
const Handlers = {
  isChangeErrorOk: (error2) => {
    const { code: code2 } = error2;
    if (code2 === "ENOSYS")
      return true;
    if (!consts_1$3.IS_USER_ROOT && (code2 === "EINVAL" || code2 === "EPERM"))
      return true;
    return false;
  },
  isRetriableError: (error2) => {
    const { code: code2 } = error2;
    if (code2 === "EMFILE" || code2 === "ENFILE" || code2 === "EAGAIN" || code2 === "EBUSY" || code2 === "EACCESS" || code2 === "EACCS" || code2 === "EPERM")
      return true;
    return false;
  },
  onChangeError: (error2) => {
    if (Handlers.isChangeErrorOk(error2))
      return;
    throw error2;
  }
};
fs_handlers.default = Handlers;
var retryify = {};
var retryify_queue = {};
Object.defineProperty(retryify_queue, "__esModule", { value: true });
const consts_1$2 = consts;
const RetryfyQueue = {
  interval: 25,
  intervalId: void 0,
  limit: consts_1$2.LIMIT_FILES_DESCRIPTORS,
  queueActive: /* @__PURE__ */ new Set(),
  queueWaiting: /* @__PURE__ */ new Set(),
  init: () => {
    if (RetryfyQueue.intervalId)
      return;
    RetryfyQueue.intervalId = setInterval(RetryfyQueue.tick, RetryfyQueue.interval);
  },
  reset: () => {
    if (!RetryfyQueue.intervalId)
      return;
    clearInterval(RetryfyQueue.intervalId);
    delete RetryfyQueue.intervalId;
  },
  add: (fn) => {
    RetryfyQueue.queueWaiting.add(fn);
    if (RetryfyQueue.queueActive.size < RetryfyQueue.limit / 2) {
      RetryfyQueue.tick();
    } else {
      RetryfyQueue.init();
    }
  },
  remove: (fn) => {
    RetryfyQueue.queueWaiting.delete(fn);
    RetryfyQueue.queueActive.delete(fn);
  },
  schedule: () => {
    return new Promise((resolve2) => {
      const cleanup = () => RetryfyQueue.remove(resolver);
      const resolver = () => resolve2(cleanup);
      RetryfyQueue.add(resolver);
    });
  },
  tick: () => {
    if (RetryfyQueue.queueActive.size >= RetryfyQueue.limit)
      return;
    if (!RetryfyQueue.queueWaiting.size)
      return RetryfyQueue.reset();
    for (const fn of RetryfyQueue.queueWaiting) {
      if (RetryfyQueue.queueActive.size >= RetryfyQueue.limit)
        break;
      RetryfyQueue.queueWaiting.delete(fn);
      RetryfyQueue.queueActive.add(fn);
      fn();
    }
  }
};
retryify_queue.default = RetryfyQueue;
Object.defineProperty(retryify, "__esModule", { value: true });
retryify.retryifySync = retryify.retryifyAsync = void 0;
const retryify_queue_1 = retryify_queue;
const retryifyAsync = (fn, isRetriableError) => {
  return function(timestamp) {
    return function attempt() {
      return retryify_queue_1.default.schedule().then((cleanup) => {
        return fn.apply(void 0, arguments).then((result) => {
          cleanup();
          return result;
        }, (error2) => {
          cleanup();
          if (Date.now() >= timestamp)
            throw error2;
          if (isRetriableError(error2)) {
            const delay = Math.round(100 + 400 * Math.random()), delayPromise = new Promise((resolve2) => setTimeout(resolve2, delay));
            return delayPromise.then(() => attempt.apply(void 0, arguments));
          }
          throw error2;
        });
      });
    };
  };
};
retryify.retryifyAsync = retryifyAsync;
const retryifySync = (fn, isRetriableError) => {
  return function(timestamp) {
    return function attempt() {
      try {
        return fn.apply(void 0, arguments);
      } catch (error2) {
        if (Date.now() > timestamp)
          throw error2;
        if (isRetriableError(error2))
          return attempt.apply(void 0, arguments);
        throw error2;
      }
    };
  };
};
retryify.retryifySync = retryifySync;
Object.defineProperty(fs$3, "__esModule", { value: true });
const fs$2 = require$$1;
const util_1$S = require$$0$1;
const attemptify_1 = attemptify;
const fs_handlers_1 = fs_handlers;
const retryify_1 = retryify;
const FS = {
  chmodAttempt: attemptify_1.attemptifyAsync(util_1$S.promisify(fs$2.chmod), fs_handlers_1.default.onChangeError),
  chownAttempt: attemptify_1.attemptifyAsync(util_1$S.promisify(fs$2.chown), fs_handlers_1.default.onChangeError),
  closeAttempt: attemptify_1.attemptifyAsync(util_1$S.promisify(fs$2.close)),
  fsyncAttempt: attemptify_1.attemptifyAsync(util_1$S.promisify(fs$2.fsync)),
  mkdirAttempt: attemptify_1.attemptifyAsync(util_1$S.promisify(fs$2.mkdir)),
  realpathAttempt: attemptify_1.attemptifyAsync(util_1$S.promisify(fs$2.realpath)),
  statAttempt: attemptify_1.attemptifyAsync(util_1$S.promisify(fs$2.stat)),
  unlinkAttempt: attemptify_1.attemptifyAsync(util_1$S.promisify(fs$2.unlink)),
  closeRetry: retryify_1.retryifyAsync(util_1$S.promisify(fs$2.close), fs_handlers_1.default.isRetriableError),
  fsyncRetry: retryify_1.retryifyAsync(util_1$S.promisify(fs$2.fsync), fs_handlers_1.default.isRetriableError),
  openRetry: retryify_1.retryifyAsync(util_1$S.promisify(fs$2.open), fs_handlers_1.default.isRetriableError),
  readFileRetry: retryify_1.retryifyAsync(util_1$S.promisify(fs$2.readFile), fs_handlers_1.default.isRetriableError),
  renameRetry: retryify_1.retryifyAsync(util_1$S.promisify(fs$2.rename), fs_handlers_1.default.isRetriableError),
  statRetry: retryify_1.retryifyAsync(util_1$S.promisify(fs$2.stat), fs_handlers_1.default.isRetriableError),
  writeRetry: retryify_1.retryifyAsync(util_1$S.promisify(fs$2.write), fs_handlers_1.default.isRetriableError),
  chmodSyncAttempt: attemptify_1.attemptifySync(fs$2.chmodSync, fs_handlers_1.default.onChangeError),
  chownSyncAttempt: attemptify_1.attemptifySync(fs$2.chownSync, fs_handlers_1.default.onChangeError),
  closeSyncAttempt: attemptify_1.attemptifySync(fs$2.closeSync),
  mkdirSyncAttempt: attemptify_1.attemptifySync(fs$2.mkdirSync),
  realpathSyncAttempt: attemptify_1.attemptifySync(fs$2.realpathSync),
  statSyncAttempt: attemptify_1.attemptifySync(fs$2.statSync),
  unlinkSyncAttempt: attemptify_1.attemptifySync(fs$2.unlinkSync),
  closeSyncRetry: retryify_1.retryifySync(fs$2.closeSync, fs_handlers_1.default.isRetriableError),
  fsyncSyncRetry: retryify_1.retryifySync(fs$2.fsyncSync, fs_handlers_1.default.isRetriableError),
  openSyncRetry: retryify_1.retryifySync(fs$2.openSync, fs_handlers_1.default.isRetriableError),
  readFileSyncRetry: retryify_1.retryifySync(fs$2.readFileSync, fs_handlers_1.default.isRetriableError),
  renameSyncRetry: retryify_1.retryifySync(fs$2.renameSync, fs_handlers_1.default.isRetriableError),
  statSyncRetry: retryify_1.retryifySync(fs$2.statSync, fs_handlers_1.default.isRetriableError),
  writeSyncRetry: retryify_1.retryifySync(fs$2.writeSync, fs_handlers_1.default.isRetriableError)
};
fs$3.default = FS;
var lang = {};
Object.defineProperty(lang, "__esModule", { value: true });
const Lang = {
  isFunction: (x) => {
    return typeof x === "function";
  },
  isString: (x) => {
    return typeof x === "string";
  },
  isUndefined: (x) => {
    return typeof x === "undefined";
  }
};
lang.default = Lang;
var scheduler = {};
Object.defineProperty(scheduler, "__esModule", { value: true });
const Queues = {};
const Scheduler = {
  next: (id2) => {
    const queue = Queues[id2];
    if (!queue)
      return;
    queue.shift();
    const job = queue[0];
    if (job) {
      job(() => Scheduler.next(id2));
    } else {
      delete Queues[id2];
    }
  },
  schedule: (id2) => {
    return new Promise((resolve2) => {
      let queue = Queues[id2];
      if (!queue)
        queue = Queues[id2] = [];
      queue.push(resolve2);
      if (queue.length > 1)
        return;
      resolve2(() => Scheduler.next(id2));
    });
  }
};
scheduler.default = Scheduler;
var temp = {};
Object.defineProperty(temp, "__esModule", { value: true });
const path$2 = require$$0;
const consts_1$1 = consts;
const fs_1$1 = fs$3;
const Temp = {
  store: {},
  create: (filePath) => {
    const randomness = `000000${Math.floor(Math.random() * 16777215).toString(16)}`.slice(-6), timestamp = Date.now().toString().slice(-10), prefix = "tmp-", suffix = `.${prefix}${timestamp}${randomness}`, tempPath = `${filePath}${suffix}`;
    return tempPath;
  },
  get: (filePath, creator, purge = true) => {
    const tempPath = Temp.truncate(creator(filePath));
    if (tempPath in Temp.store)
      return Temp.get(filePath, creator, purge);
    Temp.store[tempPath] = purge;
    const disposer = () => delete Temp.store[tempPath];
    return [tempPath, disposer];
  },
  purge: (filePath) => {
    if (!Temp.store[filePath])
      return;
    delete Temp.store[filePath];
    fs_1$1.default.unlinkAttempt(filePath);
  },
  purgeSync: (filePath) => {
    if (!Temp.store[filePath])
      return;
    delete Temp.store[filePath];
    fs_1$1.default.unlinkSyncAttempt(filePath);
  },
  purgeSyncAll: () => {
    for (const filePath in Temp.store) {
      Temp.purgeSync(filePath);
    }
  },
  truncate: (filePath) => {
    const basename = path$2.basename(filePath);
    if (basename.length <= consts_1$1.LIMIT_BASENAME_LENGTH)
      return filePath;
    const truncable = /^(\.?)(.*?)((?:\.[^.]+)?(?:\.tmp-\d{10}[a-f0-9]{6})?)$/.exec(basename);
    if (!truncable)
      return filePath;
    const truncationLength = basename.length - consts_1$1.LIMIT_BASENAME_LENGTH;
    return `${filePath.slice(0, -basename.length)}${truncable[1]}${truncable[2].slice(0, -truncationLength)}${truncable[3]}`;
  }
};
process.on("exit", Temp.purgeSyncAll);
temp.default = Temp;
Object.defineProperty(dist$1, "__esModule", { value: true });
dist$1.writeFileSync = dist$1.writeFile = dist$1.readFileSync = dist$1.readFile = void 0;
const path$1 = require$$0;
const consts_1 = consts;
const fs_1 = fs$3;
const lang_1 = lang;
const scheduler_1 = scheduler;
const temp_1 = temp;
function readFile$1(filePath, options = consts_1.DEFAULT_READ_OPTIONS) {
  var _a;
  if (lang_1.default.isString(options))
    return readFile$1(filePath, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_ASYNC);
  return fs_1.default.readFileRetry(timeout)(filePath, options);
}
dist$1.readFile = readFile$1;
function readFileSync(filePath, options = consts_1.DEFAULT_READ_OPTIONS) {
  var _a;
  if (lang_1.default.isString(options))
    return readFileSync(filePath, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_SYNC);
  return fs_1.default.readFileSyncRetry(timeout)(filePath, options);
}
dist$1.readFileSync = readFileSync;
const writeFile = (filePath, data, options, callback) => {
  if (lang_1.default.isFunction(options))
    return writeFile(filePath, data, consts_1.DEFAULT_WRITE_OPTIONS, options);
  const promise = writeFileAsync(filePath, data, options);
  if (callback)
    promise.then(callback, callback);
  return promise;
};
dist$1.writeFile = writeFile;
const writeFileAsync = async (filePath, data, options = consts_1.DEFAULT_WRITE_OPTIONS) => {
  var _a;
  if (lang_1.default.isString(options))
    return writeFileAsync(filePath, data, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_ASYNC);
  let schedulerCustomDisposer = null, schedulerDisposer = null, tempDisposer = null, tempPath = null, fd = null;
  try {
    if (options.schedule)
      schedulerCustomDisposer = await options.schedule(filePath);
    schedulerDisposer = await scheduler_1.default.schedule(filePath);
    filePath = await fs_1.default.realpathAttempt(filePath) || filePath;
    [tempPath, tempDisposer] = temp_1.default.get(filePath, options.tmpCreate || temp_1.default.create, !(options.tmpPurge === false));
    const useStatChown = consts_1.IS_POSIX && lang_1.default.isUndefined(options.chown), useStatMode = lang_1.default.isUndefined(options.mode);
    if (useStatChown || useStatMode) {
      const stat = await fs_1.default.statAttempt(filePath);
      if (stat) {
        options = { ...options };
        if (useStatChown)
          options.chown = { uid: stat.uid, gid: stat.gid };
        if (useStatMode)
          options.mode = stat.mode;
      }
    }
    const parentPath = path$1.dirname(filePath);
    await fs_1.default.mkdirAttempt(parentPath, {
      mode: consts_1.DEFAULT_FOLDER_MODE,
      recursive: true
    });
    fd = await fs_1.default.openRetry(timeout)(tempPath, "w", options.mode || consts_1.DEFAULT_FILE_MODE);
    if (options.tmpCreated)
      options.tmpCreated(tempPath);
    if (lang_1.default.isString(data)) {
      await fs_1.default.writeRetry(timeout)(fd, data, 0, options.encoding || consts_1.DEFAULT_ENCODING);
    } else if (!lang_1.default.isUndefined(data)) {
      await fs_1.default.writeRetry(timeout)(fd, data, 0, data.length, 0);
    }
    if (options.fsync !== false) {
      if (options.fsyncWait !== false) {
        await fs_1.default.fsyncRetry(timeout)(fd);
      } else {
        fs_1.default.fsyncAttempt(fd);
      }
    }
    await fs_1.default.closeRetry(timeout)(fd);
    fd = null;
    if (options.chown)
      await fs_1.default.chownAttempt(tempPath, options.chown.uid, options.chown.gid);
    if (options.mode)
      await fs_1.default.chmodAttempt(tempPath, options.mode);
    try {
      await fs_1.default.renameRetry(timeout)(tempPath, filePath);
    } catch (error2) {
      if (error2.code !== "ENAMETOOLONG")
        throw error2;
      await fs_1.default.renameRetry(timeout)(tempPath, temp_1.default.truncate(filePath));
    }
    tempDisposer();
    tempPath = null;
  } finally {
    if (fd)
      await fs_1.default.closeAttempt(fd);
    if (tempPath)
      temp_1.default.purge(tempPath);
    if (schedulerCustomDisposer)
      schedulerCustomDisposer();
    if (schedulerDisposer)
      schedulerDisposer();
  }
};
const writeFileSync = (filePath, data, options = consts_1.DEFAULT_WRITE_OPTIONS) => {
  var _a;
  if (lang_1.default.isString(options))
    return writeFileSync(filePath, data, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_SYNC);
  let tempDisposer = null, tempPath = null, fd = null;
  try {
    filePath = fs_1.default.realpathSyncAttempt(filePath) || filePath;
    [tempPath, tempDisposer] = temp_1.default.get(filePath, options.tmpCreate || temp_1.default.create, !(options.tmpPurge === false));
    const useStatChown = consts_1.IS_POSIX && lang_1.default.isUndefined(options.chown), useStatMode = lang_1.default.isUndefined(options.mode);
    if (useStatChown || useStatMode) {
      const stat = fs_1.default.statSyncAttempt(filePath);
      if (stat) {
        options = { ...options };
        if (useStatChown)
          options.chown = { uid: stat.uid, gid: stat.gid };
        if (useStatMode)
          options.mode = stat.mode;
      }
    }
    const parentPath = path$1.dirname(filePath);
    fs_1.default.mkdirSyncAttempt(parentPath, {
      mode: consts_1.DEFAULT_FOLDER_MODE,
      recursive: true
    });
    fd = fs_1.default.openSyncRetry(timeout)(tempPath, "w", options.mode || consts_1.DEFAULT_FILE_MODE);
    if (options.tmpCreated)
      options.tmpCreated(tempPath);
    if (lang_1.default.isString(data)) {
      fs_1.default.writeSyncRetry(timeout)(fd, data, 0, options.encoding || consts_1.DEFAULT_ENCODING);
    } else if (!lang_1.default.isUndefined(data)) {
      fs_1.default.writeSyncRetry(timeout)(fd, data, 0, data.length, 0);
    }
    if (options.fsync !== false) {
      if (options.fsyncWait !== false) {
        fs_1.default.fsyncSyncRetry(timeout)(fd);
      } else {
        fs_1.default.fsyncAttempt(fd);
      }
    }
    fs_1.default.closeSyncRetry(timeout)(fd);
    fd = null;
    if (options.chown)
      fs_1.default.chownSyncAttempt(tempPath, options.chown.uid, options.chown.gid);
    if (options.mode)
      fs_1.default.chmodSyncAttempt(tempPath, options.mode);
    try {
      fs_1.default.renameSyncRetry(timeout)(tempPath, filePath);
    } catch (error2) {
      if (error2.code !== "ENAMETOOLONG")
        throw error2;
      fs_1.default.renameSyncRetry(timeout)(tempPath, temp_1.default.truncate(filePath));
    }
    tempDisposer();
    tempPath = null;
  } finally {
    if (fd)
      fs_1.default.closeSyncAttempt(fd);
    if (tempPath)
      temp_1.default.purge(tempPath);
  }
};
dist$1.writeFileSync = writeFileSync;
var ajv$1 = { exports: {} };
var core$5 = {};
var validate$1 = {};
var boolSchema$1 = {};
var errors$4 = {};
var codegen$1 = {};
var code$3 = {};
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.regexpCode = exports$1.getEsmExportName = exports$1.getProperty = exports$1.safeStringify = exports$1.stringify = exports$1.strConcat = exports$1.addCodeArg = exports$1.str = exports$1._ = exports$1.nil = exports$1._Code = exports$1.Name = exports$1.IDENTIFIER = exports$1._CodeOrName = void 0;
  class _CodeOrName {
  }
  exports$1._CodeOrName = _CodeOrName;
  exports$1.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class Name extends _CodeOrName {
    constructor(s) {
      super();
      if (!exports$1.IDENTIFIER.test(s))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = s;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  exports$1.Name = Name;
  class _Code extends _CodeOrName {
    constructor(code2) {
      super();
      this._items = typeof code2 === "string" ? [code2] : code2;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return false;
      const item = this._items[0];
      return item === "" || item === '""';
    }
    get str() {
      var _a;
      return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
    }
    get names() {
      var _a;
      return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names2, c) => {
        if (c instanceof Name)
          names2[c.str] = (names2[c.str] || 0) + 1;
        return names2;
      }, {});
    }
  }
  exports$1._Code = _Code;
  exports$1.nil = new _Code("");
  function _(strs, ...args) {
    const code2 = [strs[0]];
    let i = 0;
    while (i < args.length) {
      addCodeArg(code2, args[i]);
      code2.push(strs[++i]);
    }
    return new _Code(code2);
  }
  exports$1._ = _;
  const plus = new _Code("+");
  function str(strs, ...args) {
    const expr = [safeStringify(strs[0])];
    let i = 0;
    while (i < args.length) {
      expr.push(plus);
      addCodeArg(expr, args[i]);
      expr.push(plus, safeStringify(strs[++i]));
    }
    optimize(expr);
    return new _Code(expr);
  }
  exports$1.str = str;
  function addCodeArg(code2, arg) {
    if (arg instanceof _Code)
      code2.push(...arg._items);
    else if (arg instanceof Name)
      code2.push(arg);
    else
      code2.push(interpolate(arg));
  }
  exports$1.addCodeArg = addCodeArg;
  function optimize(expr) {
    let i = 1;
    while (i < expr.length - 1) {
      if (expr[i] === plus) {
        const res = mergeExprItems(expr[i - 1], expr[i + 1]);
        if (res !== void 0) {
          expr.splice(i - 1, 3, res);
          continue;
        }
        expr[i++] = "+";
      }
      i++;
    }
  }
  function mergeExprItems(a, b) {
    if (b === '""')
      return a;
    if (a === '""')
      return b;
    if (typeof a == "string") {
      if (b instanceof Name || a[a.length - 1] !== '"')
        return;
      if (typeof b != "string")
        return `${a.slice(0, -1)}${b}"`;
      if (b[0] === '"')
        return a.slice(0, -1) + b.slice(1);
      return;
    }
    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
      return `"${a}${b.slice(1)}`;
    return;
  }
  function strConcat(c1, c2) {
    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
  }
  exports$1.strConcat = strConcat;
  function interpolate(x) {
    return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
  }
  function stringify(x) {
    return new _Code(safeStringify(x));
  }
  exports$1.stringify = stringify;
  function safeStringify(x) {
    return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  exports$1.safeStringify = safeStringify;
  function getProperty(key2) {
    return typeof key2 == "string" && exports$1.IDENTIFIER.test(key2) ? new _Code(`.${key2}`) : _`[${key2}]`;
  }
  exports$1.getProperty = getProperty;
  function getEsmExportName(key2) {
    if (typeof key2 == "string" && exports$1.IDENTIFIER.test(key2)) {
      return new _Code(`${key2}`);
    }
    throw new Error(`CodeGen: invalid export name: ${key2}, use explicit $id name mapping`);
  }
  exports$1.getEsmExportName = getEsmExportName;
  function regexpCode(rx) {
    return new _Code(rx.toString());
  }
  exports$1.regexpCode = regexpCode;
})(code$3);
var scope$1 = {};
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.ValueScope = exports$1.ValueScopeName = exports$1.Scope = exports$1.varKinds = exports$1.UsedValueState = void 0;
  const code_12 = code$3;
  class ValueError extends Error {
    constructor(name) {
      super(`CodeGen: "code" for ${name} not defined`);
      this.value = name.value;
    }
  }
  var UsedValueState;
  (function(UsedValueState2) {
    UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
    UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
  })(UsedValueState || (exports$1.UsedValueState = UsedValueState = {}));
  exports$1.varKinds = {
    const: new code_12.Name("const"),
    let: new code_12.Name("let"),
    var: new code_12.Name("var")
  };
  class Scope {
    constructor({ prefixes, parent } = {}) {
      this._names = {};
      this._prefixes = prefixes;
      this._parent = parent;
    }
    toName(nameOrPrefix) {
      return nameOrPrefix instanceof code_12.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix) {
      return new code_12.Name(this._newName(prefix));
    }
    _newName(prefix) {
      const ng = this._names[prefix] || this._nameGroup(prefix);
      return `${prefix}${ng.index++}`;
    }
    _nameGroup(prefix) {
      var _a, _b;
      if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
        throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
      }
      return this._names[prefix] = { prefix, index: 0 };
    }
  }
  exports$1.Scope = Scope;
  class ValueScopeName extends code_12.Name {
    constructor(prefix, nameStr) {
      super(nameStr);
      this.prefix = prefix;
    }
    setValue(value, { property, itemIndex }) {
      this.value = value;
      this.scopePath = (0, code_12._)`.${new code_12.Name(property)}[${itemIndex}]`;
    }
  }
  exports$1.ValueScopeName = ValueScopeName;
  const line = (0, code_12._)`\n`;
  class ValueScope extends Scope {
    constructor(opts) {
      super(opts);
      this._values = {};
      this._scope = opts.scope;
      this.opts = { ...opts, _n: opts.lines ? line : code_12.nil };
    }
    get() {
      return this._scope;
    }
    name(prefix) {
      return new ValueScopeName(prefix, this._newName(prefix));
    }
    value(nameOrPrefix, value) {
      var _a;
      if (value.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const name = this.toName(nameOrPrefix);
      const { prefix } = name;
      const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
      let vs = this._values[prefix];
      if (vs) {
        const _name = vs.get(valueKey);
        if (_name)
          return _name;
      } else {
        vs = this._values[prefix] = /* @__PURE__ */ new Map();
      }
      vs.set(valueKey, name);
      const s = this._scope[prefix] || (this._scope[prefix] = []);
      const itemIndex = s.length;
      s[itemIndex] = value.ref;
      name.setValue(value, { property: prefix, itemIndex });
      return name;
    }
    getValue(prefix, keyOrRef) {
      const vs = this._values[prefix];
      if (!vs)
        return;
      return vs.get(keyOrRef);
    }
    scopeRefs(scopeName, values = this._values) {
      return this._reduceValues(values, (name) => {
        if (name.scopePath === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return (0, code_12._)`${scopeName}${name.scopePath}`;
      });
    }
    scopeCode(values = this._values, usedValues, getCode) {
      return this._reduceValues(values, (name) => {
        if (name.value === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return name.value.code;
      }, usedValues, getCode);
    }
    _reduceValues(values, valueCode, usedValues = {}, getCode) {
      let code2 = code_12.nil;
      for (const prefix in values) {
        const vs = values[prefix];
        if (!vs)
          continue;
        const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
        vs.forEach((name) => {
          if (nameSet.has(name))
            return;
          nameSet.set(name, UsedValueState.Started);
          let c = valueCode(name);
          if (c) {
            const def2 = this.opts.es5 ? exports$1.varKinds.var : exports$1.varKinds.const;
            code2 = (0, code_12._)`${code2}${def2} ${name} = ${c};${this.opts._n}`;
          } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
            code2 = (0, code_12._)`${code2}${c}${this.opts._n}`;
          } else {
            throw new ValueError(name);
          }
          nameSet.set(name, UsedValueState.Completed);
        });
      }
      return code2;
    }
  }
  exports$1.ValueScope = ValueScope;
})(scope$1);
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.or = exports$1.and = exports$1.not = exports$1.CodeGen = exports$1.operators = exports$1.varKinds = exports$1.ValueScopeName = exports$1.ValueScope = exports$1.Scope = exports$1.Name = exports$1.regexpCode = exports$1.stringify = exports$1.getProperty = exports$1.nil = exports$1.strConcat = exports$1.str = exports$1._ = void 0;
  const code_12 = code$3;
  const scope_1 = scope$1;
  var code_2 = code$3;
  Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
    return code_2._;
  } });
  Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
    return code_2.str;
  } });
  Object.defineProperty(exports$1, "strConcat", { enumerable: true, get: function() {
    return code_2.strConcat;
  } });
  Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
    return code_2.nil;
  } });
  Object.defineProperty(exports$1, "getProperty", { enumerable: true, get: function() {
    return code_2.getProperty;
  } });
  Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
    return code_2.stringify;
  } });
  Object.defineProperty(exports$1, "regexpCode", { enumerable: true, get: function() {
    return code_2.regexpCode;
  } });
  Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
    return code_2.Name;
  } });
  var scope_2 = scope$1;
  Object.defineProperty(exports$1, "Scope", { enumerable: true, get: function() {
    return scope_2.Scope;
  } });
  Object.defineProperty(exports$1, "ValueScope", { enumerable: true, get: function() {
    return scope_2.ValueScope;
  } });
  Object.defineProperty(exports$1, "ValueScopeName", { enumerable: true, get: function() {
    return scope_2.ValueScopeName;
  } });
  Object.defineProperty(exports$1, "varKinds", { enumerable: true, get: function() {
    return scope_2.varKinds;
  } });
  exports$1.operators = {
    GT: new code_12._Code(">"),
    GTE: new code_12._Code(">="),
    LT: new code_12._Code("<"),
    LTE: new code_12._Code("<="),
    EQ: new code_12._Code("==="),
    NEQ: new code_12._Code("!=="),
    NOT: new code_12._Code("!"),
    OR: new code_12._Code("||"),
    AND: new code_12._Code("&&"),
    ADD: new code_12._Code("+")
  };
  class Node {
    optimizeNodes() {
      return this;
    }
    optimizeNames(_names, _constants) {
      return this;
    }
  }
  class Def extends Node {
    constructor(varKind, name, rhs) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.rhs = rhs;
    }
    render({ es5, _n }) {
      const varKind = es5 ? scope_1.varKinds.var : this.varKind;
      const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${varKind} ${this.name}${rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (!names2[this.name.str])
        return;
      if (this.rhs)
        this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      return this.rhs instanceof code_12._CodeOrName ? this.rhs.names : {};
    }
  }
  class Assign extends Node {
    constructor(lhs, rhs, sideEffects) {
      super();
      this.lhs = lhs;
      this.rhs = rhs;
      this.sideEffects = sideEffects;
    }
    render({ _n }) {
      return `${this.lhs} = ${this.rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (this.lhs instanceof code_12.Name && !names2[this.lhs.str] && !this.sideEffects)
        return;
      this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      const names2 = this.lhs instanceof code_12.Name ? {} : { ...this.lhs.names };
      return addExprNames(names2, this.rhs);
    }
  }
  class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
      super(lhs, rhs, sideEffects);
      this.op = op;
    }
    render({ _n }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
    }
  }
  class Label extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      return `${this.label}:` + _n;
    }
  }
  class Break extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      const label = this.label ? ` ${this.label}` : "";
      return `break${label};` + _n;
    }
  }
  class Throw extends Node {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render({ _n }) {
      return `throw ${this.error};` + _n;
    }
    get names() {
      return this.error.names;
    }
  }
  class AnyCode extends Node {
    constructor(code2) {
      super();
      this.code = code2;
    }
    render({ _n }) {
      return `${this.code};` + _n;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      this.code = optimizeExpr(this.code, names2, constants2);
      return this;
    }
    get names() {
      return this.code instanceof code_12._CodeOrName ? this.code.names : {};
    }
  }
  class ParentNode extends Node {
    constructor(nodes = []) {
      super();
      this.nodes = nodes;
    }
    render(opts) {
      return this.nodes.reduce((code2, n) => code2 + n.render(opts), "");
    }
    optimizeNodes() {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i].optimizeNodes();
        if (Array.isArray(n))
          nodes.splice(i, 1, ...n);
        else if (n)
          nodes[i] = n;
        else
          nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i];
        if (n.optimizeNames(names2, constants2))
          continue;
        subtractNames(names2, n.names);
        nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((names2, n) => addNames(names2, n.names), {});
    }
  }
  class BlockNode extends ParentNode {
    render(opts) {
      return "{" + opts._n + super.render(opts) + "}" + opts._n;
    }
  }
  class Root extends ParentNode {
  }
  class Else extends BlockNode {
  }
  Else.kind = "else";
  class If extends BlockNode {
    constructor(condition, nodes) {
      super(nodes);
      this.condition = condition;
    }
    render(opts) {
      let code2 = `if(${this.condition})` + super.render(opts);
      if (this.else)
        code2 += "else " + this.else.render(opts);
      return code2;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const cond = this.condition;
      if (cond === true)
        return this.nodes;
      let e = this.else;
      if (e) {
        const ns = e.optimizeNodes();
        e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
      }
      if (e) {
        if (cond === false)
          return e instanceof If ? e : e.nodes;
        if (this.nodes.length)
          return this;
        return new If(not2(cond), e instanceof If ? [e] : e.nodes);
      }
      if (cond === false || !this.nodes.length)
        return void 0;
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a;
      this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants2);
      if (!(super.optimizeNames(names2, constants2) || this.else))
        return;
      this.condition = optimizeExpr(this.condition, names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      addExprNames(names2, this.condition);
      if (this.else)
        addNames(names2, this.else.names);
      return names2;
    }
  }
  If.kind = "if";
  class For extends BlockNode {
  }
  For.kind = "for";
  class ForLoop extends For {
    constructor(iteration) {
      super();
      this.iteration = iteration;
    }
    render(opts) {
      return `for(${this.iteration})` + super.render(opts);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iteration = optimizeExpr(this.iteration, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iteration.names);
    }
  }
  class ForRange extends For {
    constructor(varKind, name, from, to) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.from = from;
      this.to = to;
    }
    render(opts) {
      const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
      const { name, from, to } = this;
      return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
    }
    get names() {
      const names2 = addExprNames(super.names, this.from);
      return addExprNames(names2, this.to);
    }
  }
  class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
      super();
      this.loop = loop;
      this.varKind = varKind;
      this.name = name;
      this.iterable = iterable;
    }
    render(opts) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iterable = optimizeExpr(this.iterable, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iterable.names);
    }
  }
  class Func extends BlockNode {
    constructor(name, args, async) {
      super();
      this.name = name;
      this.args = args;
      this.async = async;
    }
    render(opts) {
      const _async = this.async ? "async " : "";
      return `${_async}function ${this.name}(${this.args})` + super.render(opts);
    }
  }
  Func.kind = "func";
  class Return extends ParentNode {
    render(opts) {
      return "return " + super.render(opts);
    }
  }
  Return.kind = "return";
  class Try extends BlockNode {
    render(opts) {
      let code2 = "try" + super.render(opts);
      if (this.catch)
        code2 += this.catch.render(opts);
      if (this.finally)
        code2 += this.finally.render(opts);
      return code2;
    }
    optimizeNodes() {
      var _a, _b;
      super.optimizeNodes();
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a, _b;
      super.optimizeNames(names2, constants2);
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants2);
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      if (this.catch)
        addNames(names2, this.catch.names);
      if (this.finally)
        addNames(names2, this.finally.names);
      return names2;
    }
  }
  class Catch extends BlockNode {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render(opts) {
      return `catch(${this.error})` + super.render(opts);
    }
  }
  Catch.kind = "catch";
  class Finally extends BlockNode {
    render(opts) {
      return "finally" + super.render(opts);
    }
  }
  Finally.kind = "finally";
  class CodeGen {
    constructor(extScope, opts = {}) {
      this._values = {};
      this._blockStarts = [];
      this._constants = {};
      this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
      this._extScope = extScope;
      this._scope = new scope_1.Scope({ parent: extScope });
      this._nodes = [new Root()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(prefix) {
      return this._scope.name(prefix);
    }
    // reserves unique name in the external scope
    scopeName(prefix) {
      return this._extScope.name(prefix);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(prefixOrName, value) {
      const name = this._extScope.value(prefixOrName, value);
      const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
      vs.add(name);
      return name;
    }
    getScopeValue(prefix, keyOrRef) {
      return this._extScope.getValue(prefix, keyOrRef);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(scopeName) {
      return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant) {
      const name = this._scope.toName(nameOrPrefix);
      if (rhs !== void 0 && constant)
        this._constants[name.str] = rhs;
      this._leafNode(new Def(varKind, name, rhs));
      return name;
    }
    // `const` declaration (`var` in es5 mode)
    const(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    // `var` declaration with optional assignment
    var(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    // assignment code
    assign(lhs, rhs, sideEffects) {
      return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    // `+=` code
    add(lhs, rhs) {
      return this._leafNode(new AssignOp(lhs, exports$1.operators.ADD, rhs));
    }
    // appends passed SafeExpr to code or executes Block
    code(c) {
      if (typeof c == "function")
        c();
      else if (c !== code_12.nil)
        this._leafNode(new AnyCode(c));
      return this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...keyValues) {
      const code2 = ["{"];
      for (const [key2, value] of keyValues) {
        if (code2.length > 1)
          code2.push(",");
        code2.push(key2);
        if (key2 !== value || this.opts.es5) {
          code2.push(":");
          (0, code_12.addCodeArg)(code2, value);
        }
      }
      code2.push("}");
      return new code_12._Code(code2);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(condition, thenBody, elseBody) {
      this._blockNode(new If(condition));
      if (thenBody && elseBody) {
        this.code(thenBody).else().code(elseBody).endIf();
      } else if (thenBody) {
        this.code(thenBody).endIf();
      } else if (elseBody) {
        throw new Error('CodeGen: "else" body without "then" body');
      }
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(condition) {
      return this._elseNode(new If(condition));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new Else());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(If, Else);
    }
    _for(node, forBody) {
      this._blockNode(node);
      if (forBody)
        this.code(forBody).endFor();
      return this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(iteration, forBody) {
      return this._for(new ForLoop(iteration), forBody);
    }
    // `for` statement for a range of values
    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
      const name = this._scope.toName(nameOrPrefix);
      if (this.opts.es5) {
        const arr = iterable instanceof code_12.Name ? iterable : this.var("_arr", iterable);
        return this.forRange("_i", 0, (0, code_12._)`${arr}.length`, (i) => {
          this.var(name, (0, code_12._)`${arr}[${i}]`);
          forBody(name);
        });
      }
      return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
      if (this.opts.ownProperties) {
        return this.forOf(nameOrPrefix, (0, code_12._)`Object.keys(${obj})`, forBody);
      }
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(For);
    }
    // `label` statement
    label(label) {
      return this._leafNode(new Label(label));
    }
    // `break` statement
    break(label) {
      return this._leafNode(new Break(label));
    }
    // `return` statement
    return(value) {
      const node = new Return();
      this._blockNode(node);
      this.code(value);
      if (node.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(Return);
    }
    // `try` statement
    try(tryBody, catchCode, finallyCode) {
      if (!catchCode && !finallyCode)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const node = new Try();
      this._blockNode(node);
      this.code(tryBody);
      if (catchCode) {
        const error2 = this.name("e");
        this._currNode = node.catch = new Catch(error2);
        catchCode(error2);
      }
      if (finallyCode) {
        this._currNode = node.finally = new Finally();
        this.code(finallyCode);
      }
      return this._endBlockNode(Catch, Finally);
    }
    // `throw` statement
    throw(error2) {
      return this._leafNode(new Throw(error2));
    }
    // start self-balancing block
    block(body, nodeCount) {
      this._blockStarts.push(this._nodes.length);
      if (body)
        this.code(body).endBlock(nodeCount);
      return this;
    }
    // end the current self-balancing block
    endBlock(nodeCount) {
      const len = this._blockStarts.pop();
      if (len === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const toClose = this._nodes.length - len;
      if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
        throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
      }
      this._nodes.length = len;
      return this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(name, args = code_12.nil, async, funcBody) {
      this._blockNode(new Func(name, args, async));
      if (funcBody)
        this.code(funcBody).endFunc();
      return this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(Func);
    }
    optimize(n = 1) {
      while (n-- > 0) {
        this._root.optimizeNodes();
        this._root.optimizeNames(this._root.names, this._constants);
      }
    }
    _leafNode(node) {
      this._currNode.nodes.push(node);
      return this;
    }
    _blockNode(node) {
      this._currNode.nodes.push(node);
      this._nodes.push(node);
    }
    _endBlockNode(N1, N2) {
      const n = this._currNode;
      if (n instanceof N1 || N2 && n instanceof N2) {
        this._nodes.pop();
        return this;
      }
      throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
    }
    _elseNode(node) {
      const n = this._currNode;
      if (!(n instanceof If)) {
        throw new Error('CodeGen: "else" without "if"');
      }
      this._currNode = n.else = node;
      return this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const ns = this._nodes;
      return ns[ns.length - 1];
    }
    set _currNode(node) {
      const ns = this._nodes;
      ns[ns.length - 1] = node;
    }
  }
  exports$1.CodeGen = CodeGen;
  function addNames(names2, from) {
    for (const n in from)
      names2[n] = (names2[n] || 0) + (from[n] || 0);
    return names2;
  }
  function addExprNames(names2, from) {
    return from instanceof code_12._CodeOrName ? addNames(names2, from.names) : names2;
  }
  function optimizeExpr(expr, names2, constants2) {
    if (expr instanceof code_12.Name)
      return replaceName(expr);
    if (!canOptimize(expr))
      return expr;
    return new code_12._Code(expr._items.reduce((items2, c) => {
      if (c instanceof code_12.Name)
        c = replaceName(c);
      if (c instanceof code_12._Code)
        items2.push(...c._items);
      else
        items2.push(c);
      return items2;
    }, []));
    function replaceName(n) {
      const c = constants2[n.str];
      if (c === void 0 || names2[n.str] !== 1)
        return n;
      delete names2[n.str];
      return c;
    }
    function canOptimize(e) {
      return e instanceof code_12._Code && e._items.some((c) => c instanceof code_12.Name && names2[c.str] === 1 && constants2[c.str] !== void 0);
    }
  }
  function subtractNames(names2, from) {
    for (const n in from)
      names2[n] = (names2[n] || 0) - (from[n] || 0);
  }
  function not2(x) {
    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_12._)`!${par(x)}`;
  }
  exports$1.not = not2;
  const andCode = mappend(exports$1.operators.AND);
  function and(...args) {
    return args.reduce(andCode);
  }
  exports$1.and = and;
  const orCode = mappend(exports$1.operators.OR);
  function or(...args) {
    return args.reduce(orCode);
  }
  exports$1.or = or;
  function mappend(op) {
    return (x, y) => x === code_12.nil ? y : y === code_12.nil ? x : (0, code_12._)`${par(x)} ${op} ${par(y)}`;
  }
  function par(x) {
    return x instanceof code_12.Name ? x : (0, code_12._)`(${x})`;
  }
})(codegen$1);
var util$1 = {};
Object.defineProperty(util$1, "__esModule", { value: true });
util$1.checkStrictMode = util$1.getErrorPath = util$1.Type = util$1.useFunc = util$1.setEvaluated = util$1.evaluatedPropsToName = util$1.mergeEvaluated = util$1.eachItem = util$1.unescapeJsonPointer = util$1.escapeJsonPointer = util$1.escapeFragment = util$1.unescapeFragment = util$1.schemaRefOrVal = util$1.schemaHasRulesButRef = util$1.schemaHasRules = util$1.checkUnknownRules = util$1.alwaysValidSchema = util$1.toHash = void 0;
const codegen_1$$ = codegen$1;
const code_1$l = code$3;
function toHash$1(arr) {
  const hash = {};
  for (const item of arr)
    hash[item] = true;
  return hash;
}
util$1.toHash = toHash$1;
function alwaysValidSchema$1(it, schema) {
  if (typeof schema == "boolean")
    return schema;
  if (Object.keys(schema).length === 0)
    return true;
  checkUnknownRules$1(it, schema);
  return !schemaHasRules$1(schema, it.self.RULES.all);
}
util$1.alwaysValidSchema = alwaysValidSchema$1;
function checkUnknownRules$1(it, schema = it.schema) {
  const { opts, self: self2 } = it;
  if (!opts.strictSchema)
    return;
  if (typeof schema === "boolean")
    return;
  const rules2 = self2.RULES.keywords;
  for (const key2 in schema) {
    if (!rules2[key2])
      checkStrictMode$1(it, `unknown keyword: "${key2}"`);
  }
}
util$1.checkUnknownRules = checkUnknownRules$1;
function schemaHasRules$1(schema, rules2) {
  if (typeof schema == "boolean")
    return !schema;
  for (const key2 in schema)
    if (rules2[key2])
      return true;
  return false;
}
util$1.schemaHasRules = schemaHasRules$1;
function schemaHasRulesButRef$1(schema, RULES) {
  if (typeof schema == "boolean")
    return !schema;
  for (const key2 in schema)
    if (key2 !== "$ref" && RULES.all[key2])
      return true;
  return false;
}
util$1.schemaHasRulesButRef = schemaHasRulesButRef$1;
function schemaRefOrVal$1({ topSchemaRef, schemaPath }, schema, keyword2, $data) {
  if (!$data) {
    if (typeof schema == "number" || typeof schema == "boolean")
      return schema;
    if (typeof schema == "string")
      return (0, codegen_1$$._)`${schema}`;
  }
  return (0, codegen_1$$._)`${topSchemaRef}${schemaPath}${(0, codegen_1$$.getProperty)(keyword2)}`;
}
util$1.schemaRefOrVal = schemaRefOrVal$1;
function unescapeFragment$1(str) {
  return unescapeJsonPointer$1(decodeURIComponent(str));
}
util$1.unescapeFragment = unescapeFragment$1;
function escapeFragment$1(str) {
  return encodeURIComponent(escapeJsonPointer$1(str));
}
util$1.escapeFragment = escapeFragment$1;
function escapeJsonPointer$1(str) {
  if (typeof str == "number")
    return `${str}`;
  return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
util$1.escapeJsonPointer = escapeJsonPointer$1;
function unescapeJsonPointer$1(str) {
  return str.replace(/~1/g, "/").replace(/~0/g, "~");
}
util$1.unescapeJsonPointer = unescapeJsonPointer$1;
function eachItem$1(xs, f) {
  if (Array.isArray(xs)) {
    for (const x of xs)
      f(x);
  } else {
    f(xs);
  }
}
util$1.eachItem = eachItem$1;
function makeMergeEvaluated$1({ mergeNames, mergeToName, mergeValues, resultToName }) {
  return (gen, from, to, toName) => {
    const res = to === void 0 ? from : to instanceof codegen_1$$.Name ? (from instanceof codegen_1$$.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1$$.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
    return toName === codegen_1$$.Name && !(res instanceof codegen_1$$.Name) ? resultToName(gen, res) : res;
  };
}
util$1.mergeEvaluated = {
  props: makeMergeEvaluated$1({
    mergeNames: (gen, from, to) => gen.if((0, codegen_1$$._)`${to} !== true && ${from} !== undefined`, () => {
      gen.if((0, codegen_1$$._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1$$._)`${to} || {}`).code((0, codegen_1$$._)`Object.assign(${to}, ${from})`));
    }),
    mergeToName: (gen, from, to) => gen.if((0, codegen_1$$._)`${to} !== true`, () => {
      if (from === true) {
        gen.assign(to, true);
      } else {
        gen.assign(to, (0, codegen_1$$._)`${to} || {}`);
        setEvaluated$1(gen, to, from);
      }
    }),
    mergeValues: (from, to) => from === true ? true : { ...from, ...to },
    resultToName: evaluatedPropsToName$1
  }),
  items: makeMergeEvaluated$1({
    mergeNames: (gen, from, to) => gen.if((0, codegen_1$$._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1$$._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
    mergeToName: (gen, from, to) => gen.if((0, codegen_1$$._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1$$._)`${to} > ${from} ? ${to} : ${from}`)),
    mergeValues: (from, to) => from === true ? true : Math.max(from, to),
    resultToName: (gen, items2) => gen.var("items", items2)
  })
};
function evaluatedPropsToName$1(gen, ps) {
  if (ps === true)
    return gen.var("props", true);
  const props = gen.var("props", (0, codegen_1$$._)`{}`);
  if (ps !== void 0)
    setEvaluated$1(gen, props, ps);
  return props;
}
util$1.evaluatedPropsToName = evaluatedPropsToName$1;
function setEvaluated$1(gen, props, ps) {
  Object.keys(ps).forEach((p) => gen.assign((0, codegen_1$$._)`${props}${(0, codegen_1$$.getProperty)(p)}`, true));
}
util$1.setEvaluated = setEvaluated$1;
const snippets$1 = {};
function useFunc$1(gen, f) {
  return gen.scopeValue("func", {
    ref: f,
    code: snippets$1[f.code] || (snippets$1[f.code] = new code_1$l._Code(f.code))
  });
}
util$1.useFunc = useFunc$1;
var Type$1;
(function(Type2) {
  Type2[Type2["Num"] = 0] = "Num";
  Type2[Type2["Str"] = 1] = "Str";
})(Type$1 || (util$1.Type = Type$1 = {}));
function getErrorPath$1(dataProp, dataPropType, jsPropertySyntax) {
  if (dataProp instanceof codegen_1$$.Name) {
    const isNumber = dataPropType === Type$1.Num;
    return jsPropertySyntax ? isNumber ? (0, codegen_1$$._)`"[" + ${dataProp} + "]"` : (0, codegen_1$$._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1$$._)`"/" + ${dataProp}` : (0, codegen_1$$._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
  }
  return jsPropertySyntax ? (0, codegen_1$$.getProperty)(dataProp).toString() : "/" + escapeJsonPointer$1(dataProp);
}
util$1.getErrorPath = getErrorPath$1;
function checkStrictMode$1(it, msg, mode = it.opts.strictSchema) {
  if (!mode)
    return;
  msg = `strict mode: ${msg}`;
  if (mode === true)
    throw new Error(msg);
  it.self.logger.warn(msg);
}
util$1.checkStrictMode = checkStrictMode$1;
var names$3 = {};
Object.defineProperty(names$3, "__esModule", { value: true });
const codegen_1$_ = codegen$1;
const names$2 = {
  // validation function arguments
  data: new codegen_1$_.Name("data"),
  // data passed to validation function
  // args passed from referencing schema
  valCxt: new codegen_1$_.Name("valCxt"),
  // validation/data context - should not be used directly, it is destructured to the names below
  instancePath: new codegen_1$_.Name("instancePath"),
  parentData: new codegen_1$_.Name("parentData"),
  parentDataProperty: new codegen_1$_.Name("parentDataProperty"),
  rootData: new codegen_1$_.Name("rootData"),
  // root data - same as the data passed to the first/top validation function
  dynamicAnchors: new codegen_1$_.Name("dynamicAnchors"),
  // used to support recursiveRef and dynamicRef
  // function scoped variables
  vErrors: new codegen_1$_.Name("vErrors"),
  // null or array of validation errors
  errors: new codegen_1$_.Name("errors"),
  // counter of validation errors
  this: new codegen_1$_.Name("this"),
  // "globals"
  self: new codegen_1$_.Name("self"),
  scope: new codegen_1$_.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new codegen_1$_.Name("json"),
  jsonPos: new codegen_1$_.Name("jsonPos"),
  jsonLen: new codegen_1$_.Name("jsonLen"),
  jsonPart: new codegen_1$_.Name("jsonPart")
};
names$3.default = names$2;
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.extendErrors = exports$1.resetErrorsCount = exports$1.reportExtraError = exports$1.reportError = exports$1.keyword$DataError = exports$1.keywordError = void 0;
  const codegen_12 = codegen$1;
  const util_12 = util$1;
  const names_12 = names$3;
  exports$1.keywordError = {
    message: ({ keyword: keyword2 }) => (0, codegen_12.str)`must pass "${keyword2}" keyword validation`
  };
  exports$1.keyword$DataError = {
    message: ({ keyword: keyword2, schemaType }) => schemaType ? (0, codegen_12.str)`"${keyword2}" keyword must be ${schemaType} ($data)` : (0, codegen_12.str)`"${keyword2}" keyword is invalid ($data)`
  };
  function reportError(cxt, error2 = exports$1.keywordError, errorPaths, overrideAllErrors) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
      addError(gen, errObj);
    } else {
      returnErrors(it, (0, codegen_12._)`[${errObj}]`);
    }
  }
  exports$1.reportError = reportError;
  function reportExtraError(cxt, error2 = exports$1.keywordError, errorPaths) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
      returnErrors(it, names_12.default.vErrors);
    }
  }
  exports$1.reportExtraError = reportExtraError;
  function resetErrorsCount(gen, errsCount) {
    gen.assign(names_12.default.errors, errsCount);
    gen.if((0, codegen_12._)`${names_12.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_12._)`${names_12.default.vErrors}.length`, errsCount), () => gen.assign(names_12.default.vErrors, null)));
  }
  exports$1.resetErrorsCount = resetErrorsCount;
  function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it }) {
    if (errsCount === void 0)
      throw new Error("ajv implementation error");
    const err = gen.name("err");
    gen.forRange("i", errsCount, names_12.default.errors, (i) => {
      gen.const(err, (0, codegen_12._)`${names_12.default.vErrors}[${i}]`);
      gen.if((0, codegen_12._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_12._)`${err}.instancePath`, (0, codegen_12.strConcat)(names_12.default.instancePath, it.errorPath)));
      gen.assign((0, codegen_12._)`${err}.schemaPath`, (0, codegen_12.str)`${it.errSchemaPath}/${keyword2}`);
      if (it.opts.verbose) {
        gen.assign((0, codegen_12._)`${err}.schema`, schemaValue);
        gen.assign((0, codegen_12._)`${err}.data`, data);
      }
    });
  }
  exports$1.extendErrors = extendErrors;
  function addError(gen, errObj) {
    const err = gen.const("err", errObj);
    gen.if((0, codegen_12._)`${names_12.default.vErrors} === null`, () => gen.assign(names_12.default.vErrors, (0, codegen_12._)`[${err}]`), (0, codegen_12._)`${names_12.default.vErrors}.push(${err})`);
    gen.code((0, codegen_12._)`${names_12.default.errors}++`);
  }
  function returnErrors(it, errs) {
    const { gen, validateName, schemaEnv } = it;
    if (schemaEnv.$async) {
      gen.throw((0, codegen_12._)`new ${it.ValidationError}(${errs})`);
    } else {
      gen.assign((0, codegen_12._)`${validateName}.errors`, errs);
      gen.return(false);
    }
  }
  const E = {
    keyword: new codegen_12.Name("keyword"),
    schemaPath: new codegen_12.Name("schemaPath"),
    // also used in JTD errors
    params: new codegen_12.Name("params"),
    propertyName: new codegen_12.Name("propertyName"),
    message: new codegen_12.Name("message"),
    schema: new codegen_12.Name("schema"),
    parentSchema: new codegen_12.Name("parentSchema")
  };
  function errorObjectCode(cxt, error2, errorPaths) {
    const { createErrors } = cxt.it;
    if (createErrors === false)
      return (0, codegen_12._)`{}`;
    return errorObject(cxt, error2, errorPaths);
  }
  function errorObject(cxt, error2, errorPaths = {}) {
    const { gen, it } = cxt;
    const keyValues = [
      errorInstancePath(it, errorPaths),
      errorSchemaPath(cxt, errorPaths)
    ];
    extraErrorProps(cxt, error2, keyValues);
    return gen.object(...keyValues);
  }
  function errorInstancePath({ errorPath }, { instancePath }) {
    const instPath = instancePath ? (0, codegen_12.str)`${errorPath}${(0, util_12.getErrorPath)(instancePath, util_12.Type.Str)}` : errorPath;
    return [names_12.default.instancePath, (0, codegen_12.strConcat)(names_12.default.instancePath, instPath)];
  }
  function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
    let schPath = parentSchema ? errSchemaPath : (0, codegen_12.str)`${errSchemaPath}/${keyword2}`;
    if (schemaPath) {
      schPath = (0, codegen_12.str)`${schPath}${(0, util_12.getErrorPath)(schemaPath, util_12.Type.Str)}`;
    }
    return [E.schemaPath, schPath];
  }
  function extraErrorProps(cxt, { params, message }, keyValues) {
    const { keyword: keyword2, data, schemaValue, it } = cxt;
    const { opts, propertyName, topSchemaRef, schemaPath } = it;
    keyValues.push([E.keyword, keyword2], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_12._)`{}`]);
    if (opts.messages) {
      keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts.verbose) {
      keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_12._)`${topSchemaRef}${schemaPath}`], [names_12.default.data, data]);
    }
    if (propertyName)
      keyValues.push([E.propertyName, propertyName]);
  }
})(errors$4);
Object.defineProperty(boolSchema$1, "__esModule", { value: true });
boolSchema$1.boolOrEmptySchema = boolSchema$1.topBoolOrEmptySchema = void 0;
const errors_1$7 = errors$4;
const codegen_1$Z = codegen$1;
const names_1$d = names$3;
const boolError$1 = {
  message: "boolean schema is false"
};
function topBoolOrEmptySchema$1(it) {
  const { gen, schema, validateName } = it;
  if (schema === false) {
    falseSchemaError$1(it, false);
  } else if (typeof schema == "object" && schema.$async === true) {
    gen.return(names_1$d.default.data);
  } else {
    gen.assign((0, codegen_1$Z._)`${validateName}.errors`, null);
    gen.return(true);
  }
}
boolSchema$1.topBoolOrEmptySchema = topBoolOrEmptySchema$1;
function boolOrEmptySchema$1(it, valid2) {
  const { gen, schema } = it;
  if (schema === false) {
    gen.var(valid2, false);
    falseSchemaError$1(it);
  } else {
    gen.var(valid2, true);
  }
}
boolSchema$1.boolOrEmptySchema = boolOrEmptySchema$1;
function falseSchemaError$1(it, overrideAllErrors) {
  const { gen, data } = it;
  const cxt = {
    gen,
    keyword: "false schema",
    data,
    schema: false,
    schemaCode: false,
    schemaValue: false,
    params: {},
    it
  };
  (0, errors_1$7.reportError)(cxt, boolError$1, void 0, overrideAllErrors);
}
var dataType$1 = {};
var rules$1 = {};
Object.defineProperty(rules$1, "__esModule", { value: true });
rules$1.getRules = rules$1.isJSONType = void 0;
const _jsonTypes$1 = ["string", "number", "integer", "boolean", "null", "object", "array"];
const jsonTypes$1 = new Set(_jsonTypes$1);
function isJSONType$1(x) {
  return typeof x == "string" && jsonTypes$1.has(x);
}
rules$1.isJSONType = isJSONType$1;
function getRules$1() {
  const groups = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...groups, integer: true, boolean: true, null: true },
    rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
rules$1.getRules = getRules$1;
var applicability$1 = {};
Object.defineProperty(applicability$1, "__esModule", { value: true });
applicability$1.shouldUseRule = applicability$1.shouldUseGroup = applicability$1.schemaHasRulesForType = void 0;
function schemaHasRulesForType$1({ schema, self: self2 }, type2) {
  const group = self2.RULES.types[type2];
  return group && group !== true && shouldUseGroup$1(schema, group);
}
applicability$1.schemaHasRulesForType = schemaHasRulesForType$1;
function shouldUseGroup$1(schema, group) {
  return group.rules.some((rule) => shouldUseRule$1(schema, rule));
}
applicability$1.shouldUseGroup = shouldUseGroup$1;
function shouldUseRule$1(schema, rule) {
  var _a;
  return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
}
applicability$1.shouldUseRule = shouldUseRule$1;
Object.defineProperty(dataType$1, "__esModule", { value: true });
dataType$1.reportTypeError = dataType$1.checkDataTypes = dataType$1.checkDataType = dataType$1.coerceAndCheckDataType = dataType$1.getJSONTypes = dataType$1.getSchemaTypes = dataType$1.DataType = void 0;
const rules_1$1 = rules$1;
const applicability_1$3 = applicability$1;
const errors_1$6 = errors$4;
const codegen_1$Y = codegen$1;
const util_1$R = util$1;
var DataType$1;
(function(DataType2) {
  DataType2[DataType2["Correct"] = 0] = "Correct";
  DataType2[DataType2["Wrong"] = 1] = "Wrong";
})(DataType$1 || (dataType$1.DataType = DataType$1 = {}));
function getSchemaTypes$1(schema) {
  const types2 = getJSONTypes$1(schema.type);
  const hasNull = types2.includes("null");
  if (hasNull) {
    if (schema.nullable === false)
      throw new Error("type: null contradicts nullable: false");
  } else {
    if (!types2.length && schema.nullable !== void 0) {
      throw new Error('"nullable" cannot be used without "type"');
    }
    if (schema.nullable === true)
      types2.push("null");
  }
  return types2;
}
dataType$1.getSchemaTypes = getSchemaTypes$1;
function getJSONTypes$1(ts) {
  const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
  if (types2.every(rules_1$1.isJSONType))
    return types2;
  throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
}
dataType$1.getJSONTypes = getJSONTypes$1;
function coerceAndCheckDataType$1(it, types2) {
  const { gen, data, opts } = it;
  const coerceTo = coerceToTypes$1(types2, opts.coerceTypes);
  const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1$3.schemaHasRulesForType)(it, types2[0]));
  if (checkTypes) {
    const wrongType = checkDataTypes$1(types2, data, opts.strictNumbers, DataType$1.Wrong);
    gen.if(wrongType, () => {
      if (coerceTo.length)
        coerceData$1(it, types2, coerceTo);
      else
        reportTypeError$1(it);
    });
  }
  return checkTypes;
}
dataType$1.coerceAndCheckDataType = coerceAndCheckDataType$1;
const COERCIBLE$1 = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
function coerceToTypes$1(types2, coerceTypes) {
  return coerceTypes ? types2.filter((t2) => COERCIBLE$1.has(t2) || coerceTypes === "array" && t2 === "array") : [];
}
function coerceData$1(it, types2, coerceTo) {
  const { gen, data, opts } = it;
  const dataType2 = gen.let("dataType", (0, codegen_1$Y._)`typeof ${data}`);
  const coerced = gen.let("coerced", (0, codegen_1$Y._)`undefined`);
  if (opts.coerceTypes === "array") {
    gen.if((0, codegen_1$Y._)`${dataType2} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1$Y._)`${data}[0]`).assign(dataType2, (0, codegen_1$Y._)`typeof ${data}`).if(checkDataTypes$1(types2, data, opts.strictNumbers), () => gen.assign(coerced, data)));
  }
  gen.if((0, codegen_1$Y._)`${coerced} !== undefined`);
  for (const t2 of coerceTo) {
    if (COERCIBLE$1.has(t2) || t2 === "array" && opts.coerceTypes === "array") {
      coerceSpecificType(t2);
    }
  }
  gen.else();
  reportTypeError$1(it);
  gen.endIf();
  gen.if((0, codegen_1$Y._)`${coerced} !== undefined`, () => {
    gen.assign(data, coerced);
    assignParentData$1(it, coerced);
  });
  function coerceSpecificType(t2) {
    switch (t2) {
      case "string":
        gen.elseIf((0, codegen_1$Y._)`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, (0, codegen_1$Y._)`"" + ${data}`).elseIf((0, codegen_1$Y._)`${data} === null`).assign(coerced, (0, codegen_1$Y._)`""`);
        return;
      case "number":
        gen.elseIf((0, codegen_1$Y._)`${dataType2} == "boolean" || ${data} === null
              || (${dataType2} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1$Y._)`+${data}`);
        return;
      case "integer":
        gen.elseIf((0, codegen_1$Y._)`${dataType2} === "boolean" || ${data} === null
              || (${dataType2} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1$Y._)`+${data}`);
        return;
      case "boolean":
        gen.elseIf((0, codegen_1$Y._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1$Y._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
        return;
      case "null":
        gen.elseIf((0, codegen_1$Y._)`${data} === "" || ${data} === 0 || ${data} === false`);
        gen.assign(coerced, null);
        return;
      case "array":
        gen.elseIf((0, codegen_1$Y._)`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1$Y._)`[${data}]`);
    }
  }
}
function assignParentData$1({ gen, parentData, parentDataProperty }, expr) {
  gen.if((0, codegen_1$Y._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1$Y._)`${parentData}[${parentDataProperty}]`, expr));
}
function checkDataType$1(dataType2, data, strictNums, correct = DataType$1.Correct) {
  const EQ = correct === DataType$1.Correct ? codegen_1$Y.operators.EQ : codegen_1$Y.operators.NEQ;
  let cond;
  switch (dataType2) {
    case "null":
      return (0, codegen_1$Y._)`${data} ${EQ} null`;
    case "array":
      cond = (0, codegen_1$Y._)`Array.isArray(${data})`;
      break;
    case "object":
      cond = (0, codegen_1$Y._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
      break;
    case "integer":
      cond = numCond((0, codegen_1$Y._)`!(${data} % 1) && !isNaN(${data})`);
      break;
    case "number":
      cond = numCond();
      break;
    default:
      return (0, codegen_1$Y._)`typeof ${data} ${EQ} ${dataType2}`;
  }
  return correct === DataType$1.Correct ? cond : (0, codegen_1$Y.not)(cond);
  function numCond(_cond = codegen_1$Y.nil) {
    return (0, codegen_1$Y.and)((0, codegen_1$Y._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1$Y._)`isFinite(${data})` : codegen_1$Y.nil);
  }
}
dataType$1.checkDataType = checkDataType$1;
function checkDataTypes$1(dataTypes, data, strictNums, correct) {
  if (dataTypes.length === 1) {
    return checkDataType$1(dataTypes[0], data, strictNums, correct);
  }
  let cond;
  const types2 = (0, util_1$R.toHash)(dataTypes);
  if (types2.array && types2.object) {
    const notObj = (0, codegen_1$Y._)`typeof ${data} != "object"`;
    cond = types2.null ? notObj : (0, codegen_1$Y._)`!${data} || ${notObj}`;
    delete types2.null;
    delete types2.array;
    delete types2.object;
  } else {
    cond = codegen_1$Y.nil;
  }
  if (types2.number)
    delete types2.integer;
  for (const t2 in types2)
    cond = (0, codegen_1$Y.and)(cond, checkDataType$1(t2, data, strictNums, correct));
  return cond;
}
dataType$1.checkDataTypes = checkDataTypes$1;
const typeError$1 = {
  message: ({ schema }) => `must be ${schema}`,
  params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1$Y._)`{type: ${schema}}` : (0, codegen_1$Y._)`{type: ${schemaValue}}`
};
function reportTypeError$1(it) {
  const cxt = getTypeErrorContext$1(it);
  (0, errors_1$6.reportError)(cxt, typeError$1);
}
dataType$1.reportTypeError = reportTypeError$1;
function getTypeErrorContext$1(it) {
  const { gen, data, schema } = it;
  const schemaCode = (0, util_1$R.schemaRefOrVal)(it, schema, "type");
  return {
    gen,
    keyword: "type",
    data,
    schema: schema.type,
    schemaCode,
    schemaValue: schemaCode,
    parentSchema: schema,
    params: {},
    it
  };
}
var defaults$1 = {};
Object.defineProperty(defaults$1, "__esModule", { value: true });
defaults$1.assignDefaults = void 0;
const codegen_1$X = codegen$1;
const util_1$Q = util$1;
function assignDefaults$1(it, ty) {
  const { properties: properties2, items: items2 } = it.schema;
  if (ty === "object" && properties2) {
    for (const key2 in properties2) {
      assignDefault$1(it, key2, properties2[key2].default);
    }
  } else if (ty === "array" && Array.isArray(items2)) {
    items2.forEach((sch, i) => assignDefault$1(it, i, sch.default));
  }
}
defaults$1.assignDefaults = assignDefaults$1;
function assignDefault$1(it, prop, defaultValue) {
  const { gen, compositeRule, data, opts } = it;
  if (defaultValue === void 0)
    return;
  const childData = (0, codegen_1$X._)`${data}${(0, codegen_1$X.getProperty)(prop)}`;
  if (compositeRule) {
    (0, util_1$Q.checkStrictMode)(it, `default is ignored for: ${childData}`);
    return;
  }
  let condition = (0, codegen_1$X._)`${childData} === undefined`;
  if (opts.useDefaults === "empty") {
    condition = (0, codegen_1$X._)`${condition} || ${childData} === null || ${childData} === ""`;
  }
  gen.if(condition, (0, codegen_1$X._)`${childData} = ${(0, codegen_1$X.stringify)(defaultValue)}`);
}
var keyword$1 = {};
var code$2 = {};
Object.defineProperty(code$2, "__esModule", { value: true });
code$2.validateUnion = code$2.validateArray = code$2.usePattern = code$2.callValidateCode = code$2.schemaProperties = code$2.allSchemaProperties = code$2.noPropertyInData = code$2.propertyInData = code$2.isOwnProperty = code$2.hasPropFunc = code$2.reportMissingProp = code$2.checkMissingProp = code$2.checkReportMissingProp = void 0;
const codegen_1$W = codegen$1;
const util_1$P = util$1;
const names_1$c = names$3;
const util_2$3 = util$1;
function checkReportMissingProp$1(cxt, prop) {
  const { gen, data, it } = cxt;
  gen.if(noPropertyInData$1(gen, data, prop, it.opts.ownProperties), () => {
    cxt.setParams({ missingProperty: (0, codegen_1$W._)`${prop}` }, true);
    cxt.error();
  });
}
code$2.checkReportMissingProp = checkReportMissingProp$1;
function checkMissingProp$1({ gen, data, it: { opts } }, properties2, missing) {
  return (0, codegen_1$W.or)(...properties2.map((prop) => (0, codegen_1$W.and)(noPropertyInData$1(gen, data, prop, opts.ownProperties), (0, codegen_1$W._)`${missing} = ${prop}`)));
}
code$2.checkMissingProp = checkMissingProp$1;
function reportMissingProp$1(cxt, missing) {
  cxt.setParams({ missingProperty: missing }, true);
  cxt.error();
}
code$2.reportMissingProp = reportMissingProp$1;
function hasPropFunc$1(gen) {
  return gen.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: (0, codegen_1$W._)`Object.prototype.hasOwnProperty`
  });
}
code$2.hasPropFunc = hasPropFunc$1;
function isOwnProperty$1(gen, data, property) {
  return (0, codegen_1$W._)`${hasPropFunc$1(gen)}.call(${data}, ${property})`;
}
code$2.isOwnProperty = isOwnProperty$1;
function propertyInData$1(gen, data, property, ownProperties) {
  const cond = (0, codegen_1$W._)`${data}${(0, codegen_1$W.getProperty)(property)} !== undefined`;
  return ownProperties ? (0, codegen_1$W._)`${cond} && ${isOwnProperty$1(gen, data, property)}` : cond;
}
code$2.propertyInData = propertyInData$1;
function noPropertyInData$1(gen, data, property, ownProperties) {
  const cond = (0, codegen_1$W._)`${data}${(0, codegen_1$W.getProperty)(property)} === undefined`;
  return ownProperties ? (0, codegen_1$W.or)(cond, (0, codegen_1$W.not)(isOwnProperty$1(gen, data, property))) : cond;
}
code$2.noPropertyInData = noPropertyInData$1;
function allSchemaProperties$1(schemaMap) {
  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
}
code$2.allSchemaProperties = allSchemaProperties$1;
function schemaProperties$1(it, schemaMap) {
  return allSchemaProperties$1(schemaMap).filter((p) => !(0, util_1$P.alwaysValidSchema)(it, schemaMap[p]));
}
code$2.schemaProperties = schemaProperties$1;
function callValidateCode$1({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
  const dataAndSchema = passSchema ? (0, codegen_1$W._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
  const valCxt = [
    [names_1$c.default.instancePath, (0, codegen_1$W.strConcat)(names_1$c.default.instancePath, errorPath)],
    [names_1$c.default.parentData, it.parentData],
    [names_1$c.default.parentDataProperty, it.parentDataProperty],
    [names_1$c.default.rootData, names_1$c.default.rootData]
  ];
  if (it.opts.dynamicRef)
    valCxt.push([names_1$c.default.dynamicAnchors, names_1$c.default.dynamicAnchors]);
  const args = (0, codegen_1$W._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
  return context !== codegen_1$W.nil ? (0, codegen_1$W._)`${func}.call(${context}, ${args})` : (0, codegen_1$W._)`${func}(${args})`;
}
code$2.callValidateCode = callValidateCode$1;
const newRegExp$1 = (0, codegen_1$W._)`new RegExp`;
function usePattern$1({ gen, it: { opts } }, pattern2) {
  const u = opts.unicodeRegExp ? "u" : "";
  const { regExp } = opts.code;
  const rx = regExp(pattern2, u);
  return gen.scopeValue("pattern", {
    key: rx.toString(),
    ref: rx,
    code: (0, codegen_1$W._)`${regExp.code === "new RegExp" ? newRegExp$1 : (0, util_2$3.useFunc)(gen, regExp)}(${pattern2}, ${u})`
  });
}
code$2.usePattern = usePattern$1;
function validateArray$1(cxt) {
  const { gen, data, keyword: keyword2, it } = cxt;
  const valid2 = gen.name("valid");
  if (it.allErrors) {
    const validArr = gen.let("valid", true);
    validateItems(() => gen.assign(validArr, false));
    return validArr;
  }
  gen.var(valid2, true);
  validateItems(() => gen.break());
  return valid2;
  function validateItems(notValid) {
    const len = gen.const("len", (0, codegen_1$W._)`${data}.length`);
    gen.forRange("i", 0, len, (i) => {
      cxt.subschema({
        keyword: keyword2,
        dataProp: i,
        dataPropType: util_1$P.Type.Num
      }, valid2);
      gen.if((0, codegen_1$W.not)(valid2), notValid);
    });
  }
}
code$2.validateArray = validateArray$1;
function validateUnion$1(cxt) {
  const { gen, schema, keyword: keyword2, it } = cxt;
  if (!Array.isArray(schema))
    throw new Error("ajv implementation error");
  const alwaysValid = schema.some((sch) => (0, util_1$P.alwaysValidSchema)(it, sch));
  if (alwaysValid && !it.opts.unevaluated)
    return;
  const valid2 = gen.let("valid", false);
  const schValid = gen.name("_valid");
  gen.block(() => schema.forEach((_sch, i) => {
    const schCxt = cxt.subschema({
      keyword: keyword2,
      schemaProp: i,
      compositeRule: true
    }, schValid);
    gen.assign(valid2, (0, codegen_1$W._)`${valid2} || ${schValid}`);
    const merged = cxt.mergeValidEvaluated(schCxt, schValid);
    if (!merged)
      gen.if((0, codegen_1$W.not)(valid2));
  }));
  cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
}
code$2.validateUnion = validateUnion$1;
Object.defineProperty(keyword$1, "__esModule", { value: true });
keyword$1.validateKeywordUsage = keyword$1.validSchemaType = keyword$1.funcKeywordCode = keyword$1.macroKeywordCode = void 0;
const codegen_1$V = codegen$1;
const names_1$b = names$3;
const code_1$k = code$2;
const errors_1$5 = errors$4;
function macroKeywordCode$1(cxt, def2) {
  const { gen, keyword: keyword2, schema, parentSchema, it } = cxt;
  const macroSchema = def2.macro.call(it.self, schema, parentSchema, it);
  const schemaRef = useKeyword$1(gen, keyword2, macroSchema);
  if (it.opts.validateSchema !== false)
    it.self.validateSchema(macroSchema, true);
  const valid2 = gen.name("valid");
  cxt.subschema({
    schema: macroSchema,
    schemaPath: codegen_1$V.nil,
    errSchemaPath: `${it.errSchemaPath}/${keyword2}`,
    topSchemaRef: schemaRef,
    compositeRule: true
  }, valid2);
  cxt.pass(valid2, () => cxt.error(true));
}
keyword$1.macroKeywordCode = macroKeywordCode$1;
function funcKeywordCode$1(cxt, def2) {
  var _a;
  const { gen, keyword: keyword2, schema, parentSchema, $data, it } = cxt;
  checkAsyncKeyword$1(it, def2);
  const validate2 = !$data && def2.compile ? def2.compile.call(it.self, schema, parentSchema, it) : def2.validate;
  const validateRef = useKeyword$1(gen, keyword2, validate2);
  const valid2 = gen.let("valid");
  cxt.block$data(valid2, validateKeyword);
  cxt.ok((_a = def2.valid) !== null && _a !== void 0 ? _a : valid2);
  function validateKeyword() {
    if (def2.errors === false) {
      assignValid();
      if (def2.modifying)
        modifyData$1(cxt);
      reportErrs(() => cxt.error());
    } else {
      const ruleErrs = def2.async ? validateAsync() : validateSync();
      if (def2.modifying)
        modifyData$1(cxt);
      reportErrs(() => addErrs$1(cxt, ruleErrs));
    }
  }
  function validateAsync() {
    const ruleErrs = gen.let("ruleErrs", null);
    gen.try(() => assignValid((0, codegen_1$V._)`await `), (e) => gen.assign(valid2, false).if((0, codegen_1$V._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1$V._)`${e}.errors`), () => gen.throw(e)));
    return ruleErrs;
  }
  function validateSync() {
    const validateErrs = (0, codegen_1$V._)`${validateRef}.errors`;
    gen.assign(validateErrs, null);
    assignValid(codegen_1$V.nil);
    return validateErrs;
  }
  function assignValid(_await = def2.async ? (0, codegen_1$V._)`await ` : codegen_1$V.nil) {
    const passCxt = it.opts.passContext ? names_1$b.default.this : names_1$b.default.self;
    const passSchema = !("compile" in def2 && !$data || def2.schema === false);
    gen.assign(valid2, (0, codegen_1$V._)`${_await}${(0, code_1$k.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def2.modifying);
  }
  function reportErrs(errors2) {
    var _a2;
    gen.if((0, codegen_1$V.not)((_a2 = def2.valid) !== null && _a2 !== void 0 ? _a2 : valid2), errors2);
  }
}
keyword$1.funcKeywordCode = funcKeywordCode$1;
function modifyData$1(cxt) {
  const { gen, data, it } = cxt;
  gen.if(it.parentData, () => gen.assign(data, (0, codegen_1$V._)`${it.parentData}[${it.parentDataProperty}]`));
}
function addErrs$1(cxt, errs) {
  const { gen } = cxt;
  gen.if((0, codegen_1$V._)`Array.isArray(${errs})`, () => {
    gen.assign(names_1$b.default.vErrors, (0, codegen_1$V._)`${names_1$b.default.vErrors} === null ? ${errs} : ${names_1$b.default.vErrors}.concat(${errs})`).assign(names_1$b.default.errors, (0, codegen_1$V._)`${names_1$b.default.vErrors}.length`);
    (0, errors_1$5.extendErrors)(cxt);
  }, () => cxt.error());
}
function checkAsyncKeyword$1({ schemaEnv }, def2) {
  if (def2.async && !schemaEnv.$async)
    throw new Error("async keyword in sync schema");
}
function useKeyword$1(gen, keyword2, result) {
  if (result === void 0)
    throw new Error(`keyword "${keyword2}" failed to compile`);
  return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1$V.stringify)(result) });
}
function validSchemaType$1(schema, schemaType, allowUndefined = false) {
  return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
}
keyword$1.validSchemaType = validSchemaType$1;
function validateKeywordUsage$1({ schema, opts, self: self2, errSchemaPath }, def2, keyword2) {
  if (Array.isArray(def2.keyword) ? !def2.keyword.includes(keyword2) : def2.keyword !== keyword2) {
    throw new Error("ajv implementation error");
  }
  const deps = def2.dependencies;
  if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
    throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
  }
  if (def2.validateSchema) {
    const valid2 = def2.validateSchema(schema[keyword2]);
    if (!valid2) {
      const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def2.validateSchema.errors);
      if (opts.validateSchema === "log")
        self2.logger.error(msg);
      else
        throw new Error(msg);
    }
  }
}
keyword$1.validateKeywordUsage = validateKeywordUsage$1;
var subschema$1 = {};
Object.defineProperty(subschema$1, "__esModule", { value: true });
subschema$1.extendSubschemaMode = subschema$1.extendSubschemaData = subschema$1.getSubschema = void 0;
const codegen_1$U = codegen$1;
const util_1$O = util$1;
function getSubschema$1(it, { keyword: keyword2, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
  if (keyword2 !== void 0 && schema !== void 0) {
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  }
  if (keyword2 !== void 0) {
    const sch = it.schema[keyword2];
    return schemaProp === void 0 ? {
      schema: sch,
      schemaPath: (0, codegen_1$U._)`${it.schemaPath}${(0, codegen_1$U.getProperty)(keyword2)}`,
      errSchemaPath: `${it.errSchemaPath}/${keyword2}`
    } : {
      schema: sch[schemaProp],
      schemaPath: (0, codegen_1$U._)`${it.schemaPath}${(0, codegen_1$U.getProperty)(keyword2)}${(0, codegen_1$U.getProperty)(schemaProp)}`,
      errSchemaPath: `${it.errSchemaPath}/${keyword2}/${(0, util_1$O.escapeFragment)(schemaProp)}`
    };
  }
  if (schema !== void 0) {
    if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    }
    return {
      schema,
      schemaPath,
      topSchemaRef,
      errSchemaPath
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
subschema$1.getSubschema = getSubschema$1;
function extendSubschemaData$1(subschema2, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
  if (data !== void 0 && dataProp !== void 0) {
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  }
  const { gen } = it;
  if (dataProp !== void 0) {
    const { errorPath, dataPathArr, opts } = it;
    const nextData = gen.let("data", (0, codegen_1$U._)`${it.data}${(0, codegen_1$U.getProperty)(dataProp)}`, true);
    dataContextProps(nextData);
    subschema2.errorPath = (0, codegen_1$U.str)`${errorPath}${(0, util_1$O.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
    subschema2.parentDataProperty = (0, codegen_1$U._)`${dataProp}`;
    subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
  }
  if (data !== void 0) {
    const nextData = data instanceof codegen_1$U.Name ? data : gen.let("data", data, true);
    dataContextProps(nextData);
    if (propertyName !== void 0)
      subschema2.propertyName = propertyName;
  }
  if (dataTypes)
    subschema2.dataTypes = dataTypes;
  function dataContextProps(_nextData) {
    subschema2.data = _nextData;
    subschema2.dataLevel = it.dataLevel + 1;
    subschema2.dataTypes = [];
    it.definedProperties = /* @__PURE__ */ new Set();
    subschema2.parentData = it.data;
    subschema2.dataNames = [...it.dataNames, _nextData];
  }
}
subschema$1.extendSubschemaData = extendSubschemaData$1;
function extendSubschemaMode$1(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
  if (compositeRule !== void 0)
    subschema2.compositeRule = compositeRule;
  if (createErrors !== void 0)
    subschema2.createErrors = createErrors;
  if (allErrors !== void 0)
    subschema2.allErrors = allErrors;
  subschema2.jtdDiscriminator = jtdDiscriminator;
  subschema2.jtdMetadata = jtdMetadata;
}
subschema$1.extendSubschemaMode = extendSubschemaMode$1;
var resolve$5 = {};
var fastDeepEqual = function equal(a, b) {
  if (a === b) return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    if (a.constructor !== b.constructor) return false;
    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0; )
        if (!equal(a[i], b[i])) return false;
      return true;
    }
    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;
    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
    for (i = length; i-- !== 0; ) {
      var key2 = keys[i];
      if (!equal(a[key2], b[key2])) return false;
    }
    return true;
  }
  return a !== a && b !== b;
};
var jsonSchemaTraverse$1 = { exports: {} };
var traverse$3 = jsonSchemaTraverse$1.exports = function(schema, opts, cb) {
  if (typeof opts == "function") {
    cb = opts;
    opts = {};
  }
  cb = opts.cb || cb;
  var pre = typeof cb == "function" ? cb : cb.pre || function() {
  };
  var post = cb.post || function() {
  };
  _traverse$1(opts, pre, post, schema, "", schema);
};
traverse$3.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true,
  if: true,
  then: true,
  else: true
};
traverse$3.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};
traverse$3.propsKeywords = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};
traverse$3.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};
function _traverse$1(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == "object" && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key2 in schema) {
      var sch = schema[key2];
      if (Array.isArray(sch)) {
        if (key2 in traverse$3.arrayKeywords) {
          for (var i = 0; i < sch.length; i++)
            _traverse$1(opts, pre, post, sch[i], jsonPtr + "/" + key2 + "/" + i, rootSchema, jsonPtr, key2, schema, i);
        }
      } else if (key2 in traverse$3.propsKeywords) {
        if (sch && typeof sch == "object") {
          for (var prop in sch)
            _traverse$1(opts, pre, post, sch[prop], jsonPtr + "/" + key2 + "/" + escapeJsonPtr$1(prop), rootSchema, jsonPtr, key2, schema, prop);
        }
      } else if (key2 in traverse$3.keywords || opts.allKeys && !(key2 in traverse$3.skipKeywords)) {
        _traverse$1(opts, pre, post, sch, jsonPtr + "/" + key2, rootSchema, jsonPtr, key2, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}
function escapeJsonPtr$1(str) {
  return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
var jsonSchemaTraverseExports$1 = jsonSchemaTraverse$1.exports;
Object.defineProperty(resolve$5, "__esModule", { value: true });
resolve$5.getSchemaRefs = resolve$5.resolveUrl = resolve$5.normalizeId = resolve$5._getFullPath = resolve$5.getFullPath = resolve$5.inlineRef = void 0;
const util_1$N = util$1;
const equal$6 = fastDeepEqual;
const traverse$2 = jsonSchemaTraverseExports$1;
const SIMPLE_INLINED$1 = /* @__PURE__ */ new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function inlineRef$1(schema, limit2 = true) {
  if (typeof schema == "boolean")
    return true;
  if (limit2 === true)
    return !hasRef$1(schema);
  if (!limit2)
    return false;
  return countKeys$1(schema) <= limit2;
}
resolve$5.inlineRef = inlineRef$1;
const REF_KEYWORDS$1 = /* @__PURE__ */ new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function hasRef$1(schema) {
  for (const key2 in schema) {
    if (REF_KEYWORDS$1.has(key2))
      return true;
    const sch = schema[key2];
    if (Array.isArray(sch) && sch.some(hasRef$1))
      return true;
    if (typeof sch == "object" && hasRef$1(sch))
      return true;
  }
  return false;
}
function countKeys$1(schema) {
  let count = 0;
  for (const key2 in schema) {
    if (key2 === "$ref")
      return Infinity;
    count++;
    if (SIMPLE_INLINED$1.has(key2))
      continue;
    if (typeof schema[key2] == "object") {
      (0, util_1$N.eachItem)(schema[key2], (sch) => count += countKeys$1(sch));
    }
    if (count === Infinity)
      return Infinity;
  }
  return count;
}
function getFullPath$1(resolver, id2 = "", normalize2) {
  if (normalize2 !== false)
    id2 = normalizeId$1(id2);
  const p = resolver.parse(id2);
  return _getFullPath$1(resolver, p);
}
resolve$5.getFullPath = getFullPath$1;
function _getFullPath$1(resolver, p) {
  const serialized = resolver.serialize(p);
  return serialized.split("#")[0] + "#";
}
resolve$5._getFullPath = _getFullPath$1;
const TRAILING_SLASH_HASH$1 = /#\/?$/;
function normalizeId$1(id2) {
  return id2 ? id2.replace(TRAILING_SLASH_HASH$1, "") : "";
}
resolve$5.normalizeId = normalizeId$1;
function resolveUrl$1(resolver, baseId, id2) {
  id2 = normalizeId$1(id2);
  return resolver.resolve(baseId, id2);
}
resolve$5.resolveUrl = resolveUrl$1;
const ANCHOR$1 = /^[a-z_][-a-z0-9._]*$/i;
function getSchemaRefs$1(schema, baseId) {
  if (typeof schema == "boolean")
    return {};
  const { schemaId, uriResolver } = this.opts;
  const schId = normalizeId$1(schema[schemaId] || baseId);
  const baseIds = { "": schId };
  const pathPrefix = getFullPath$1(uriResolver, schId, false);
  const localRefs = {};
  const schemaRefs = /* @__PURE__ */ new Set();
  traverse$2(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
    if (parentJsonPtr === void 0)
      return;
    const fullPath = pathPrefix + jsonPtr;
    let innerBaseId = baseIds[parentJsonPtr];
    if (typeof sch[schemaId] == "string")
      innerBaseId = addRef.call(this, sch[schemaId]);
    addAnchor.call(this, sch.$anchor);
    addAnchor.call(this, sch.$dynamicAnchor);
    baseIds[jsonPtr] = innerBaseId;
    function addRef(ref2) {
      const _resolve = this.opts.uriResolver.resolve;
      ref2 = normalizeId$1(innerBaseId ? _resolve(innerBaseId, ref2) : ref2);
      if (schemaRefs.has(ref2))
        throw ambiguos(ref2);
      schemaRefs.add(ref2);
      let schOrRef = this.refs[ref2];
      if (typeof schOrRef == "string")
        schOrRef = this.refs[schOrRef];
      if (typeof schOrRef == "object") {
        checkAmbiguosRef(sch, schOrRef.schema, ref2);
      } else if (ref2 !== normalizeId$1(fullPath)) {
        if (ref2[0] === "#") {
          checkAmbiguosRef(sch, localRefs[ref2], ref2);
          localRefs[ref2] = sch;
        } else {
          this.refs[ref2] = fullPath;
        }
      }
      return ref2;
    }
    function addAnchor(anchor) {
      if (typeof anchor == "string") {
        if (!ANCHOR$1.test(anchor))
          throw new Error(`invalid anchor "${anchor}"`);
        addRef.call(this, `#${anchor}`);
      }
    }
  });
  return localRefs;
  function checkAmbiguosRef(sch1, sch2, ref2) {
    if (sch2 !== void 0 && !equal$6(sch1, sch2))
      throw ambiguos(ref2);
  }
  function ambiguos(ref2) {
    return new Error(`reference "${ref2}" resolves to more than one schema`);
  }
}
resolve$5.getSchemaRefs = getSchemaRefs$1;
Object.defineProperty(validate$1, "__esModule", { value: true });
validate$1.getData = validate$1.KeywordCxt = validate$1.validateFunctionCode = void 0;
const boolSchema_1$1 = boolSchema$1;
const dataType_1$3 = dataType$1;
const applicability_1$2 = applicability$1;
const dataType_2$1 = dataType$1;
const defaults_1$1 = defaults$1;
const keyword_1$1 = keyword$1;
const subschema_1$1 = subschema$1;
const codegen_1$T = codegen$1;
const names_1$a = names$3;
const resolve_1$5 = resolve$5;
const util_1$M = util$1;
const errors_1$4 = errors$4;
function validateFunctionCode$1(it) {
  if (isSchemaObj$1(it)) {
    checkKeywords$1(it);
    if (schemaCxtHasRules$1(it)) {
      topSchemaObjCode$1(it);
      return;
    }
  }
  validateFunction$1(it, () => (0, boolSchema_1$1.topBoolOrEmptySchema)(it));
}
validate$1.validateFunctionCode = validateFunctionCode$1;
function validateFunction$1({ gen, validateName, schema, schemaEnv, opts }, body) {
  if (opts.code.es5) {
    gen.func(validateName, (0, codegen_1$T._)`${names_1$a.default.data}, ${names_1$a.default.valCxt}`, schemaEnv.$async, () => {
      gen.code((0, codegen_1$T._)`"use strict"; ${funcSourceUrl$1(schema, opts)}`);
      destructureValCxtES5$1(gen, opts);
      gen.code(body);
    });
  } else {
    gen.func(validateName, (0, codegen_1$T._)`${names_1$a.default.data}, ${destructureValCxt$1(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl$1(schema, opts)).code(body));
  }
}
function destructureValCxt$1(opts) {
  return (0, codegen_1$T._)`{${names_1$a.default.instancePath}="", ${names_1$a.default.parentData}, ${names_1$a.default.parentDataProperty}, ${names_1$a.default.rootData}=${names_1$a.default.data}${opts.dynamicRef ? (0, codegen_1$T._)`, ${names_1$a.default.dynamicAnchors}={}` : codegen_1$T.nil}}={}`;
}
function destructureValCxtES5$1(gen, opts) {
  gen.if(names_1$a.default.valCxt, () => {
    gen.var(names_1$a.default.instancePath, (0, codegen_1$T._)`${names_1$a.default.valCxt}.${names_1$a.default.instancePath}`);
    gen.var(names_1$a.default.parentData, (0, codegen_1$T._)`${names_1$a.default.valCxt}.${names_1$a.default.parentData}`);
    gen.var(names_1$a.default.parentDataProperty, (0, codegen_1$T._)`${names_1$a.default.valCxt}.${names_1$a.default.parentDataProperty}`);
    gen.var(names_1$a.default.rootData, (0, codegen_1$T._)`${names_1$a.default.valCxt}.${names_1$a.default.rootData}`);
    if (opts.dynamicRef)
      gen.var(names_1$a.default.dynamicAnchors, (0, codegen_1$T._)`${names_1$a.default.valCxt}.${names_1$a.default.dynamicAnchors}`);
  }, () => {
    gen.var(names_1$a.default.instancePath, (0, codegen_1$T._)`""`);
    gen.var(names_1$a.default.parentData, (0, codegen_1$T._)`undefined`);
    gen.var(names_1$a.default.parentDataProperty, (0, codegen_1$T._)`undefined`);
    gen.var(names_1$a.default.rootData, names_1$a.default.data);
    if (opts.dynamicRef)
      gen.var(names_1$a.default.dynamicAnchors, (0, codegen_1$T._)`{}`);
  });
}
function topSchemaObjCode$1(it) {
  const { schema, opts, gen } = it;
  validateFunction$1(it, () => {
    if (opts.$comment && schema.$comment)
      commentKeyword$1(it);
    checkNoDefault$1(it);
    gen.let(names_1$a.default.vErrors, null);
    gen.let(names_1$a.default.errors, 0);
    if (opts.unevaluated)
      resetEvaluated$1(it);
    typeAndKeywords$1(it);
    returnResults$1(it);
  });
  return;
}
function resetEvaluated$1(it) {
  const { gen, validateName } = it;
  it.evaluated = gen.const("evaluated", (0, codegen_1$T._)`${validateName}.evaluated`);
  gen.if((0, codegen_1$T._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1$T._)`${it.evaluated}.props`, (0, codegen_1$T._)`undefined`));
  gen.if((0, codegen_1$T._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1$T._)`${it.evaluated}.items`, (0, codegen_1$T._)`undefined`));
}
function funcSourceUrl$1(schema, opts) {
  const schId = typeof schema == "object" && schema[opts.schemaId];
  return schId && (opts.code.source || opts.code.process) ? (0, codegen_1$T._)`/*# sourceURL=${schId} */` : codegen_1$T.nil;
}
function subschemaCode$1(it, valid2) {
  if (isSchemaObj$1(it)) {
    checkKeywords$1(it);
    if (schemaCxtHasRules$1(it)) {
      subSchemaObjCode$1(it, valid2);
      return;
    }
  }
  (0, boolSchema_1$1.boolOrEmptySchema)(it, valid2);
}
function schemaCxtHasRules$1({ schema, self: self2 }) {
  if (typeof schema == "boolean")
    return !schema;
  for (const key2 in schema)
    if (self2.RULES.all[key2])
      return true;
  return false;
}
function isSchemaObj$1(it) {
  return typeof it.schema != "boolean";
}
function subSchemaObjCode$1(it, valid2) {
  const { schema, gen, opts } = it;
  if (opts.$comment && schema.$comment)
    commentKeyword$1(it);
  updateContext$1(it);
  checkAsyncSchema$1(it);
  const errsCount = gen.const("_errs", names_1$a.default.errors);
  typeAndKeywords$1(it, errsCount);
  gen.var(valid2, (0, codegen_1$T._)`${errsCount} === ${names_1$a.default.errors}`);
}
function checkKeywords$1(it) {
  (0, util_1$M.checkUnknownRules)(it);
  checkRefsAndKeywords$1(it);
}
function typeAndKeywords$1(it, errsCount) {
  if (it.opts.jtd)
    return schemaKeywords$1(it, [], false, errsCount);
  const types2 = (0, dataType_1$3.getSchemaTypes)(it.schema);
  const checkedTypes = (0, dataType_1$3.coerceAndCheckDataType)(it, types2);
  schemaKeywords$1(it, types2, !checkedTypes, errsCount);
}
function checkRefsAndKeywords$1(it) {
  const { schema, errSchemaPath, opts, self: self2 } = it;
  if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1$M.schemaHasRulesButRef)(schema, self2.RULES)) {
    self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
  }
}
function checkNoDefault$1(it) {
  const { schema, opts } = it;
  if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
    (0, util_1$M.checkStrictMode)(it, "default is ignored in the schema root");
  }
}
function updateContext$1(it) {
  const schId = it.schema[it.opts.schemaId];
  if (schId)
    it.baseId = (0, resolve_1$5.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
}
function checkAsyncSchema$1(it) {
  if (it.schema.$async && !it.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function commentKeyword$1({ gen, schemaEnv, schema, errSchemaPath, opts }) {
  const msg = schema.$comment;
  if (opts.$comment === true) {
    gen.code((0, codegen_1$T._)`${names_1$a.default.self}.logger.log(${msg})`);
  } else if (typeof opts.$comment == "function") {
    const schemaPath = (0, codegen_1$T.str)`${errSchemaPath}/$comment`;
    const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
    gen.code((0, codegen_1$T._)`${names_1$a.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
  }
}
function returnResults$1(it) {
  const { gen, schemaEnv, validateName, ValidationError: ValidationError3, opts } = it;
  if (schemaEnv.$async) {
    gen.if((0, codegen_1$T._)`${names_1$a.default.errors} === 0`, () => gen.return(names_1$a.default.data), () => gen.throw((0, codegen_1$T._)`new ${ValidationError3}(${names_1$a.default.vErrors})`));
  } else {
    gen.assign((0, codegen_1$T._)`${validateName}.errors`, names_1$a.default.vErrors);
    if (opts.unevaluated)
      assignEvaluated$1(it);
    gen.return((0, codegen_1$T._)`${names_1$a.default.errors} === 0`);
  }
}
function assignEvaluated$1({ gen, evaluated, props, items: items2 }) {
  if (props instanceof codegen_1$T.Name)
    gen.assign((0, codegen_1$T._)`${evaluated}.props`, props);
  if (items2 instanceof codegen_1$T.Name)
    gen.assign((0, codegen_1$T._)`${evaluated}.items`, items2);
}
function schemaKeywords$1(it, types2, typeErrors, errsCount) {
  const { gen, schema, data, allErrors, opts, self: self2 } = it;
  const { RULES } = self2;
  if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1$M.schemaHasRulesButRef)(schema, RULES))) {
    gen.block(() => keywordCode$1(it, "$ref", RULES.all.$ref.definition));
    return;
  }
  if (!opts.jtd)
    checkStrictTypes$1(it, types2);
  gen.block(() => {
    for (const group of RULES.rules)
      groupKeywords(group);
    groupKeywords(RULES.post);
  });
  function groupKeywords(group) {
    if (!(0, applicability_1$2.shouldUseGroup)(schema, group))
      return;
    if (group.type) {
      gen.if((0, dataType_2$1.checkDataType)(group.type, data, opts.strictNumbers));
      iterateKeywords$1(it, group);
      if (types2.length === 1 && types2[0] === group.type && typeErrors) {
        gen.else();
        (0, dataType_2$1.reportTypeError)(it);
      }
      gen.endIf();
    } else {
      iterateKeywords$1(it, group);
    }
    if (!allErrors)
      gen.if((0, codegen_1$T._)`${names_1$a.default.errors} === ${errsCount || 0}`);
  }
}
function iterateKeywords$1(it, group) {
  const { gen, schema, opts: { useDefaults } } = it;
  if (useDefaults)
    (0, defaults_1$1.assignDefaults)(it, group.type);
  gen.block(() => {
    for (const rule of group.rules) {
      if ((0, applicability_1$2.shouldUseRule)(schema, rule)) {
        keywordCode$1(it, rule.keyword, rule.definition, group.type);
      }
    }
  });
}
function checkStrictTypes$1(it, types2) {
  if (it.schemaEnv.meta || !it.opts.strictTypes)
    return;
  checkContextTypes$1(it, types2);
  if (!it.opts.allowUnionTypes)
    checkMultipleTypes$1(it, types2);
  checkKeywordTypes$1(it, it.dataTypes);
}
function checkContextTypes$1(it, types2) {
  if (!types2.length)
    return;
  if (!it.dataTypes.length) {
    it.dataTypes = types2;
    return;
  }
  types2.forEach((t2) => {
    if (!includesType$1(it.dataTypes, t2)) {
      strictTypesError$1(it, `type "${t2}" not allowed by context "${it.dataTypes.join(",")}"`);
    }
  });
  narrowSchemaTypes$1(it, types2);
}
function checkMultipleTypes$1(it, ts) {
  if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
    strictTypesError$1(it, "use allowUnionTypes to allow union type keyword");
  }
}
function checkKeywordTypes$1(it, ts) {
  const rules2 = it.self.RULES.all;
  for (const keyword2 in rules2) {
    const rule = rules2[keyword2];
    if (typeof rule == "object" && (0, applicability_1$2.shouldUseRule)(it.schema, rule)) {
      const { type: type2 } = rule.definition;
      if (type2.length && !type2.some((t2) => hasApplicableType$1(ts, t2))) {
        strictTypesError$1(it, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
      }
    }
  }
}
function hasApplicableType$1(schTs, kwdT) {
  return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
}
function includesType$1(ts, t2) {
  return ts.includes(t2) || t2 === "integer" && ts.includes("number");
}
function narrowSchemaTypes$1(it, withTypes) {
  const ts = [];
  for (const t2 of it.dataTypes) {
    if (includesType$1(withTypes, t2))
      ts.push(t2);
    else if (withTypes.includes("integer") && t2 === "number")
      ts.push("integer");
  }
  it.dataTypes = ts;
}
function strictTypesError$1(it, msg) {
  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
  msg += ` at "${schemaPath}" (strictTypes)`;
  (0, util_1$M.checkStrictMode)(it, msg, it.opts.strictTypes);
}
let KeywordCxt$1 = class KeywordCxt {
  constructor(it, def2, keyword2) {
    (0, keyword_1$1.validateKeywordUsage)(it, def2, keyword2);
    this.gen = it.gen;
    this.allErrors = it.allErrors;
    this.keyword = keyword2;
    this.data = it.data;
    this.schema = it.schema[keyword2];
    this.$data = def2.$data && it.opts.$data && this.schema && this.schema.$data;
    this.schemaValue = (0, util_1$M.schemaRefOrVal)(it, this.schema, keyword2, this.$data);
    this.schemaType = def2.schemaType;
    this.parentSchema = it.schema;
    this.params = {};
    this.it = it;
    this.def = def2;
    if (this.$data) {
      this.schemaCode = it.gen.const("vSchema", getData$1(this.$data, it));
    } else {
      this.schemaCode = this.schemaValue;
      if (!(0, keyword_1$1.validSchemaType)(this.schema, def2.schemaType, def2.allowUndefined)) {
        throw new Error(`${keyword2} value must be ${JSON.stringify(def2.schemaType)}`);
      }
    }
    if ("code" in def2 ? def2.trackErrors : def2.errors !== false) {
      this.errsCount = it.gen.const("_errs", names_1$a.default.errors);
    }
  }
  result(condition, successAction, failAction) {
    this.failResult((0, codegen_1$T.not)(condition), successAction, failAction);
  }
  failResult(condition, successAction, failAction) {
    this.gen.if(condition);
    if (failAction)
      failAction();
    else
      this.error();
    if (successAction) {
      this.gen.else();
      successAction();
      if (this.allErrors)
        this.gen.endIf();
    } else {
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
  }
  pass(condition, failAction) {
    this.failResult((0, codegen_1$T.not)(condition), void 0, failAction);
  }
  fail(condition) {
    if (condition === void 0) {
      this.error();
      if (!this.allErrors)
        this.gen.if(false);
      return;
    }
    this.gen.if(condition);
    this.error();
    if (this.allErrors)
      this.gen.endIf();
    else
      this.gen.else();
  }
  fail$data(condition) {
    if (!this.$data)
      return this.fail(condition);
    const { schemaCode } = this;
    this.fail((0, codegen_1$T._)`${schemaCode} !== undefined && (${(0, codegen_1$T.or)(this.invalid$data(), condition)})`);
  }
  error(append, errorParams, errorPaths) {
    if (errorParams) {
      this.setParams(errorParams);
      this._error(append, errorPaths);
      this.setParams({});
      return;
    }
    this._error(append, errorPaths);
  }
  _error(append, errorPaths) {
    (append ? errors_1$4.reportExtraError : errors_1$4.reportError)(this, this.def.error, errorPaths);
  }
  $dataError() {
    (0, errors_1$4.reportError)(this, this.def.$dataError || errors_1$4.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, errors_1$4.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(cond) {
    if (!this.allErrors)
      this.gen.if(cond);
  }
  setParams(obj, assign) {
    if (assign)
      Object.assign(this.params, obj);
    else
      this.params = obj;
  }
  block$data(valid2, codeBlock, $dataValid = codegen_1$T.nil) {
    this.gen.block(() => {
      this.check$data(valid2, $dataValid);
      codeBlock();
    });
  }
  check$data(valid2 = codegen_1$T.nil, $dataValid = codegen_1$T.nil) {
    if (!this.$data)
      return;
    const { gen, schemaCode, schemaType, def: def2 } = this;
    gen.if((0, codegen_1$T.or)((0, codegen_1$T._)`${schemaCode} === undefined`, $dataValid));
    if (valid2 !== codegen_1$T.nil)
      gen.assign(valid2, true);
    if (schemaType.length || def2.validateSchema) {
      gen.elseIf(this.invalid$data());
      this.$dataError();
      if (valid2 !== codegen_1$T.nil)
        gen.assign(valid2, false);
    }
    gen.else();
  }
  invalid$data() {
    const { gen, schemaCode, schemaType, def: def2, it } = this;
    return (0, codegen_1$T.or)(wrong$DataType(), invalid$DataSchema());
    function wrong$DataType() {
      if (schemaType.length) {
        if (!(schemaCode instanceof codegen_1$T.Name))
          throw new Error("ajv implementation error");
        const st = Array.isArray(schemaType) ? schemaType : [schemaType];
        return (0, codegen_1$T._)`${(0, dataType_2$1.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2$1.DataType.Wrong)}`;
      }
      return codegen_1$T.nil;
    }
    function invalid$DataSchema() {
      if (def2.validateSchema) {
        const validateSchemaRef = gen.scopeValue("validate$data", { ref: def2.validateSchema });
        return (0, codegen_1$T._)`!${validateSchemaRef}(${schemaCode})`;
      }
      return codegen_1$T.nil;
    }
  }
  subschema(appl, valid2) {
    const subschema2 = (0, subschema_1$1.getSubschema)(this.it, appl);
    (0, subschema_1$1.extendSubschemaData)(subschema2, this.it, appl);
    (0, subschema_1$1.extendSubschemaMode)(subschema2, appl);
    const nextContext = { ...this.it, ...subschema2, items: void 0, props: void 0 };
    subschemaCode$1(nextContext, valid2);
    return nextContext;
  }
  mergeEvaluated(schemaCxt, toName) {
    const { it, gen } = this;
    if (!it.opts.unevaluated)
      return;
    if (it.props !== true && schemaCxt.props !== void 0) {
      it.props = util_1$M.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
    }
    if (it.items !== true && schemaCxt.items !== void 0) {
      it.items = util_1$M.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
    }
  }
  mergeValidEvaluated(schemaCxt, valid2) {
    const { it, gen } = this;
    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
      gen.if(valid2, () => this.mergeEvaluated(schemaCxt, codegen_1$T.Name));
      return true;
    }
  }
};
validate$1.KeywordCxt = KeywordCxt$1;
function keywordCode$1(it, keyword2, def2, ruleType) {
  const cxt = new KeywordCxt$1(it, def2, keyword2);
  if ("code" in def2) {
    def2.code(cxt, ruleType);
  } else if (cxt.$data && def2.validate) {
    (0, keyword_1$1.funcKeywordCode)(cxt, def2);
  } else if ("macro" in def2) {
    (0, keyword_1$1.macroKeywordCode)(cxt, def2);
  } else if (def2.compile || def2.validate) {
    (0, keyword_1$1.funcKeywordCode)(cxt, def2);
  }
}
const JSON_POINTER$1 = /^\/(?:[^~]|~0|~1)*$/;
const RELATIVE_JSON_POINTER$1 = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData$1($data, { dataLevel, dataNames, dataPathArr }) {
  let jsonPointer;
  let data;
  if ($data === "")
    return names_1$a.default.rootData;
  if ($data[0] === "/") {
    if (!JSON_POINTER$1.test($data))
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    jsonPointer = $data;
    data = names_1$a.default.rootData;
  } else {
    const matches = RELATIVE_JSON_POINTER$1.exec($data);
    if (!matches)
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    const up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer === "#") {
      if (up >= dataLevel)
        throw new Error(errorMsg("property/index", up));
      return dataPathArr[dataLevel - up];
    }
    if (up > dataLevel)
      throw new Error(errorMsg("data", up));
    data = dataNames[dataLevel - up];
    if (!jsonPointer)
      return data;
  }
  let expr = data;
  const segments = jsonPointer.split("/");
  for (const segment of segments) {
    if (segment) {
      data = (0, codegen_1$T._)`${data}${(0, codegen_1$T.getProperty)((0, util_1$M.unescapeJsonPointer)(segment))}`;
      expr = (0, codegen_1$T._)`${expr} && ${data}`;
    }
  }
  return expr;
  function errorMsg(pointerType, up) {
    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
  }
}
validate$1.getData = getData$1;
var validation_error$1 = {};
Object.defineProperty(validation_error$1, "__esModule", { value: true });
let ValidationError$1 = class ValidationError extends Error {
  constructor(errors2) {
    super("validation failed");
    this.errors = errors2;
    this.ajv = this.validation = true;
  }
};
validation_error$1.default = ValidationError$1;
var ref_error$1 = {};
Object.defineProperty(ref_error$1, "__esModule", { value: true });
const resolve_1$4 = resolve$5;
let MissingRefError$1 = class MissingRefError extends Error {
  constructor(resolver, baseId, ref2, msg) {
    super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
    this.missingRef = (0, resolve_1$4.resolveUrl)(resolver, baseId, ref2);
    this.missingSchema = (0, resolve_1$4.normalizeId)((0, resolve_1$4.getFullPath)(resolver, this.missingRef));
  }
};
ref_error$1.default = MissingRefError$1;
var compile$1 = {};
Object.defineProperty(compile$1, "__esModule", { value: true });
compile$1.resolveSchema = compile$1.getCompilingSchema = compile$1.resolveRef = compile$1.compileSchema = compile$1.SchemaEnv = void 0;
const codegen_1$S = codegen$1;
const validation_error_1$1 = validation_error$1;
const names_1$9 = names$3;
const resolve_1$3 = resolve$5;
const util_1$L = util$1;
const validate_1$3 = validate$1;
let SchemaEnv$1 = class SchemaEnv {
  constructor(env2) {
    var _a;
    this.refs = {};
    this.dynamicAnchors = {};
    let schema;
    if (typeof env2.schema == "object")
      schema = env2.schema;
    this.schema = env2.schema;
    this.schemaId = env2.schemaId;
    this.root = env2.root || this;
    this.baseId = (_a = env2.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1$3.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env2.schemaId || "$id"]);
    this.schemaPath = env2.schemaPath;
    this.localRefs = env2.localRefs;
    this.meta = env2.meta;
    this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
    this.refs = {};
  }
};
compile$1.SchemaEnv = SchemaEnv$1;
function compileSchema$1(sch) {
  const _sch = getCompilingSchema$1.call(this, sch);
  if (_sch)
    return _sch;
  const rootId = (0, resolve_1$3.getFullPath)(this.opts.uriResolver, sch.root.baseId);
  const { es5, lines } = this.opts.code;
  const { ownProperties } = this.opts;
  const gen = new codegen_1$S.CodeGen(this.scope, { es5, lines, ownProperties });
  let _ValidationError;
  if (sch.$async) {
    _ValidationError = gen.scopeValue("Error", {
      ref: validation_error_1$1.default,
      code: (0, codegen_1$S._)`require("ajv/dist/runtime/validation_error").default`
    });
  }
  const validateName = gen.scopeName("validate");
  sch.validateName = validateName;
  const schemaCxt = {
    gen,
    allErrors: this.opts.allErrors,
    data: names_1$9.default.data,
    parentData: names_1$9.default.parentData,
    parentDataProperty: names_1$9.default.parentDataProperty,
    dataNames: [names_1$9.default.data],
    dataPathArr: [codegen_1$S.nil],
    // TODO can its length be used as dataLevel if nil is removed?
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
    topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1$S.stringify)(sch.schema) } : { ref: sch.schema }),
    validateName,
    ValidationError: _ValidationError,
    schema: sch.schema,
    schemaEnv: sch,
    rootId,
    baseId: sch.baseId || rootId,
    schemaPath: codegen_1$S.nil,
    errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, codegen_1$S._)`""`,
    opts: this.opts,
    self: this
  };
  let sourceCode;
  try {
    this._compilations.add(sch);
    (0, validate_1$3.validateFunctionCode)(schemaCxt);
    gen.optimize(this.opts.code.optimize);
    const validateCode = gen.toString();
    sourceCode = `${gen.scopeRefs(names_1$9.default.scope)}return ${validateCode}`;
    if (this.opts.code.process)
      sourceCode = this.opts.code.process(sourceCode, sch);
    const makeValidate = new Function(`${names_1$9.default.self}`, `${names_1$9.default.scope}`, sourceCode);
    const validate2 = makeValidate(this, this.scope.get());
    this.scope.value(validateName, { ref: validate2 });
    validate2.errors = null;
    validate2.schema = sch.schema;
    validate2.schemaEnv = sch;
    if (sch.$async)
      validate2.$async = true;
    if (this.opts.code.source === true) {
      validate2.source = { validateName, validateCode, scopeValues: gen._values };
    }
    if (this.opts.unevaluated) {
      const { props, items: items2 } = schemaCxt;
      validate2.evaluated = {
        props: props instanceof codegen_1$S.Name ? void 0 : props,
        items: items2 instanceof codegen_1$S.Name ? void 0 : items2,
        dynamicProps: props instanceof codegen_1$S.Name,
        dynamicItems: items2 instanceof codegen_1$S.Name
      };
      if (validate2.source)
        validate2.source.evaluated = (0, codegen_1$S.stringify)(validate2.evaluated);
    }
    sch.validate = validate2;
    return sch;
  } catch (e) {
    delete sch.validate;
    delete sch.validateName;
    if (sourceCode)
      this.logger.error("Error compiling schema, function code:", sourceCode);
    throw e;
  } finally {
    this._compilations.delete(sch);
  }
}
compile$1.compileSchema = compileSchema$1;
function resolveRef$1(root, baseId, ref2) {
  var _a;
  ref2 = (0, resolve_1$3.resolveUrl)(this.opts.uriResolver, baseId, ref2);
  const schOrFunc = root.refs[ref2];
  if (schOrFunc)
    return schOrFunc;
  let _sch = resolve$4.call(this, root, ref2);
  if (_sch === void 0) {
    const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref2];
    const { schemaId } = this.opts;
    if (schema)
      _sch = new SchemaEnv$1({ schema, schemaId, root, baseId });
  }
  if (_sch === void 0)
    return;
  return root.refs[ref2] = inlineOrCompile$1.call(this, _sch);
}
compile$1.resolveRef = resolveRef$1;
function inlineOrCompile$1(sch) {
  if ((0, resolve_1$3.inlineRef)(sch.schema, this.opts.inlineRefs))
    return sch.schema;
  return sch.validate ? sch : compileSchema$1.call(this, sch);
}
function getCompilingSchema$1(schEnv) {
  for (const sch of this._compilations) {
    if (sameSchemaEnv$1(sch, schEnv))
      return sch;
  }
}
compile$1.getCompilingSchema = getCompilingSchema$1;
function sameSchemaEnv$1(s1, s2) {
  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
}
function resolve$4(root, ref2) {
  let sch;
  while (typeof (sch = this.refs[ref2]) == "string")
    ref2 = sch;
  return sch || this.schemas[ref2] || resolveSchema$1.call(this, root, ref2);
}
function resolveSchema$1(root, ref2) {
  const p = this.opts.uriResolver.parse(ref2);
  const refPath = (0, resolve_1$3._getFullPath)(this.opts.uriResolver, p);
  let baseId = (0, resolve_1$3.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
  if (Object.keys(root.schema).length > 0 && refPath === baseId) {
    return getJsonPointer$1.call(this, p, root);
  }
  const id2 = (0, resolve_1$3.normalizeId)(refPath);
  const schOrRef = this.refs[id2] || this.schemas[id2];
  if (typeof schOrRef == "string") {
    const sch = resolveSchema$1.call(this, root, schOrRef);
    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
      return;
    return getJsonPointer$1.call(this, p, sch);
  }
  if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
    return;
  if (!schOrRef.validate)
    compileSchema$1.call(this, schOrRef);
  if (id2 === (0, resolve_1$3.normalizeId)(ref2)) {
    const { schema } = schOrRef;
    const { schemaId } = this.opts;
    const schId = schema[schemaId];
    if (schId)
      baseId = (0, resolve_1$3.resolveUrl)(this.opts.uriResolver, baseId, schId);
    return new SchemaEnv$1({ schema, schemaId, root, baseId });
  }
  return getJsonPointer$1.call(this, p, schOrRef);
}
compile$1.resolveSchema = resolveSchema$1;
const PREVENT_SCOPE_CHANGE$1 = /* @__PURE__ */ new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function getJsonPointer$1(parsedRef, { baseId, schema, root }) {
  var _a;
  if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
    return;
  for (const part of parsedRef.fragment.slice(1).split("/")) {
    if (typeof schema === "boolean")
      return;
    const partSchema = schema[(0, util_1$L.unescapeFragment)(part)];
    if (partSchema === void 0)
      return;
    schema = partSchema;
    const schId = typeof schema === "object" && schema[this.opts.schemaId];
    if (!PREVENT_SCOPE_CHANGE$1.has(part) && schId) {
      baseId = (0, resolve_1$3.resolveUrl)(this.opts.uriResolver, baseId, schId);
    }
  }
  let env2;
  if (typeof schema != "boolean" && schema.$ref && !(0, util_1$L.schemaHasRulesButRef)(schema, this.RULES)) {
    const $ref = (0, resolve_1$3.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
    env2 = resolveSchema$1.call(this, root, $ref);
  }
  const { schemaId } = this.opts;
  env2 = env2 || new SchemaEnv$1({ schema, schemaId, root, baseId });
  if (env2.schema !== env2.root.schema)
    return env2;
  return void 0;
}
const $id$3 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description$1 = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
const type$3 = "object";
const required$3 = [
  "$data"
];
const properties$5 = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
};
const additionalProperties$3 = false;
const require$$9$1 = {
  $id: $id$3,
  description: description$1,
  type: type$3,
  required: required$3,
  properties: properties$5,
  additionalProperties: additionalProperties$3
};
var uri$3 = {};
var fastUri$1 = { exports: {} };
const isUUID$1 = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
const isIPv4$1 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
function stringArrayToHexStripped(input) {
  let acc = "";
  let code2 = 0;
  let i = 0;
  for (i = 0; i < input.length; i++) {
    code2 = input[i].charCodeAt(0);
    if (code2 === 48) {
      continue;
    }
    if (!(code2 >= 48 && code2 <= 57 || code2 >= 65 && code2 <= 70 || code2 >= 97 && code2 <= 102)) {
      return "";
    }
    acc += input[i];
    break;
  }
  for (i += 1; i < input.length; i++) {
    code2 = input[i].charCodeAt(0);
    if (!(code2 >= 48 && code2 <= 57 || code2 >= 65 && code2 <= 70 || code2 >= 97 && code2 <= 102)) {
      return "";
    }
    acc += input[i];
  }
  return acc;
}
const nonSimpleDomain$1 = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
function consumeIsZone(buffer2) {
  buffer2.length = 0;
  return true;
}
function consumeHextets(buffer2, address, output) {
  if (buffer2.length) {
    const hex = stringArrayToHexStripped(buffer2);
    if (hex !== "") {
      address.push(hex);
    } else {
      output.error = true;
      return false;
    }
    buffer2.length = 0;
  }
  return true;
}
function getIPV6(input) {
  let tokenCount = 0;
  const output = { error: false, address: "", zone: "" };
  const address = [];
  const buffer2 = [];
  let endipv6Encountered = false;
  let endIpv6 = false;
  let consume = consumeHextets;
  for (let i = 0; i < input.length; i++) {
    const cursor = input[i];
    if (cursor === "[" || cursor === "]") {
      continue;
    }
    if (cursor === ":") {
      if (endipv6Encountered === true) {
        endIpv6 = true;
      }
      if (!consume(buffer2, address, output)) {
        break;
      }
      if (++tokenCount > 7) {
        output.error = true;
        break;
      }
      if (i > 0 && input[i - 1] === ":") {
        endipv6Encountered = true;
      }
      address.push(":");
      continue;
    } else if (cursor === "%") {
      if (!consume(buffer2, address, output)) {
        break;
      }
      consume = consumeIsZone;
    } else {
      buffer2.push(cursor);
      continue;
    }
  }
  if (buffer2.length) {
    if (consume === consumeIsZone) {
      output.zone = buffer2.join("");
    } else if (endIpv6) {
      address.push(buffer2.join(""));
    } else {
      address.push(stringArrayToHexStripped(buffer2));
    }
  }
  output.address = address.join("");
  return output;
}
function normalizeIPv6$1(host) {
  if (findToken(host, ":") < 2) {
    return { host, isIPV6: false };
  }
  const ipv6 = getIPV6(host);
  if (!ipv6.error) {
    let newHost = ipv6.address;
    let escapedHost = ipv6.address;
    if (ipv6.zone) {
      newHost += "%" + ipv6.zone;
      escapedHost += "%25" + ipv6.zone;
    }
    return { host: newHost, isIPV6: true, escapedHost };
  } else {
    return { host, isIPV6: false };
  }
}
function findToken(str, token) {
  let ind = 0;
  for (let i = 0; i < str.length; i++) {
    if (str[i] === token) ind++;
  }
  return ind;
}
function removeDotSegments$1(path2) {
  let input = path2;
  const output = [];
  let nextSlash = -1;
  let len = 0;
  while (len = input.length) {
    if (len === 1) {
      if (input === ".") {
        break;
      } else if (input === "/") {
        output.push("/");
        break;
      } else {
        output.push(input);
        break;
      }
    } else if (len === 2) {
      if (input[0] === ".") {
        if (input[1] === ".") {
          break;
        } else if (input[1] === "/") {
          input = input.slice(2);
          continue;
        }
      } else if (input[0] === "/") {
        if (input[1] === "." || input[1] === "/") {
          output.push("/");
          break;
        }
      }
    } else if (len === 3) {
      if (input === "/..") {
        if (output.length !== 0) {
          output.pop();
        }
        output.push("/");
        break;
      }
    }
    if (input[0] === ".") {
      if (input[1] === ".") {
        if (input[2] === "/") {
          input = input.slice(3);
          continue;
        }
      } else if (input[1] === "/") {
        input = input.slice(2);
        continue;
      }
    } else if (input[0] === "/") {
      if (input[1] === ".") {
        if (input[2] === "/") {
          input = input.slice(2);
          continue;
        } else if (input[2] === ".") {
          if (input[3] === "/") {
            input = input.slice(3);
            if (output.length !== 0) {
              output.pop();
            }
            continue;
          }
        }
      }
    }
    if ((nextSlash = input.indexOf("/", 1)) === -1) {
      output.push(input);
      break;
    } else {
      output.push(input.slice(0, nextSlash));
      input = input.slice(nextSlash);
    }
  }
  return output.join("");
}
function normalizeComponentEncoding$1(component, esc) {
  const func = esc !== true ? escape : unescape;
  if (component.scheme !== void 0) {
    component.scheme = func(component.scheme);
  }
  if (component.userinfo !== void 0) {
    component.userinfo = func(component.userinfo);
  }
  if (component.host !== void 0) {
    component.host = func(component.host);
  }
  if (component.path !== void 0) {
    component.path = func(component.path);
  }
  if (component.query !== void 0) {
    component.query = func(component.query);
  }
  if (component.fragment !== void 0) {
    component.fragment = func(component.fragment);
  }
  return component;
}
function recomposeAuthority$1(component) {
  const uriTokens = [];
  if (component.userinfo !== void 0) {
    uriTokens.push(component.userinfo);
    uriTokens.push("@");
  }
  if (component.host !== void 0) {
    let host = unescape(component.host);
    if (!isIPv4$1(host)) {
      const ipV6res = normalizeIPv6$1(host);
      if (ipV6res.isIPV6 === true) {
        host = `[${ipV6res.escapedHost}]`;
      } else {
        host = component.host;
      }
    }
    uriTokens.push(host);
  }
  if (typeof component.port === "number" || typeof component.port === "string") {
    uriTokens.push(":");
    uriTokens.push(String(component.port));
  }
  return uriTokens.length ? uriTokens.join("") : void 0;
}
var utils$2 = {
  nonSimpleDomain: nonSimpleDomain$1,
  recomposeAuthority: recomposeAuthority$1,
  normalizeComponentEncoding: normalizeComponentEncoding$1,
  removeDotSegments: removeDotSegments$1,
  isIPv4: isIPv4$1,
  isUUID: isUUID$1,
  normalizeIPv6: normalizeIPv6$1
};
const { isUUID } = utils$2;
const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
function wsIsSecure(wsComponent) {
  if (wsComponent.secure === true) {
    return true;
  } else if (wsComponent.secure === false) {
    return false;
  } else if (wsComponent.scheme) {
    return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S");
  } else {
    return false;
  }
}
function httpParse(component) {
  if (!component.host) {
    component.error = component.error || "HTTP URIs must have a host.";
  }
  return component;
}
function httpSerialize(component) {
  const secure = String(component.scheme).toLowerCase() === "https";
  if (component.port === (secure ? 443 : 80) || component.port === "") {
    component.port = void 0;
  }
  if (!component.path) {
    component.path = "/";
  }
  return component;
}
function wsParse(wsComponent) {
  wsComponent.secure = wsIsSecure(wsComponent);
  wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : "");
  wsComponent.path = void 0;
  wsComponent.query = void 0;
  return wsComponent;
}
function wsSerialize(wsComponent) {
  if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") {
    wsComponent.port = void 0;
  }
  if (typeof wsComponent.secure === "boolean") {
    wsComponent.scheme = wsComponent.secure ? "wss" : "ws";
    wsComponent.secure = void 0;
  }
  if (wsComponent.resourceName) {
    const [path2, query] = wsComponent.resourceName.split("?");
    wsComponent.path = path2 && path2 !== "/" ? path2 : void 0;
    wsComponent.query = query;
    wsComponent.resourceName = void 0;
  }
  wsComponent.fragment = void 0;
  return wsComponent;
}
function urnParse(urnComponent, options) {
  if (!urnComponent.path) {
    urnComponent.error = "URN can not be parsed";
    return urnComponent;
  }
  const matches = urnComponent.path.match(URN_REG);
  if (matches) {
    const scheme = options.scheme || urnComponent.scheme || "urn";
    urnComponent.nid = matches[1].toLowerCase();
    urnComponent.nss = matches[2];
    const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`;
    const schemeHandler = getSchemeHandler$1(urnScheme);
    urnComponent.path = void 0;
    if (schemeHandler) {
      urnComponent = schemeHandler.parse(urnComponent, options);
    }
  } else {
    urnComponent.error = urnComponent.error || "URN can not be parsed.";
  }
  return urnComponent;
}
function urnSerialize(urnComponent, options) {
  if (urnComponent.nid === void 0) {
    throw new Error("URN without nid cannot be serialized");
  }
  const scheme = options.scheme || urnComponent.scheme || "urn";
  const nid = urnComponent.nid.toLowerCase();
  const urnScheme = `${scheme}:${options.nid || nid}`;
  const schemeHandler = getSchemeHandler$1(urnScheme);
  if (schemeHandler) {
    urnComponent = schemeHandler.serialize(urnComponent, options);
  }
  const uriComponent = urnComponent;
  const nss = urnComponent.nss;
  uriComponent.path = `${nid || options.nid}:${nss}`;
  options.skipEscape = true;
  return uriComponent;
}
function urnuuidParse(urnComponent, options) {
  const uuidComponent = urnComponent;
  uuidComponent.uuid = uuidComponent.nss;
  uuidComponent.nss = void 0;
  if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {
    uuidComponent.error = uuidComponent.error || "UUID is not valid.";
  }
  return uuidComponent;
}
function urnuuidSerialize(uuidComponent) {
  const urnComponent = uuidComponent;
  urnComponent.nss = (uuidComponent.uuid || "").toLowerCase();
  return urnComponent;
}
const http = (
  /** @type {SchemeHandler} */
  {
    scheme: "http",
    domainHost: true,
    parse: httpParse,
    serialize: httpSerialize
  }
);
const https = (
  /** @type {SchemeHandler} */
  {
    scheme: "https",
    domainHost: http.domainHost,
    parse: httpParse,
    serialize: httpSerialize
  }
);
const ws = (
  /** @type {SchemeHandler} */
  {
    scheme: "ws",
    domainHost: true,
    parse: wsParse,
    serialize: wsSerialize
  }
);
const wss = (
  /** @type {SchemeHandler} */
  {
    scheme: "wss",
    domainHost: ws.domainHost,
    parse: ws.parse,
    serialize: ws.serialize
  }
);
const urn = (
  /** @type {SchemeHandler} */
  {
    scheme: "urn",
    parse: urnParse,
    serialize: urnSerialize,
    skipNormalize: true
  }
);
const urnuuid = (
  /** @type {SchemeHandler} */
  {
    scheme: "urn:uuid",
    parse: urnuuidParse,
    serialize: urnuuidSerialize,
    skipNormalize: true
  }
);
const SCHEMES$1 = (
  /** @type {Record<SchemeName, SchemeHandler>} */
  {
    http,
    https,
    ws,
    wss,
    urn,
    "urn:uuid": urnuuid
  }
);
Object.setPrototypeOf(SCHEMES$1, null);
function getSchemeHandler$1(scheme) {
  return scheme && (SCHEMES$1[
    /** @type {SchemeName} */
    scheme
  ] || SCHEMES$1[
    /** @type {SchemeName} */
    scheme.toLowerCase()
  ]) || void 0;
}
var schemes = {
  SCHEMES: SCHEMES$1,
  getSchemeHandler: getSchemeHandler$1
};
const { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = utils$2;
const { SCHEMES, getSchemeHandler } = schemes;
function normalize(uri2, options) {
  if (typeof uri2 === "string") {
    uri2 = /** @type {T} */
    serialize(parse$7(uri2, options), options);
  } else if (typeof uri2 === "object") {
    uri2 = /** @type {T} */
    parse$7(serialize(uri2, options), options);
  }
  return uri2;
}
function resolve$3(baseURI, relativeURI, options) {
  const schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" };
  const resolved = resolveComponent(parse$7(baseURI, schemelessOptions), parse$7(relativeURI, schemelessOptions), schemelessOptions, true);
  schemelessOptions.skipEscape = true;
  return serialize(resolved, schemelessOptions);
}
function resolveComponent(base, relative, options, skipNormalization) {
  const target = {};
  if (!skipNormalization) {
    base = parse$7(serialize(base, options), options);
    relative = parse$7(serialize(relative, options), options);
  }
  options = options || {};
  if (!options.tolerant && relative.scheme) {
    target.scheme = relative.scheme;
    target.userinfo = relative.userinfo;
    target.host = relative.host;
    target.port = relative.port;
    target.path = removeDotSegments(relative.path || "");
    target.query = relative.query;
  } else {
    if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
      target.userinfo = relative.userinfo;
      target.host = relative.host;
      target.port = relative.port;
      target.path = removeDotSegments(relative.path || "");
      target.query = relative.query;
    } else {
      if (!relative.path) {
        target.path = base.path;
        if (relative.query !== void 0) {
          target.query = relative.query;
        } else {
          target.query = base.query;
        }
      } else {
        if (relative.path[0] === "/") {
          target.path = removeDotSegments(relative.path);
        } else {
          if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
            target.path = "/" + relative.path;
          } else if (!base.path) {
            target.path = relative.path;
          } else {
            target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
          }
          target.path = removeDotSegments(target.path);
        }
        target.query = relative.query;
      }
      target.userinfo = base.userinfo;
      target.host = base.host;
      target.port = base.port;
    }
    target.scheme = base.scheme;
  }
  target.fragment = relative.fragment;
  return target;
}
function equal$5(uriA, uriB, options) {
  if (typeof uriA === "string") {
    uriA = unescape(uriA);
    uriA = serialize(normalizeComponentEncoding(parse$7(uriA, options), true), { ...options, skipEscape: true });
  } else if (typeof uriA === "object") {
    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
  }
  if (typeof uriB === "string") {
    uriB = unescape(uriB);
    uriB = serialize(normalizeComponentEncoding(parse$7(uriB, options), true), { ...options, skipEscape: true });
  } else if (typeof uriB === "object") {
    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
  }
  return uriA.toLowerCase() === uriB.toLowerCase();
}
function serialize(cmpts, opts) {
  const component = {
    host: cmpts.host,
    scheme: cmpts.scheme,
    userinfo: cmpts.userinfo,
    port: cmpts.port,
    path: cmpts.path,
    query: cmpts.query,
    nid: cmpts.nid,
    nss: cmpts.nss,
    uuid: cmpts.uuid,
    fragment: cmpts.fragment,
    reference: cmpts.reference,
    resourceName: cmpts.resourceName,
    secure: cmpts.secure,
    error: ""
  };
  const options = Object.assign({}, opts);
  const uriTokens = [];
  const schemeHandler = getSchemeHandler(options.scheme || component.scheme);
  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options);
  if (component.path !== void 0) {
    if (!options.skipEscape) {
      component.path = escape(component.path);
      if (component.scheme !== void 0) {
        component.path = component.path.split("%3A").join(":");
      }
    } else {
      component.path = unescape(component.path);
    }
  }
  if (options.reference !== "suffix" && component.scheme) {
    uriTokens.push(component.scheme, ":");
  }
  const authority = recomposeAuthority(component);
  if (authority !== void 0) {
    if (options.reference !== "suffix") {
      uriTokens.push("//");
    }
    uriTokens.push(authority);
    if (component.path && component.path[0] !== "/") {
      uriTokens.push("/");
    }
  }
  if (component.path !== void 0) {
    let s = component.path;
    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
      s = removeDotSegments(s);
    }
    if (authority === void 0 && s[0] === "/" && s[1] === "/") {
      s = "/%2F" + s.slice(2);
    }
    uriTokens.push(s);
  }
  if (component.query !== void 0) {
    uriTokens.push("?", component.query);
  }
  if (component.fragment !== void 0) {
    uriTokens.push("#", component.fragment);
  }
  return uriTokens.join("");
}
const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
function parse$7(uri2, opts) {
  const options = Object.assign({}, opts);
  const parsed = {
    scheme: void 0,
    userinfo: void 0,
    host: "",
    port: void 0,
    path: "",
    query: void 0,
    fragment: void 0
  };
  let isIP = false;
  if (options.reference === "suffix") {
    if (options.scheme) {
      uri2 = options.scheme + ":" + uri2;
    } else {
      uri2 = "//" + uri2;
    }
  }
  const matches = uri2.match(URI_PARSE);
  if (matches) {
    parsed.scheme = matches[1];
    parsed.userinfo = matches[3];
    parsed.host = matches[4];
    parsed.port = parseInt(matches[5], 10);
    parsed.path = matches[6] || "";
    parsed.query = matches[7];
    parsed.fragment = matches[8];
    if (isNaN(parsed.port)) {
      parsed.port = matches[5];
    }
    if (parsed.host) {
      const ipv4result = isIPv4(parsed.host);
      if (ipv4result === false) {
        const ipv6result = normalizeIPv6(parsed.host);
        parsed.host = ipv6result.host.toLowerCase();
        isIP = ipv6result.isIPV6;
      } else {
        isIP = true;
      }
    }
    if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
      parsed.reference = "same-document";
    } else if (parsed.scheme === void 0) {
      parsed.reference = "relative";
    } else if (parsed.fragment === void 0) {
      parsed.reference = "absolute";
    } else {
      parsed.reference = "uri";
    }
    if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
      parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
    }
    const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
      if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
        try {
          parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
        } catch (e) {
          parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
        }
      }
    }
    if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
      if (uri2.indexOf("%") !== -1) {
        if (parsed.scheme !== void 0) {
          parsed.scheme = unescape(parsed.scheme);
        }
        if (parsed.host !== void 0) {
          parsed.host = unescape(parsed.host);
        }
      }
      if (parsed.path) {
        parsed.path = escape(unescape(parsed.path));
      }
      if (parsed.fragment) {
        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
      }
    }
    if (schemeHandler && schemeHandler.parse) {
      schemeHandler.parse(parsed, options);
    }
  } else {
    parsed.error = parsed.error || "URI can not be parsed.";
  }
  return parsed;
}
const fastUri = {
  SCHEMES,
  normalize,
  resolve: resolve$3,
  resolveComponent,
  equal: equal$5,
  serialize,
  parse: parse$7
};
fastUri$1.exports = fastUri;
fastUri$1.exports.default = fastUri;
fastUri$1.exports.fastUri = fastUri;
var fastUriExports = fastUri$1.exports;
Object.defineProperty(uri$3, "__esModule", { value: true });
const uri$2 = fastUriExports;
uri$2.code = 'require("ajv/dist/runtime/uri").default';
uri$3.default = uri$2;
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.CodeGen = exports$1.Name = exports$1.nil = exports$1.stringify = exports$1.str = exports$1._ = exports$1.KeywordCxt = void 0;
  var validate_12 = validate$1;
  Object.defineProperty(exports$1, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen$1;
  Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports$1, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  const validation_error_12 = validation_error$1;
  const ref_error_12 = ref_error$1;
  const rules_12 = rules$1;
  const compile_12 = compile$1;
  const codegen_2 = codegen$1;
  const resolve_12 = resolve$5;
  const dataType_12 = dataType$1;
  const util_12 = util$1;
  const $dataRefSchema = require$$9$1;
  const uri_1 = uri$3;
  const defaultRegExp = (str, flags) => new RegExp(str, flags);
  defaultRegExp.code = "new RegExp";
  const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
  const EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]);
  const removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  };
  const deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  };
  const MAX_EXPRESSION = 200;
  function requiredOptions(o) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
    const s = o.strict;
    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
    const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
    return {
      strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
      strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
      strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
      strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
      strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
      code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
      loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
      loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
      meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
      messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
      inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
      schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
      addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
      validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
      validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
      unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
      int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
      uriResolver
    };
  }
  class Ajv {
    constructor(opts = {}) {
      this.schemas = {};
      this.refs = {};
      this.formats = {};
      this._compilations = /* @__PURE__ */ new Set();
      this._loading = {};
      this._cache = /* @__PURE__ */ new Map();
      opts = this.opts = { ...opts, ...requiredOptions(opts) };
      const { es5, lines } = this.opts.code;
      this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
      this.logger = getLogger(opts.logger);
      const formatOpt = opts.validateFormats;
      opts.validateFormats = false;
      this.RULES = (0, rules_12.getRules)();
      checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
      checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
      this._metaOpts = getMetaSchemaOptions.call(this);
      if (opts.formats)
        addInitialFormats.call(this);
      this._addVocabularies();
      this._addDefaultMetaSchema();
      if (opts.keywords)
        addInitialKeywords.call(this, opts.keywords);
      if (typeof opts.meta == "object")
        this.addMetaSchema(opts.meta);
      addInitialSchemas.call(this);
      opts.validateFormats = formatOpt;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data, meta, schemaId } = this.opts;
      let _dataRefSchema = $dataRefSchema;
      if (schemaId === "id") {
        _dataRefSchema = { ...$dataRefSchema };
        _dataRefSchema.id = _dataRefSchema.$id;
        delete _dataRefSchema.$id;
      }
      if (meta && $data)
        this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
      const { meta, schemaId } = this.opts;
      return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
    }
    validate(schemaKeyRef, data) {
      let v;
      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v)
          throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
      } else {
        v = this.compile(schemaKeyRef);
      }
      const valid2 = v(data);
      if (!("$async" in v))
        this.errors = v.errors;
      return valid2;
    }
    compile(schema, _meta) {
      const sch = this._addSchema(schema, _meta);
      return sch.validate || this._compileSchemaEnv(sch);
    }
    compileAsync(schema, meta) {
      if (typeof this.opts.loadSchema != "function") {
        throw new Error("options.loadSchema should be a function");
      }
      const { loadSchema } = this.opts;
      return runCompileAsync.call(this, schema, meta);
      async function runCompileAsync(_schema, _meta) {
        await loadMetaSchema.call(this, _schema.$schema);
        const sch = this._addSchema(_schema, _meta);
        return sch.validate || _compileAsync.call(this, sch);
      }
      async function loadMetaSchema($ref) {
        if ($ref && !this.getSchema($ref)) {
          await runCompileAsync.call(this, { $ref }, true);
        }
      }
      async function _compileAsync(sch) {
        try {
          return this._compileSchemaEnv(sch);
        } catch (e) {
          if (!(e instanceof ref_error_12.default))
            throw e;
          checkLoaded.call(this, e);
          await loadMissingSchema.call(this, e.missingSchema);
          return _compileAsync.call(this, sch);
        }
      }
      function checkLoaded({ missingSchema: ref2, missingRef }) {
        if (this.refs[ref2]) {
          throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
        }
      }
      async function loadMissingSchema(ref2) {
        const _schema = await _loadSchema.call(this, ref2);
        if (!this.refs[ref2])
          await loadMetaSchema.call(this, _schema.$schema);
        if (!this.refs[ref2])
          this.addSchema(_schema, ref2, meta);
      }
      async function _loadSchema(ref2) {
        const p = this._loading[ref2];
        if (p)
          return p;
        try {
          return await (this._loading[ref2] = loadSchema(ref2));
        } finally {
          delete this._loading[ref2];
        }
      }
    }
    // Adds schema to the instance
    addSchema(schema, key2, _meta, _validateSchema = this.opts.validateSchema) {
      if (Array.isArray(schema)) {
        for (const sch of schema)
          this.addSchema(sch, void 0, _meta, _validateSchema);
        return this;
      }
      let id2;
      if (typeof schema === "object") {
        const { schemaId } = this.opts;
        id2 = schema[schemaId];
        if (id2 !== void 0 && typeof id2 != "string") {
          throw new Error(`schema ${schemaId} must be string`);
        }
      }
      key2 = (0, resolve_12.normalizeId)(key2 || id2);
      this._checkUnique(key2);
      this.schemas[key2] = this._addSchema(schema, _meta, key2, _validateSchema, true);
      return this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(schema, key2, _validateSchema = this.opts.validateSchema) {
      this.addSchema(schema, key2, true, _validateSchema);
      return this;
    }
    //  Validate schema against its meta-schema
    validateSchema(schema, throwOrLogError) {
      if (typeof schema == "boolean")
        return true;
      let $schema2;
      $schema2 = schema.$schema;
      if ($schema2 !== void 0 && typeof $schema2 != "string") {
        throw new Error("$schema must be a string");
      }
      $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
      if (!$schema2) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      const valid2 = this.validate($schema2, schema);
      if (!valid2 && throwOrLogError) {
        const message = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid2;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(keyRef) {
      let sch;
      while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
        keyRef = sch;
      if (sch === void 0) {
        const { schemaId } = this.opts;
        const root = new compile_12.SchemaEnv({ schema: {}, schemaId });
        sch = compile_12.resolveSchema.call(this, root, keyRef);
        if (!sch)
          return;
        this.refs[keyRef] = sch;
      }
      return sch.validate || this._compileSchemaEnv(sch);
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        this._removeAllSchemas(this.schemas, schemaKeyRef);
        this._removeAllSchemas(this.refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          this._removeAllSchemas(this.schemas);
          this._removeAllSchemas(this.refs);
          this._cache.clear();
          return this;
        case "string": {
          const sch = getSchEnv.call(this, schemaKeyRef);
          if (typeof sch == "object")
            this._cache.delete(sch.schema);
          delete this.schemas[schemaKeyRef];
          delete this.refs[schemaKeyRef];
          return this;
        }
        case "object": {
          const cacheKey = schemaKeyRef;
          this._cache.delete(cacheKey);
          let id2 = schemaKeyRef[this.opts.schemaId];
          if (id2) {
            id2 = (0, resolve_12.normalizeId)(id2);
            delete this.schemas[id2];
            delete this.refs[id2];
          }
          return this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(definitions2) {
      for (const def2 of definitions2)
        this.addKeyword(def2);
      return this;
    }
    addKeyword(kwdOrDef, def2) {
      let keyword2;
      if (typeof kwdOrDef == "string") {
        keyword2 = kwdOrDef;
        if (typeof def2 == "object") {
          this.logger.warn("these parameters are deprecated, see docs for addKeyword");
          def2.keyword = keyword2;
        }
      } else if (typeof kwdOrDef == "object" && def2 === void 0) {
        def2 = kwdOrDef;
        keyword2 = def2.keyword;
        if (Array.isArray(keyword2) && !keyword2.length) {
          throw new Error("addKeywords: keyword must be string or non-empty array");
        }
      } else {
        throw new Error("invalid addKeywords parameters");
      }
      checkKeyword.call(this, keyword2, def2);
      if (!def2) {
        (0, util_12.eachItem)(keyword2, (kwd) => addRule.call(this, kwd));
        return this;
      }
      keywordMetaschema.call(this, def2);
      const definition = {
        ...def2,
        type: (0, dataType_12.getJSONTypes)(def2.type),
        schemaType: (0, dataType_12.getJSONTypes)(def2.schemaType)
      };
      (0, util_12.eachItem)(keyword2, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t2) => addRule.call(this, k, definition, t2)));
      return this;
    }
    getKeyword(keyword2) {
      const rule = this.RULES.all[keyword2];
      return typeof rule == "object" ? rule.definition : !!rule;
    }
    // Remove keyword
    removeKeyword(keyword2) {
      const { RULES } = this;
      delete RULES.keywords[keyword2];
      delete RULES.all[keyword2];
      for (const group of RULES.rules) {
        const i = group.rules.findIndex((rule) => rule.keyword === keyword2);
        if (i >= 0)
          group.rules.splice(i, 1);
      }
      return this;
    }
    // Add format
    addFormat(name, format2) {
      if (typeof format2 == "string")
        format2 = new RegExp(format2);
      this.formats[name] = format2;
      return this;
    }
    errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
      if (!errors2 || errors2.length === 0)
        return "No errors";
      return errors2.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
      const rules2 = this.RULES.all;
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      for (const jsonPointer of keywordsJsonPointers) {
        const segments = jsonPointer.split("/").slice(1);
        let keywords = metaSchema;
        for (const seg of segments)
          keywords = keywords[seg];
        for (const key2 in rules2) {
          const rule = rules2[key2];
          if (typeof rule != "object")
            continue;
          const { $data } = rule.definition;
          const schema = keywords[key2];
          if ($data && schema)
            keywords[key2] = schemaOrData(schema);
        }
      }
      return metaSchema;
    }
    _removeAllSchemas(schemas, regex) {
      for (const keyRef in schemas) {
        const sch = schemas[keyRef];
        if (!regex || regex.test(keyRef)) {
          if (typeof sch == "string") {
            delete schemas[keyRef];
          } else if (sch && !sch.meta) {
            this._cache.delete(sch.schema);
            delete schemas[keyRef];
          }
        }
      }
    }
    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
      let id2;
      const { schemaId } = this.opts;
      if (typeof schema == "object") {
        id2 = schema[schemaId];
      } else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        else if (typeof schema != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let sch = this._cache.get(schema);
      if (sch !== void 0)
        return sch;
      baseId = (0, resolve_12.normalizeId)(id2 || baseId);
      const localRefs = resolve_12.getSchemaRefs.call(this, schema, baseId);
      sch = new compile_12.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
      this._cache.set(sch.schema, sch);
      if (addSchema && !baseId.startsWith("#")) {
        if (baseId)
          this._checkUnique(baseId);
        this.refs[baseId] = sch;
      }
      if (validateSchema)
        this.validateSchema(schema, true);
      return sch;
    }
    _checkUnique(id2) {
      if (this.schemas[id2] || this.refs[id2]) {
        throw new Error(`schema with key or id "${id2}" already exists`);
      }
    }
    _compileSchemaEnv(sch) {
      if (sch.meta)
        this._compileMetaSchema(sch);
      else
        compile_12.compileSchema.call(this, sch);
      if (!sch.validate)
        throw new Error("ajv implementation error");
      return sch.validate;
    }
    _compileMetaSchema(sch) {
      const currentOpts = this.opts;
      this.opts = this._metaOpts;
      try {
        compile_12.compileSchema.call(this, sch);
      } finally {
        this.opts = currentOpts;
      }
    }
  }
  Ajv.ValidationError = validation_error_12.default;
  Ajv.MissingRefError = ref_error_12.default;
  exports$1.default = Ajv;
  function checkOptions(checkOpts, options, msg, log = "error") {
    for (const key2 in checkOpts) {
      const opt = key2;
      if (opt in options)
        this.logger[log](`${msg}: option ${key2}. ${checkOpts[opt]}`);
    }
  }
  function getSchEnv(keyRef) {
    keyRef = (0, resolve_12.normalizeId)(keyRef);
    return this.schemas[keyRef] || this.refs[keyRef];
  }
  function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
      return;
    if (Array.isArray(optsSchemas))
      this.addSchema(optsSchemas);
    else
      for (const key2 in optsSchemas)
        this.addSchema(optsSchemas[key2], key2);
  }
  function addInitialFormats() {
    for (const name in this.opts.formats) {
      const format2 = this.opts.formats[name];
      if (format2)
        this.addFormat(name, format2);
    }
  }
  function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
      this.addVocabulary(defs);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword2 in defs) {
      const def2 = defs[keyword2];
      if (!def2.keyword)
        def2.keyword = keyword2;
      this.addKeyword(def2);
    }
  }
  function getMetaSchemaOptions() {
    const metaOpts = { ...this.opts };
    for (const opt of META_IGNORE_OPTIONS)
      delete metaOpts[opt];
    return metaOpts;
  }
  const noLogs = { log() {
  }, warn() {
  }, error() {
  } };
  function getLogger(logger) {
    if (logger === false)
      return noLogs;
    if (logger === void 0)
      return console;
    if (logger.log && logger.warn && logger.error)
      return logger;
    throw new Error("logger must implement log, warn and error methods");
  }
  const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
  function checkKeyword(keyword2, def2) {
    const { RULES } = this;
    (0, util_12.eachItem)(keyword2, (kwd) => {
      if (RULES.keywords[kwd])
        throw new Error(`Keyword ${kwd} is already defined`);
      if (!KEYWORD_NAME.test(kwd))
        throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def2)
      return;
    if (def2.$data && !("code" in def2 || "validate" in def2)) {
      throw new Error('$data keyword must have "code" or "validate" function');
    }
  }
  function addRule(keyword2, definition, dataType2) {
    var _a;
    const post = definition === null || definition === void 0 ? void 0 : definition.post;
    if (dataType2 && post)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t2 }) => t2 === dataType2);
    if (!ruleGroup) {
      ruleGroup = { type: dataType2, rules: [] };
      RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword2] = true;
    if (!definition)
      return;
    const rule = {
      keyword: keyword2,
      definition: {
        ...definition,
        type: (0, dataType_12.getJSONTypes)(definition.type),
        schemaType: (0, dataType_12.getJSONTypes)(definition.schemaType)
      }
    };
    if (definition.before)
      addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
      ruleGroup.rules.push(rule);
    RULES.all[keyword2] = rule;
    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
  }
  function addBeforeRule(ruleGroup, rule, before) {
    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i >= 0) {
      ruleGroup.rules.splice(i, 0, rule);
    } else {
      ruleGroup.rules.push(rule);
      this.logger.warn(`rule ${before} is not defined`);
    }
  }
  function keywordMetaschema(def2) {
    let { metaSchema } = def2;
    if (metaSchema === void 0)
      return;
    if (def2.$data && this.opts.$data)
      metaSchema = schemaOrData(metaSchema);
    def2.validateSchema = this.compile(metaSchema, true);
  }
  const $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function schemaOrData(schema) {
    return { anyOf: [schema, $dataRef] };
  }
})(core$5);
var draft7$1 = {};
var core$4 = {};
var id$1 = {};
Object.defineProperty(id$1, "__esModule", { value: true });
const def$V = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
id$1.default = def$V;
var ref$1 = {};
Object.defineProperty(ref$1, "__esModule", { value: true });
ref$1.callRef = ref$1.getValidate = void 0;
const ref_error_1$3 = ref_error$1;
const code_1$j = code$2;
const codegen_1$R = codegen$1;
const names_1$8 = names$3;
const compile_1$3 = compile$1;
const util_1$K = util$1;
const def$U = {
  keyword: "$ref",
  schemaType: "string",
  code(cxt) {
    const { gen, schema: $ref, it } = cxt;
    const { baseId, schemaEnv: env2, validateName, opts, self: self2 } = it;
    const { root } = env2;
    if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
      return callRootRef();
    const schOrEnv = compile_1$3.resolveRef.call(self2, root, baseId, $ref);
    if (schOrEnv === void 0)
      throw new ref_error_1$3.default(it.opts.uriResolver, baseId, $ref);
    if (schOrEnv instanceof compile_1$3.SchemaEnv)
      return callValidate(schOrEnv);
    return inlineRefSchema(schOrEnv);
    function callRootRef() {
      if (env2 === root)
        return callRef$1(cxt, validateName, env2, env2.$async);
      const rootName = gen.scopeValue("root", { ref: root });
      return callRef$1(cxt, (0, codegen_1$R._)`${rootName}.validate`, root, root.$async);
    }
    function callValidate(sch) {
      const v = getValidate$1(cxt, sch);
      callRef$1(cxt, v, sch, sch.$async);
    }
    function inlineRefSchema(sch) {
      const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1$R.stringify)(sch) } : { ref: sch });
      const valid2 = gen.name("valid");
      const schCxt = cxt.subschema({
        schema: sch,
        dataTypes: [],
        schemaPath: codegen_1$R.nil,
        topSchemaRef: schName,
        errSchemaPath: $ref
      }, valid2);
      cxt.mergeEvaluated(schCxt);
      cxt.ok(valid2);
    }
  }
};
function getValidate$1(cxt, sch) {
  const { gen } = cxt;
  return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1$R._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
}
ref$1.getValidate = getValidate$1;
function callRef$1(cxt, v, sch, $async) {
  const { gen, it } = cxt;
  const { allErrors, schemaEnv: env2, opts } = it;
  const passCxt = opts.passContext ? names_1$8.default.this : codegen_1$R.nil;
  if ($async)
    callAsyncRef();
  else
    callSyncRef();
  function callAsyncRef() {
    if (!env2.$async)
      throw new Error("async schema referenced by sync schema");
    const valid2 = gen.let("valid");
    gen.try(() => {
      gen.code((0, codegen_1$R._)`await ${(0, code_1$j.callValidateCode)(cxt, v, passCxt)}`);
      addEvaluatedFrom(v);
      if (!allErrors)
        gen.assign(valid2, true);
    }, (e) => {
      gen.if((0, codegen_1$R._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
      addErrorsFrom(e);
      if (!allErrors)
        gen.assign(valid2, false);
    });
    cxt.ok(valid2);
  }
  function callSyncRef() {
    cxt.result((0, code_1$j.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
  }
  function addErrorsFrom(source2) {
    const errs = (0, codegen_1$R._)`${source2}.errors`;
    gen.assign(names_1$8.default.vErrors, (0, codegen_1$R._)`${names_1$8.default.vErrors} === null ? ${errs} : ${names_1$8.default.vErrors}.concat(${errs})`);
    gen.assign(names_1$8.default.errors, (0, codegen_1$R._)`${names_1$8.default.vErrors}.length`);
  }
  function addEvaluatedFrom(source2) {
    var _a;
    if (!it.opts.unevaluated)
      return;
    const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
    if (it.props !== true) {
      if (schEvaluated && !schEvaluated.dynamicProps) {
        if (schEvaluated.props !== void 0) {
          it.props = util_1$K.mergeEvaluated.props(gen, schEvaluated.props, it.props);
        }
      } else {
        const props = gen.var("props", (0, codegen_1$R._)`${source2}.evaluated.props`);
        it.props = util_1$K.mergeEvaluated.props(gen, props, it.props, codegen_1$R.Name);
      }
    }
    if (it.items !== true) {
      if (schEvaluated && !schEvaluated.dynamicItems) {
        if (schEvaluated.items !== void 0) {
          it.items = util_1$K.mergeEvaluated.items(gen, schEvaluated.items, it.items);
        }
      } else {
        const items2 = gen.var("items", (0, codegen_1$R._)`${source2}.evaluated.items`);
        it.items = util_1$K.mergeEvaluated.items(gen, items2, it.items, codegen_1$R.Name);
      }
    }
  }
}
ref$1.callRef = callRef$1;
ref$1.default = def$U;
Object.defineProperty(core$4, "__esModule", { value: true });
const id_1$1 = id$1;
const ref_1$1 = ref$1;
const core$3 = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  id_1$1.default,
  ref_1$1.default
];
core$4.default = core$3;
var validation$3 = {};
var limitNumber$1 = {};
Object.defineProperty(limitNumber$1, "__esModule", { value: true });
const codegen_1$Q = codegen$1;
const ops$1 = codegen_1$Q.operators;
const KWDs$1 = {
  maximum: { okStr: "<=", ok: ops$1.LTE, fail: ops$1.GT },
  minimum: { okStr: ">=", ok: ops$1.GTE, fail: ops$1.LT },
  exclusiveMaximum: { okStr: "<", ok: ops$1.LT, fail: ops$1.GTE },
  exclusiveMinimum: { okStr: ">", ok: ops$1.GT, fail: ops$1.LTE }
};
const error$B = {
  message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1$Q.str)`must be ${KWDs$1[keyword2].okStr} ${schemaCode}`,
  params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1$Q._)`{comparison: ${KWDs$1[keyword2].okStr}, limit: ${schemaCode}}`
};
const def$T = {
  keyword: Object.keys(KWDs$1),
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$B,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    cxt.fail$data((0, codegen_1$Q._)`${data} ${KWDs$1[keyword2].fail} ${schemaCode} || isNaN(${data})`);
  }
};
limitNumber$1.default = def$T;
var multipleOf$1 = {};
Object.defineProperty(multipleOf$1, "__esModule", { value: true });
const codegen_1$P = codegen$1;
const error$A = {
  message: ({ schemaCode }) => (0, codegen_1$P.str)`must be multiple of ${schemaCode}`,
  params: ({ schemaCode }) => (0, codegen_1$P._)`{multipleOf: ${schemaCode}}`
};
const def$S = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$A,
  code(cxt) {
    const { gen, data, schemaCode, it } = cxt;
    const prec = it.opts.multipleOfPrecision;
    const res = gen.let("res");
    const invalid = prec ? (0, codegen_1$P._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1$P._)`${res} !== parseInt(${res})`;
    cxt.fail$data((0, codegen_1$P._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
  }
};
multipleOf$1.default = def$S;
var limitLength$1 = {};
var ucs2length$3 = {};
Object.defineProperty(ucs2length$3, "__esModule", { value: true });
function ucs2length$2(str) {
  const len = str.length;
  let length = 0;
  let pos = 0;
  let value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 55296 && value <= 56319 && pos < len) {
      value = str.charCodeAt(pos);
      if ((value & 64512) === 56320)
        pos++;
    }
  }
  return length;
}
ucs2length$3.default = ucs2length$2;
ucs2length$2.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(limitLength$1, "__esModule", { value: true });
const codegen_1$O = codegen$1;
const util_1$J = util$1;
const ucs2length_1$1 = ucs2length$3;
const error$z = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxLength" ? "more" : "fewer";
    return (0, codegen_1$O.str)`must NOT have ${comp} than ${schemaCode} characters`;
  },
  params: ({ schemaCode }) => (0, codegen_1$O._)`{limit: ${schemaCode}}`
};
const def$R = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: true,
  error: error$z,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode, it } = cxt;
    const op = keyword2 === "maxLength" ? codegen_1$O.operators.GT : codegen_1$O.operators.LT;
    const len = it.opts.unicode === false ? (0, codegen_1$O._)`${data}.length` : (0, codegen_1$O._)`${(0, util_1$J.useFunc)(cxt.gen, ucs2length_1$1.default)}(${data})`;
    cxt.fail$data((0, codegen_1$O._)`${len} ${op} ${schemaCode}`);
  }
};
limitLength$1.default = def$R;
var pattern$1 = {};
Object.defineProperty(pattern$1, "__esModule", { value: true });
const code_1$i = code$2;
const codegen_1$N = codegen$1;
const error$y = {
  message: ({ schemaCode }) => (0, codegen_1$N.str)`must match pattern "${schemaCode}"`,
  params: ({ schemaCode }) => (0, codegen_1$N._)`{pattern: ${schemaCode}}`
};
const def$Q = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: true,
  error: error$y,
  code(cxt) {
    const { data, $data, schema, schemaCode, it } = cxt;
    const u = it.opts.unicodeRegExp ? "u" : "";
    const regExp = $data ? (0, codegen_1$N._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1$i.usePattern)(cxt, schema);
    cxt.fail$data((0, codegen_1$N._)`!${regExp}.test(${data})`);
  }
};
pattern$1.default = def$Q;
var limitProperties$1 = {};
Object.defineProperty(limitProperties$1, "__esModule", { value: true });
const codegen_1$M = codegen$1;
const error$x = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxProperties" ? "more" : "fewer";
    return (0, codegen_1$M.str)`must NOT have ${comp} than ${schemaCode} properties`;
  },
  params: ({ schemaCode }) => (0, codegen_1$M._)`{limit: ${schemaCode}}`
};
const def$P = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: true,
  error: error$x,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxProperties" ? codegen_1$M.operators.GT : codegen_1$M.operators.LT;
    cxt.fail$data((0, codegen_1$M._)`Object.keys(${data}).length ${op} ${schemaCode}`);
  }
};
limitProperties$1.default = def$P;
var required$2 = {};
Object.defineProperty(required$2, "__esModule", { value: true });
const code_1$h = code$2;
const codegen_1$L = codegen$1;
const util_1$I = util$1;
const error$w = {
  message: ({ params: { missingProperty } }) => (0, codegen_1$L.str)`must have required property '${missingProperty}'`,
  params: ({ params: { missingProperty } }) => (0, codegen_1$L._)`{missingProperty: ${missingProperty}}`
};
const def$O = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: true,
  error: error$w,
  code(cxt) {
    const { gen, schema, schemaCode, data, $data, it } = cxt;
    const { opts } = it;
    if (!$data && schema.length === 0)
      return;
    const useLoop = schema.length >= opts.loopRequired;
    if (it.allErrors)
      allErrorsMode();
    else
      exitOnErrorMode();
    if (opts.strictRequired) {
      const props = cxt.parentSchema.properties;
      const { definedProperties } = cxt.it;
      for (const requiredKey of schema) {
        if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
          const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
          (0, util_1$I.checkStrictMode)(it, msg, it.opts.strictRequired);
        }
      }
    }
    function allErrorsMode() {
      if (useLoop || $data) {
        cxt.block$data(codegen_1$L.nil, loopAllRequired);
      } else {
        for (const prop of schema) {
          (0, code_1$h.checkReportMissingProp)(cxt, prop);
        }
      }
    }
    function exitOnErrorMode() {
      const missing = gen.let("missing");
      if (useLoop || $data) {
        const valid2 = gen.let("valid", true);
        cxt.block$data(valid2, () => loopUntilMissing(missing, valid2));
        cxt.ok(valid2);
      } else {
        gen.if((0, code_1$h.checkMissingProp)(cxt, schema, missing));
        (0, code_1$h.reportMissingProp)(cxt, missing);
        gen.else();
      }
    }
    function loopAllRequired() {
      gen.forOf("prop", schemaCode, (prop) => {
        cxt.setParams({ missingProperty: prop });
        gen.if((0, code_1$h.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
      });
    }
    function loopUntilMissing(missing, valid2) {
      cxt.setParams({ missingProperty: missing });
      gen.forOf(missing, schemaCode, () => {
        gen.assign(valid2, (0, code_1$h.propertyInData)(gen, data, missing, opts.ownProperties));
        gen.if((0, codegen_1$L.not)(valid2), () => {
          cxt.error();
          gen.break();
        });
      }, codegen_1$L.nil);
    }
  }
};
required$2.default = def$O;
var limitItems$1 = {};
Object.defineProperty(limitItems$1, "__esModule", { value: true });
const codegen_1$K = codegen$1;
const error$v = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxItems" ? "more" : "fewer";
    return (0, codegen_1$K.str)`must NOT have ${comp} than ${schemaCode} items`;
  },
  params: ({ schemaCode }) => (0, codegen_1$K._)`{limit: ${schemaCode}}`
};
const def$N = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: true,
  error: error$v,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxItems" ? codegen_1$K.operators.GT : codegen_1$K.operators.LT;
    cxt.fail$data((0, codegen_1$K._)`${data}.length ${op} ${schemaCode}`);
  }
};
limitItems$1.default = def$N;
var uniqueItems$1 = {};
var equal$4 = {};
Object.defineProperty(equal$4, "__esModule", { value: true });
const equal$3 = fastDeepEqual;
equal$3.code = 'require("ajv/dist/runtime/equal").default';
equal$4.default = equal$3;
Object.defineProperty(uniqueItems$1, "__esModule", { value: true });
const dataType_1$2 = dataType$1;
const codegen_1$J = codegen$1;
const util_1$H = util$1;
const equal_1$5 = equal$4;
const error$u = {
  message: ({ params: { i, j } }) => (0, codegen_1$J.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
  params: ({ params: { i, j } }) => (0, codegen_1$J._)`{i: ${i}, j: ${j}}`
};
const def$M = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: true,
  error: error$u,
  code(cxt) {
    const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
    if (!$data && !schema)
      return;
    const valid2 = gen.let("valid");
    const itemTypes = parentSchema.items ? (0, dataType_1$2.getSchemaTypes)(parentSchema.items) : [];
    cxt.block$data(valid2, validateUniqueItems, (0, codegen_1$J._)`${schemaCode} === false`);
    cxt.ok(valid2);
    function validateUniqueItems() {
      const i = gen.let("i", (0, codegen_1$J._)`${data}.length`);
      const j = gen.let("j");
      cxt.setParams({ i, j });
      gen.assign(valid2, true);
      gen.if((0, codegen_1$J._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
    }
    function canOptimize() {
      return itemTypes.length > 0 && !itemTypes.some((t2) => t2 === "object" || t2 === "array");
    }
    function loopN(i, j) {
      const item = gen.name("item");
      const wrongType = (0, dataType_1$2.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1$2.DataType.Wrong);
      const indices = gen.const("indices", (0, codegen_1$J._)`{}`);
      gen.for((0, codegen_1$J._)`;${i}--;`, () => {
        gen.let(item, (0, codegen_1$J._)`${data}[${i}]`);
        gen.if(wrongType, (0, codegen_1$J._)`continue`);
        if (itemTypes.length > 1)
          gen.if((0, codegen_1$J._)`typeof ${item} == "string"`, (0, codegen_1$J._)`${item} += "_"`);
        gen.if((0, codegen_1$J._)`typeof ${indices}[${item}] == "number"`, () => {
          gen.assign(j, (0, codegen_1$J._)`${indices}[${item}]`);
          cxt.error();
          gen.assign(valid2, false).break();
        }).code((0, codegen_1$J._)`${indices}[${item}] = ${i}`);
      });
    }
    function loopN2(i, j) {
      const eql = (0, util_1$H.useFunc)(gen, equal_1$5.default);
      const outer = gen.name("outer");
      gen.label(outer).for((0, codegen_1$J._)`;${i}--;`, () => gen.for((0, codegen_1$J._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1$J._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
        cxt.error();
        gen.assign(valid2, false).break(outer);
      })));
    }
  }
};
uniqueItems$1.default = def$M;
var _const$1 = {};
Object.defineProperty(_const$1, "__esModule", { value: true });
const codegen_1$I = codegen$1;
const util_1$G = util$1;
const equal_1$4 = equal$4;
const error$t = {
  message: "must be equal to constant",
  params: ({ schemaCode }) => (0, codegen_1$I._)`{allowedValue: ${schemaCode}}`
};
const def$L = {
  keyword: "const",
  $data: true,
  error: error$t,
  code(cxt) {
    const { gen, data, $data, schemaCode, schema } = cxt;
    if ($data || schema && typeof schema == "object") {
      cxt.fail$data((0, codegen_1$I._)`!${(0, util_1$G.useFunc)(gen, equal_1$4.default)}(${data}, ${schemaCode})`);
    } else {
      cxt.fail((0, codegen_1$I._)`${schema} !== ${data}`);
    }
  }
};
_const$1.default = def$L;
var _enum$1 = {};
Object.defineProperty(_enum$1, "__esModule", { value: true });
const codegen_1$H = codegen$1;
const util_1$F = util$1;
const equal_1$3 = equal$4;
const error$s = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode }) => (0, codegen_1$H._)`{allowedValues: ${schemaCode}}`
};
const def$K = {
  keyword: "enum",
  schemaType: "array",
  $data: true,
  error: error$s,
  code(cxt) {
    const { gen, data, $data, schema, schemaCode, it } = cxt;
    if (!$data && schema.length === 0)
      throw new Error("enum must have non-empty array");
    const useLoop = schema.length >= it.opts.loopEnum;
    let eql;
    const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1$F.useFunc)(gen, equal_1$3.default);
    let valid2;
    if (useLoop || $data) {
      valid2 = gen.let("valid");
      cxt.block$data(valid2, loopEnum);
    } else {
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const vSchema = gen.const("vSchema", schemaCode);
      valid2 = (0, codegen_1$H.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
    }
    cxt.pass(valid2);
    function loopEnum() {
      gen.assign(valid2, false);
      gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1$H._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid2, true).break()));
    }
    function equalCode(vSchema, i) {
      const sch = schema[i];
      return typeof sch === "object" && sch !== null ? (0, codegen_1$H._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1$H._)`${data} === ${sch}`;
    }
  }
};
_enum$1.default = def$K;
Object.defineProperty(validation$3, "__esModule", { value: true });
const limitNumber_1$1 = limitNumber$1;
const multipleOf_1$1 = multipleOf$1;
const limitLength_1$1 = limitLength$1;
const pattern_1$1 = pattern$1;
const limitProperties_1$1 = limitProperties$1;
const required_1$1 = required$2;
const limitItems_1$1 = limitItems$1;
const uniqueItems_1$1 = uniqueItems$1;
const const_1$1 = _const$1;
const enum_1$1 = _enum$1;
const validation$2 = [
  // number
  limitNumber_1$1.default,
  multipleOf_1$1.default,
  // string
  limitLength_1$1.default,
  pattern_1$1.default,
  // object
  limitProperties_1$1.default,
  required_1$1.default,
  // array
  limitItems_1$1.default,
  uniqueItems_1$1.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  const_1$1.default,
  enum_1$1.default
];
validation$3.default = validation$2;
var applicator$1 = {};
var additionalItems$1 = {};
Object.defineProperty(additionalItems$1, "__esModule", { value: true });
additionalItems$1.validateAdditionalItems = void 0;
const codegen_1$G = codegen$1;
const util_1$E = util$1;
const error$r = {
  message: ({ params: { len } }) => (0, codegen_1$G.str)`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => (0, codegen_1$G._)`{limit: ${len}}`
};
const def$J = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: error$r,
  code(cxt) {
    const { parentSchema, it } = cxt;
    const { items: items2 } = parentSchema;
    if (!Array.isArray(items2)) {
      (0, util_1$E.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    validateAdditionalItems$1(cxt, items2);
  }
};
function validateAdditionalItems$1(cxt, items2) {
  const { gen, schema, data, keyword: keyword2, it } = cxt;
  it.items = true;
  const len = gen.const("len", (0, codegen_1$G._)`${data}.length`);
  if (schema === false) {
    cxt.setParams({ len: items2.length });
    cxt.pass((0, codegen_1$G._)`${len} <= ${items2.length}`);
  } else if (typeof schema == "object" && !(0, util_1$E.alwaysValidSchema)(it, schema)) {
    const valid2 = gen.var("valid", (0, codegen_1$G._)`${len} <= ${items2.length}`);
    gen.if((0, codegen_1$G.not)(valid2), () => validateItems(valid2));
    cxt.ok(valid2);
  }
  function validateItems(valid2) {
    gen.forRange("i", items2.length, len, (i) => {
      cxt.subschema({ keyword: keyword2, dataProp: i, dataPropType: util_1$E.Type.Num }, valid2);
      if (!it.allErrors)
        gen.if((0, codegen_1$G.not)(valid2), () => gen.break());
    });
  }
}
additionalItems$1.validateAdditionalItems = validateAdditionalItems$1;
additionalItems$1.default = def$J;
var prefixItems$1 = {};
var items$1 = {};
Object.defineProperty(items$1, "__esModule", { value: true });
items$1.validateTuple = void 0;
const codegen_1$F = codegen$1;
const util_1$D = util$1;
const code_1$g = code$2;
const def$I = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(cxt) {
    const { schema, it } = cxt;
    if (Array.isArray(schema))
      return validateTuple$1(cxt, "additionalItems", schema);
    it.items = true;
    if ((0, util_1$D.alwaysValidSchema)(it, schema))
      return;
    cxt.ok((0, code_1$g.validateArray)(cxt));
  }
};
function validateTuple$1(cxt, extraItems, schArr = cxt.schema) {
  const { gen, parentSchema, data, keyword: keyword2, it } = cxt;
  checkStrictTuple(parentSchema);
  if (it.opts.unevaluated && schArr.length && it.items !== true) {
    it.items = util_1$D.mergeEvaluated.items(gen, schArr.length, it.items);
  }
  const valid2 = gen.name("valid");
  const len = gen.const("len", (0, codegen_1$F._)`${data}.length`);
  schArr.forEach((sch, i) => {
    if ((0, util_1$D.alwaysValidSchema)(it, sch))
      return;
    gen.if((0, codegen_1$F._)`${len} > ${i}`, () => cxt.subschema({
      keyword: keyword2,
      schemaProp: i,
      dataProp: i
    }, valid2));
    cxt.ok(valid2);
  });
  function checkStrictTuple(sch) {
    const { opts, errSchemaPath } = it;
    const l = schArr.length;
    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
    if (opts.strictTuples && !fullTuple) {
      const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
      (0, util_1$D.checkStrictMode)(it, msg, opts.strictTuples);
    }
  }
}
items$1.validateTuple = validateTuple$1;
items$1.default = def$I;
Object.defineProperty(prefixItems$1, "__esModule", { value: true });
const items_1$3 = items$1;
const def$H = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (cxt) => (0, items_1$3.validateTuple)(cxt, "items")
};
prefixItems$1.default = def$H;
var items2020$1 = {};
Object.defineProperty(items2020$1, "__esModule", { value: true });
const codegen_1$E = codegen$1;
const util_1$C = util$1;
const code_1$f = code$2;
const additionalItems_1$3 = additionalItems$1;
const error$q = {
  message: ({ params: { len } }) => (0, codegen_1$E.str)`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => (0, codegen_1$E._)`{limit: ${len}}`
};
const def$G = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: error$q,
  code(cxt) {
    const { schema, parentSchema, it } = cxt;
    const { prefixItems: prefixItems2 } = parentSchema;
    it.items = true;
    if ((0, util_1$C.alwaysValidSchema)(it, schema))
      return;
    if (prefixItems2)
      (0, additionalItems_1$3.validateAdditionalItems)(cxt, prefixItems2);
    else
      cxt.ok((0, code_1$f.validateArray)(cxt));
  }
};
items2020$1.default = def$G;
var contains$1 = {};
Object.defineProperty(contains$1, "__esModule", { value: true });
const codegen_1$D = codegen$1;
const util_1$B = util$1;
const error$p = {
  message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$D.str)`must contain at least ${min} valid item(s)` : (0, codegen_1$D.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
  params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$D._)`{minContains: ${min}}` : (0, codegen_1$D._)`{minContains: ${min}, maxContains: ${max}}`
};
const def$F = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: true,
  error: error$p,
  code(cxt) {
    const { gen, schema, parentSchema, data, it } = cxt;
    let min;
    let max;
    const { minContains, maxContains } = parentSchema;
    if (it.opts.next) {
      min = minContains === void 0 ? 1 : minContains;
      max = maxContains;
    } else {
      min = 1;
    }
    const len = gen.const("len", (0, codegen_1$D._)`${data}.length`);
    cxt.setParams({ min, max });
    if (max === void 0 && min === 0) {
      (0, util_1$B.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
      return;
    }
    if (max !== void 0 && min > max) {
      (0, util_1$B.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
      cxt.fail();
      return;
    }
    if ((0, util_1$B.alwaysValidSchema)(it, schema)) {
      let cond = (0, codegen_1$D._)`${len} >= ${min}`;
      if (max !== void 0)
        cond = (0, codegen_1$D._)`${cond} && ${len} <= ${max}`;
      cxt.pass(cond);
      return;
    }
    it.items = true;
    const valid2 = gen.name("valid");
    if (max === void 0 && min === 1) {
      validateItems(valid2, () => gen.if(valid2, () => gen.break()));
    } else if (min === 0) {
      gen.let(valid2, true);
      if (max !== void 0)
        gen.if((0, codegen_1$D._)`${data}.length > 0`, validateItemsWithCount);
    } else {
      gen.let(valid2, false);
      validateItemsWithCount();
    }
    cxt.result(valid2, () => cxt.reset());
    function validateItemsWithCount() {
      const schValid = gen.name("_valid");
      const count = gen.let("count", 0);
      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
    }
    function validateItems(_valid, block) {
      gen.forRange("i", 0, len, (i) => {
        cxt.subschema({
          keyword: "contains",
          dataProp: i,
          dataPropType: util_1$B.Type.Num,
          compositeRule: true
        }, _valid);
        block();
      });
    }
    function checkLimits(count) {
      gen.code((0, codegen_1$D._)`${count}++`);
      if (max === void 0) {
        gen.if((0, codegen_1$D._)`${count} >= ${min}`, () => gen.assign(valid2, true).break());
      } else {
        gen.if((0, codegen_1$D._)`${count} > ${max}`, () => gen.assign(valid2, false).break());
        if (min === 1)
          gen.assign(valid2, true);
        else
          gen.if((0, codegen_1$D._)`${count} >= ${min}`, () => gen.assign(valid2, true));
      }
    }
  }
};
contains$1.default = def$F;
var dependencies$1 = {};
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.validateSchemaDeps = exports$1.validatePropertyDeps = exports$1.error = void 0;
  const codegen_12 = codegen$1;
  const util_12 = util$1;
  const code_12 = code$2;
  exports$1.error = {
    message: ({ params: { property, depsCount, deps } }) => {
      const property_ies = depsCount === 1 ? "property" : "properties";
      return (0, codegen_12.str)`must have ${property_ies} ${deps} when property ${property} is present`;
    },
    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_12._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
    // TODO change to reference
  };
  const def2 = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports$1.error,
    code(cxt) {
      const [propDeps, schDeps] = splitDependencies(cxt);
      validatePropertyDeps(cxt, propDeps);
      validateSchemaDeps(cxt, schDeps);
    }
  };
  function splitDependencies({ schema }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key2 in schema) {
      if (key2 === "__proto__")
        continue;
      const deps = Array.isArray(schema[key2]) ? propertyDeps : schemaDeps;
      deps[key2] = schema[key2];
    }
    return [propertyDeps, schemaDeps];
  }
  function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
    const { gen, data, it } = cxt;
    if (Object.keys(propertyDeps).length === 0)
      return;
    const missing = gen.let("missing");
    for (const prop in propertyDeps) {
      const deps = propertyDeps[prop];
      if (deps.length === 0)
        continue;
      const hasProperty = (0, code_12.propertyInData)(gen, data, prop, it.opts.ownProperties);
      cxt.setParams({
        property: prop,
        depsCount: deps.length,
        deps: deps.join(", ")
      });
      if (it.allErrors) {
        gen.if(hasProperty, () => {
          for (const depProp of deps) {
            (0, code_12.checkReportMissingProp)(cxt, depProp);
          }
        });
      } else {
        gen.if((0, codegen_12._)`${hasProperty} && (${(0, code_12.checkMissingProp)(cxt, deps, missing)})`);
        (0, code_12.reportMissingProp)(cxt, missing);
        gen.else();
      }
    }
  }
  exports$1.validatePropertyDeps = validatePropertyDeps;
  function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
    const { gen, data, keyword: keyword2, it } = cxt;
    const valid2 = gen.name("valid");
    for (const prop in schemaDeps) {
      if ((0, util_12.alwaysValidSchema)(it, schemaDeps[prop]))
        continue;
      gen.if(
        (0, code_12.propertyInData)(gen, data, prop, it.opts.ownProperties),
        () => {
          const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid2);
          cxt.mergeValidEvaluated(schCxt, valid2);
        },
        () => gen.var(valid2, true)
        // TODO var
      );
      cxt.ok(valid2);
    }
  }
  exports$1.validateSchemaDeps = validateSchemaDeps;
  exports$1.default = def2;
})(dependencies$1);
var propertyNames$1 = {};
Object.defineProperty(propertyNames$1, "__esModule", { value: true });
const codegen_1$C = codegen$1;
const util_1$A = util$1;
const error$o = {
  message: "property name must be valid",
  params: ({ params }) => (0, codegen_1$C._)`{propertyName: ${params.propertyName}}`
};
const def$E = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: error$o,
  code(cxt) {
    const { gen, schema, data, it } = cxt;
    if ((0, util_1$A.alwaysValidSchema)(it, schema))
      return;
    const valid2 = gen.name("valid");
    gen.forIn("key", data, (key2) => {
      cxt.setParams({ propertyName: key2 });
      cxt.subschema({
        keyword: "propertyNames",
        data: key2,
        dataTypes: ["string"],
        propertyName: key2,
        compositeRule: true
      }, valid2);
      gen.if((0, codegen_1$C.not)(valid2), () => {
        cxt.error(true);
        if (!it.allErrors)
          gen.break();
      });
    });
    cxt.ok(valid2);
  }
};
propertyNames$1.default = def$E;
var additionalProperties$2 = {};
Object.defineProperty(additionalProperties$2, "__esModule", { value: true });
const code_1$e = code$2;
const codegen_1$B = codegen$1;
const names_1$7 = names$3;
const util_1$z = util$1;
const error$n = {
  message: "must NOT have additional properties",
  params: ({ params }) => (0, codegen_1$B._)`{additionalProperty: ${params.additionalProperty}}`
};
const def$D = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: true,
  trackErrors: true,
  error: error$n,
  code(cxt) {
    const { gen, schema, parentSchema, data, errsCount, it } = cxt;
    if (!errsCount)
      throw new Error("ajv implementation error");
    const { allErrors, opts } = it;
    it.props = true;
    if (opts.removeAdditional !== "all" && (0, util_1$z.alwaysValidSchema)(it, schema))
      return;
    const props = (0, code_1$e.allSchemaProperties)(parentSchema.properties);
    const patProps = (0, code_1$e.allSchemaProperties)(parentSchema.patternProperties);
    checkAdditionalProperties();
    cxt.ok((0, codegen_1$B._)`${errsCount} === ${names_1$7.default.errors}`);
    function checkAdditionalProperties() {
      gen.forIn("key", data, (key2) => {
        if (!props.length && !patProps.length)
          additionalPropertyCode(key2);
        else
          gen.if(isAdditional(key2), () => additionalPropertyCode(key2));
      });
    }
    function isAdditional(key2) {
      let definedProp;
      if (props.length > 8) {
        const propsSchema = (0, util_1$z.schemaRefOrVal)(it, parentSchema.properties, "properties");
        definedProp = (0, code_1$e.isOwnProperty)(gen, propsSchema, key2);
      } else if (props.length) {
        definedProp = (0, codegen_1$B.or)(...props.map((p) => (0, codegen_1$B._)`${key2} === ${p}`));
      } else {
        definedProp = codegen_1$B.nil;
      }
      if (patProps.length) {
        definedProp = (0, codegen_1$B.or)(definedProp, ...patProps.map((p) => (0, codegen_1$B._)`${(0, code_1$e.usePattern)(cxt, p)}.test(${key2})`));
      }
      return (0, codegen_1$B.not)(definedProp);
    }
    function deleteAdditional(key2) {
      gen.code((0, codegen_1$B._)`delete ${data}[${key2}]`);
    }
    function additionalPropertyCode(key2) {
      if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
        deleteAdditional(key2);
        return;
      }
      if (schema === false) {
        cxt.setParams({ additionalProperty: key2 });
        cxt.error();
        if (!allErrors)
          gen.break();
        return;
      }
      if (typeof schema == "object" && !(0, util_1$z.alwaysValidSchema)(it, schema)) {
        const valid2 = gen.name("valid");
        if (opts.removeAdditional === "failing") {
          applyAdditionalSchema(key2, valid2, false);
          gen.if((0, codegen_1$B.not)(valid2), () => {
            cxt.reset();
            deleteAdditional(key2);
          });
        } else {
          applyAdditionalSchema(key2, valid2);
          if (!allErrors)
            gen.if((0, codegen_1$B.not)(valid2), () => gen.break());
        }
      }
    }
    function applyAdditionalSchema(key2, valid2, errors2) {
      const subschema2 = {
        keyword: "additionalProperties",
        dataProp: key2,
        dataPropType: util_1$z.Type.Str
      };
      if (errors2 === false) {
        Object.assign(subschema2, {
          compositeRule: true,
          createErrors: false,
          allErrors: false
        });
      }
      cxt.subschema(subschema2, valid2);
    }
  }
};
additionalProperties$2.default = def$D;
var properties$4 = {};
Object.defineProperty(properties$4, "__esModule", { value: true });
const validate_1$2 = validate$1;
const code_1$d = code$2;
const util_1$y = util$1;
const additionalProperties_1$3 = additionalProperties$2;
const def$C = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema, parentSchema, data, it } = cxt;
    if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
      additionalProperties_1$3.default.code(new validate_1$2.KeywordCxt(it, additionalProperties_1$3.default, "additionalProperties"));
    }
    const allProps = (0, code_1$d.allSchemaProperties)(schema);
    for (const prop of allProps) {
      it.definedProperties.add(prop);
    }
    if (it.opts.unevaluated && allProps.length && it.props !== true) {
      it.props = util_1$y.mergeEvaluated.props(gen, (0, util_1$y.toHash)(allProps), it.props);
    }
    const properties2 = allProps.filter((p) => !(0, util_1$y.alwaysValidSchema)(it, schema[p]));
    if (properties2.length === 0)
      return;
    const valid2 = gen.name("valid");
    for (const prop of properties2) {
      if (hasDefault(prop)) {
        applyPropertySchema(prop);
      } else {
        gen.if((0, code_1$d.propertyInData)(gen, data, prop, it.opts.ownProperties));
        applyPropertySchema(prop);
        if (!it.allErrors)
          gen.else().var(valid2, true);
        gen.endIf();
      }
      cxt.it.definedProperties.add(prop);
      cxt.ok(valid2);
    }
    function hasDefault(prop) {
      return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
    }
    function applyPropertySchema(prop) {
      cxt.subschema({
        keyword: "properties",
        schemaProp: prop,
        dataProp: prop
      }, valid2);
    }
  }
};
properties$4.default = def$C;
var patternProperties$1 = {};
Object.defineProperty(patternProperties$1, "__esModule", { value: true });
const code_1$c = code$2;
const codegen_1$A = codegen$1;
const util_1$x = util$1;
const util_2$2 = util$1;
const def$B = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema, data, parentSchema, it } = cxt;
    const { opts } = it;
    const patterns = (0, code_1$c.allSchemaProperties)(schema);
    const alwaysValidPatterns = patterns.filter((p) => (0, util_1$x.alwaysValidSchema)(it, schema[p]));
    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
      return;
    }
    const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
    const valid2 = gen.name("valid");
    if (it.props !== true && !(it.props instanceof codegen_1$A.Name)) {
      it.props = (0, util_2$2.evaluatedPropsToName)(gen, it.props);
    }
    const { props } = it;
    validatePatternProperties();
    function validatePatternProperties() {
      for (const pat of patterns) {
        if (checkProperties)
          checkMatchingProperties(pat);
        if (it.allErrors) {
          validateProperties(pat);
        } else {
          gen.var(valid2, true);
          validateProperties(pat);
          gen.if(valid2);
        }
      }
    }
    function checkMatchingProperties(pat) {
      for (const prop in checkProperties) {
        if (new RegExp(pat).test(prop)) {
          (0, util_1$x.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
        }
      }
    }
    function validateProperties(pat) {
      gen.forIn("key", data, (key2) => {
        gen.if((0, codegen_1$A._)`${(0, code_1$c.usePattern)(cxt, pat)}.test(${key2})`, () => {
          const alwaysValid = alwaysValidPatterns.includes(pat);
          if (!alwaysValid) {
            cxt.subschema({
              keyword: "patternProperties",
              schemaProp: pat,
              dataProp: key2,
              dataPropType: util_2$2.Type.Str
            }, valid2);
          }
          if (it.opts.unevaluated && props !== true) {
            gen.assign((0, codegen_1$A._)`${props}[${key2}]`, true);
          } else if (!alwaysValid && !it.allErrors) {
            gen.if((0, codegen_1$A.not)(valid2), () => gen.break());
          }
        });
      });
    }
  }
};
patternProperties$1.default = def$B;
var not$1 = {};
Object.defineProperty(not$1, "__esModule", { value: true });
const util_1$w = util$1;
const def$A = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  code(cxt) {
    const { gen, schema, it } = cxt;
    if ((0, util_1$w.alwaysValidSchema)(it, schema)) {
      cxt.fail();
      return;
    }
    const valid2 = gen.name("valid");
    cxt.subschema({
      keyword: "not",
      compositeRule: true,
      createErrors: false,
      allErrors: false
    }, valid2);
    cxt.failResult(valid2, () => cxt.reset(), () => cxt.error());
  },
  error: { message: "must NOT be valid" }
};
not$1.default = def$A;
var anyOf$1 = {};
Object.defineProperty(anyOf$1, "__esModule", { value: true });
const code_1$b = code$2;
const def$z = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: true,
  code: code_1$b.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
anyOf$1.default = def$z;
var oneOf$2 = {};
Object.defineProperty(oneOf$2, "__esModule", { value: true });
const codegen_1$z = codegen$1;
const util_1$v = util$1;
const error$m = {
  message: "must match exactly one schema in oneOf",
  params: ({ params }) => (0, codegen_1$z._)`{passingSchemas: ${params.passing}}`
};
const def$y = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: true,
  error: error$m,
  code(cxt) {
    const { gen, schema, parentSchema, it } = cxt;
    if (!Array.isArray(schema))
      throw new Error("ajv implementation error");
    if (it.opts.discriminator && parentSchema.discriminator)
      return;
    const schArr = schema;
    const valid2 = gen.let("valid", false);
    const passing = gen.let("passing", null);
    const schValid = gen.name("_valid");
    cxt.setParams({ passing });
    gen.block(validateOneOf);
    cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
    function validateOneOf() {
      schArr.forEach((sch, i) => {
        let schCxt;
        if ((0, util_1$v.alwaysValidSchema)(it, sch)) {
          gen.var(schValid, true);
        } else {
          schCxt = cxt.subschema({
            keyword: "oneOf",
            schemaProp: i,
            compositeRule: true
          }, schValid);
        }
        if (i > 0) {
          gen.if((0, codegen_1$z._)`${schValid} && ${valid2}`).assign(valid2, false).assign(passing, (0, codegen_1$z._)`[${passing}, ${i}]`).else();
        }
        gen.if(schValid, () => {
          gen.assign(valid2, true);
          gen.assign(passing, i);
          if (schCxt)
            cxt.mergeEvaluated(schCxt, codegen_1$z.Name);
        });
      });
    }
  }
};
oneOf$2.default = def$y;
var allOf$1 = {};
Object.defineProperty(allOf$1, "__esModule", { value: true });
const util_1$u = util$1;
const def$x = {
  keyword: "allOf",
  schemaType: "array",
  code(cxt) {
    const { gen, schema, it } = cxt;
    if (!Array.isArray(schema))
      throw new Error("ajv implementation error");
    const valid2 = gen.name("valid");
    schema.forEach((sch, i) => {
      if ((0, util_1$u.alwaysValidSchema)(it, sch))
        return;
      const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid2);
      cxt.ok(valid2);
      cxt.mergeEvaluated(schCxt);
    });
  }
};
allOf$1.default = def$x;
var _if$1 = {};
Object.defineProperty(_if$1, "__esModule", { value: true });
const codegen_1$y = codegen$1;
const util_1$t = util$1;
const error$l = {
  message: ({ params }) => (0, codegen_1$y.str)`must match "${params.ifClause}" schema`,
  params: ({ params }) => (0, codegen_1$y._)`{failingKeyword: ${params.ifClause}}`
};
const def$w = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  error: error$l,
  code(cxt) {
    const { gen, parentSchema, it } = cxt;
    if (parentSchema.then === void 0 && parentSchema.else === void 0) {
      (0, util_1$t.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
    }
    const hasThen = hasSchema$1(it, "then");
    const hasElse = hasSchema$1(it, "else");
    if (!hasThen && !hasElse)
      return;
    const valid2 = gen.let("valid", true);
    const schValid = gen.name("_valid");
    validateIf();
    cxt.reset();
    if (hasThen && hasElse) {
      const ifClause = gen.let("ifClause");
      cxt.setParams({ ifClause });
      gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
    } else if (hasThen) {
      gen.if(schValid, validateClause("then"));
    } else {
      gen.if((0, codegen_1$y.not)(schValid), validateClause("else"));
    }
    cxt.pass(valid2, () => cxt.error(true));
    function validateIf() {
      const schCxt = cxt.subschema({
        keyword: "if",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, schValid);
      cxt.mergeEvaluated(schCxt);
    }
    function validateClause(keyword2, ifClause) {
      return () => {
        const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
        gen.assign(valid2, schValid);
        cxt.mergeValidEvaluated(schCxt, valid2);
        if (ifClause)
          gen.assign(ifClause, (0, codegen_1$y._)`${keyword2}`);
        else
          cxt.setParams({ ifClause: keyword2 });
      };
    }
  }
};
function hasSchema$1(it, keyword2) {
  const schema = it.schema[keyword2];
  return schema !== void 0 && !(0, util_1$t.alwaysValidSchema)(it, schema);
}
_if$1.default = def$w;
var thenElse$1 = {};
Object.defineProperty(thenElse$1, "__esModule", { value: true });
const util_1$s = util$1;
const def$v = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: keyword2, parentSchema, it }) {
    if (parentSchema.if === void 0)
      (0, util_1$s.checkStrictMode)(it, `"${keyword2}" without "if" is ignored`);
  }
};
thenElse$1.default = def$v;
Object.defineProperty(applicator$1, "__esModule", { value: true });
const additionalItems_1$2 = additionalItems$1;
const prefixItems_1$1 = prefixItems$1;
const items_1$2 = items$1;
const items2020_1$1 = items2020$1;
const contains_1$1 = contains$1;
const dependencies_1$1 = dependencies$1;
const propertyNames_1$1 = propertyNames$1;
const additionalProperties_1$2 = additionalProperties$2;
const properties_1$1 = properties$4;
const patternProperties_1$1 = patternProperties$1;
const not_1$1 = not$1;
const anyOf_1$1 = anyOf$1;
const oneOf_1$1 = oneOf$2;
const allOf_1$1 = allOf$1;
const if_1$1 = _if$1;
const thenElse_1$1 = thenElse$1;
function getApplicator$1(draft2020 = false) {
  const applicator2 = [
    // any
    not_1$1.default,
    anyOf_1$1.default,
    oneOf_1$1.default,
    allOf_1$1.default,
    if_1$1.default,
    thenElse_1$1.default,
    // object
    propertyNames_1$1.default,
    additionalProperties_1$2.default,
    dependencies_1$1.default,
    properties_1$1.default,
    patternProperties_1$1.default
  ];
  if (draft2020)
    applicator2.push(prefixItems_1$1.default, items2020_1$1.default);
  else
    applicator2.push(additionalItems_1$2.default, items_1$2.default);
  applicator2.push(contains_1$1.default);
  return applicator2;
}
applicator$1.default = getApplicator$1;
var format$5 = {};
var format$4 = {};
Object.defineProperty(format$4, "__esModule", { value: true });
const codegen_1$x = codegen$1;
const error$k = {
  message: ({ schemaCode }) => (0, codegen_1$x.str)`must match format "${schemaCode}"`,
  params: ({ schemaCode }) => (0, codegen_1$x._)`{format: ${schemaCode}}`
};
const def$u = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: true,
  error: error$k,
  code(cxt, ruleType) {
    const { gen, data, $data, schema, schemaCode, it } = cxt;
    const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
    if (!opts.validateFormats)
      return;
    if ($data)
      validate$DataFormat();
    else
      validateFormat();
    function validate$DataFormat() {
      const fmts = gen.scopeValue("formats", {
        ref: self2.formats,
        code: opts.code.formats
      });
      const fDef = gen.const("fDef", (0, codegen_1$x._)`${fmts}[${schemaCode}]`);
      const fType = gen.let("fType");
      const format2 = gen.let("format");
      gen.if((0, codegen_1$x._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1$x._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1$x._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1$x._)`"string"`).assign(format2, fDef));
      cxt.fail$data((0, codegen_1$x.or)(unknownFmt(), invalidFmt()));
      function unknownFmt() {
        if (opts.strictSchema === false)
          return codegen_1$x.nil;
        return (0, codegen_1$x._)`${schemaCode} && !${format2}`;
      }
      function invalidFmt() {
        const callFormat = schemaEnv.$async ? (0, codegen_1$x._)`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : (0, codegen_1$x._)`${format2}(${data})`;
        const validData = (0, codegen_1$x._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
        return (0, codegen_1$x._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
      }
    }
    function validateFormat() {
      const formatDef = self2.formats[schema];
      if (!formatDef) {
        unknownFormat();
        return;
      }
      if (formatDef === true)
        return;
      const [fmtType, format2, fmtRef] = getFormat(formatDef);
      if (fmtType === ruleType)
        cxt.pass(validCondition());
      function unknownFormat() {
        if (opts.strictSchema === false) {
          self2.logger.warn(unknownMsg());
          return;
        }
        throw new Error(unknownMsg());
        function unknownMsg() {
          return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
        }
      }
      function getFormat(fmtDef) {
        const code2 = fmtDef instanceof RegExp ? (0, codegen_1$x.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1$x._)`${opts.code.formats}${(0, codegen_1$x.getProperty)(schema)}` : void 0;
        const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code: code2 });
        if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
          return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1$x._)`${fmt}.validate`];
        }
        return ["string", fmtDef, fmt];
      }
      function validCondition() {
        if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
          if (!schemaEnv.$async)
            throw new Error("async format in sync schema");
          return (0, codegen_1$x._)`await ${fmtRef}(${data})`;
        }
        return typeof format2 == "function" ? (0, codegen_1$x._)`${fmtRef}(${data})` : (0, codegen_1$x._)`${fmtRef}.test(${data})`;
      }
    }
  }
};
format$4.default = def$u;
Object.defineProperty(format$5, "__esModule", { value: true });
const format_1$3 = format$4;
const format$3 = [format_1$3.default];
format$5.default = format$3;
var metadata$1 = {};
Object.defineProperty(metadata$1, "__esModule", { value: true });
metadata$1.contentVocabulary = metadata$1.metadataVocabulary = void 0;
metadata$1.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
metadata$1.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(draft7$1, "__esModule", { value: true });
const core_1$1 = core$4;
const validation_1$1 = validation$3;
const applicator_1$1 = applicator$1;
const format_1$2 = format$5;
const metadata_1$1 = metadata$1;
const draft7Vocabularies$1 = [
  core_1$1.default,
  validation_1$1.default,
  (0, applicator_1$1.default)(),
  format_1$2.default,
  metadata_1$1.metadataVocabulary,
  metadata_1$1.contentVocabulary
];
draft7$1.default = draft7Vocabularies$1;
var discriminator$1 = {};
var types$2 = {};
Object.defineProperty(types$2, "__esModule", { value: true });
types$2.DiscrError = void 0;
var DiscrError$1;
(function(DiscrError2) {
  DiscrError2["Tag"] = "tag";
  DiscrError2["Mapping"] = "mapping";
})(DiscrError$1 || (types$2.DiscrError = DiscrError$1 = {}));
Object.defineProperty(discriminator$1, "__esModule", { value: true });
const codegen_1$w = codegen$1;
const types_1$1 = types$2;
const compile_1$2 = compile$1;
const ref_error_1$2 = ref_error$1;
const util_1$r = util$1;
const error$j = {
  message: ({ params: { discrError, tagName } }) => discrError === types_1$1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
  params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1$w._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
};
const def$t = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error: error$j,
  code(cxt) {
    const { gen, data, schema, parentSchema, it } = cxt;
    const { oneOf: oneOf2 } = parentSchema;
    if (!it.opts.discriminator) {
      throw new Error("discriminator: requires discriminator option");
    }
    const tagName = schema.propertyName;
    if (typeof tagName != "string")
      throw new Error("discriminator: requires propertyName");
    if (schema.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!oneOf2)
      throw new Error("discriminator: requires oneOf keyword");
    const valid2 = gen.let("valid", false);
    const tag = gen.const("tag", (0, codegen_1$w._)`${data}${(0, codegen_1$w.getProperty)(tagName)}`);
    gen.if((0, codegen_1$w._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1$1.DiscrError.Tag, tag, tagName }));
    cxt.ok(valid2);
    function validateMapping() {
      const mapping = getMapping();
      gen.if(false);
      for (const tagValue in mapping) {
        gen.elseIf((0, codegen_1$w._)`${tag} === ${tagValue}`);
        gen.assign(valid2, applyTagSchema(mapping[tagValue]));
      }
      gen.else();
      cxt.error(false, { discrError: types_1$1.DiscrError.Mapping, tag, tagName });
      gen.endIf();
    }
    function applyTagSchema(schemaProp) {
      const _valid = gen.name("valid");
      const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
      cxt.mergeEvaluated(schCxt, codegen_1$w.Name);
      return _valid;
    }
    function getMapping() {
      var _a;
      const oneOfMapping = {};
      const topRequired = hasRequired(parentSchema);
      let tagRequired = true;
      for (let i = 0; i < oneOf2.length; i++) {
        let sch = oneOf2[i];
        if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1$r.schemaHasRulesButRef)(sch, it.self.RULES)) {
          const ref2 = sch.$ref;
          sch = compile_1$2.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref2);
          if (sch instanceof compile_1$2.SchemaEnv)
            sch = sch.schema;
          if (sch === void 0)
            throw new ref_error_1$2.default(it.opts.uriResolver, it.baseId, ref2);
        }
        const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
        if (typeof propSch != "object") {
          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
        }
        tagRequired = tagRequired && (topRequired || hasRequired(sch));
        addMappings(propSch, i);
      }
      if (!tagRequired)
        throw new Error(`discriminator: "${tagName}" must be required`);
      return oneOfMapping;
      function hasRequired({ required: required2 }) {
        return Array.isArray(required2) && required2.includes(tagName);
      }
      function addMappings(sch, i) {
        if (sch.const) {
          addMapping(sch.const, i);
        } else if (sch.enum) {
          for (const tagValue of sch.enum) {
            addMapping(tagValue, i);
          }
        } else {
          throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
        }
      }
      function addMapping(tagValue, i) {
        if (typeof tagValue != "string" || tagValue in oneOfMapping) {
          throw new Error(`discriminator: "${tagName}" values must be unique strings`);
        }
        oneOfMapping[tagValue] = i;
      }
    }
  }
};
discriminator$1.default = def$t;
const $schema$1 = "http://json-schema.org/draft-07/schema#";
const $id$2 = "http://json-schema.org/draft-07/schema#";
const title$1 = "Core schema meta-schema";
const definitions$1 = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        "default": 0
      }
    ]
  },
  simpleTypes: {
    "enum": [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: true,
    "default": []
  }
};
const type$2 = [
  "object",
  "boolean"
];
const properties$3 = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  "default": true,
  readOnly: {
    type: "boolean",
    "default": false
  },
  examples: {
    type: "array",
    items: true
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    "default": true
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    "default": false
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    "default": {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  "const": true,
  "enum": {
    type: "array",
    items: true,
    minItems: 1,
    uniqueItems: true
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: true
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  "if": {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  "else": {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
};
const require$$3$1 = {
  $schema: $schema$1,
  $id: $id$2,
  title: title$1,
  definitions: definitions$1,
  type: type$2,
  properties: properties$3,
  "default": true
};
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.MissingRefError = exports$1.ValidationError = exports$1.CodeGen = exports$1.Name = exports$1.nil = exports$1.stringify = exports$1.str = exports$1._ = exports$1.KeywordCxt = exports$1.Ajv = void 0;
  const core_12 = core$5;
  const draft7_1 = draft7$1;
  const discriminator_1 = discriminator$1;
  const draft7MetaSchema = require$$3$1;
  const META_SUPPORT_DATA = ["/properties"];
  const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
  class Ajv extends core_12.default {
    _addVocabularies() {
      super._addVocabularies();
      draft7_1.default.forEach((v) => this.addVocabulary(v));
      if (this.opts.discriminator)
        this.addKeyword(discriminator_1.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      if (!this.opts.meta)
        return;
      const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
      this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
      this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
    }
  }
  exports$1.Ajv = Ajv;
  module2.exports = exports$1 = Ajv;
  module2.exports.Ajv = Ajv;
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.default = Ajv;
  var validate_12 = validate$1;
  Object.defineProperty(exports$1, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen$1;
  Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports$1, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  var validation_error_12 = validation_error$1;
  Object.defineProperty(exports$1, "ValidationError", { enumerable: true, get: function() {
    return validation_error_12.default;
  } });
  var ref_error_12 = ref_error$1;
  Object.defineProperty(exports$1, "MissingRefError", { enumerable: true, get: function() {
    return ref_error_12.default;
  } });
})(ajv$1, ajv$1.exports);
var ajvExports$1 = ajv$1.exports;
var dist = { exports: {} };
var formats = {};
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.formatNames = exports$1.fastFormats = exports$1.fullFormats = void 0;
  function fmtDef(validate2, compare2) {
    return { validate: validate2, compare: compare2 };
  }
  exports$1.fullFormats = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: fmtDef(date, compareDate),
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: fmtDef(time, compareTime),
    "date-time": fmtDef(date_time, compareDateTime),
    // duration: https://tools.ietf.org/html/rfc3339#appendix-A
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri: uri2,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    // uri-template: https://tools.ietf.org/html/rfc6570
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    // For the source: https://gist.github.com/dperini/729294
    // For test cases: https://mathiasbynens.be/demo/url-regex
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex,
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
    // byte: https://github.com/miguelmota/is-base64
    byte,
    // signed 32 bit integer
    int32: { type: "number", validate: validateInt32 },
    // signed 64 bit integer
    int64: { type: "number", validate: validateInt64 },
    // C-type float
    float: { type: "number", validate: validateNumber3 },
    // C-type double
    double: { type: "number", validate: validateNumber3 },
    // hint to the UI to hide input strings
    password: true,
    // unchecked string payload
    binary: true
  };
  exports$1.fastFormats = {
    ...exports$1.fullFormats,
    date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
    time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
    "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
  };
  exports$1.formatNames = Object.keys(exports$1.fullFormats);
  function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function date(str) {
    const matches = DATE.exec(str);
    if (!matches)
      return false;
    const year = +matches[1];
    const month = +matches[2];
    const day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
  }
  function compareDate(d1, d2) {
    if (!(d1 && d2))
      return void 0;
    if (d1 > d2)
      return 1;
    if (d1 < d2)
      return -1;
    return 0;
  }
  const TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
  function time(str, withTimeZone) {
    const matches = TIME.exec(str);
    if (!matches)
      return false;
    const hour = +matches[1];
    const minute = +matches[2];
    const second = +matches[3];
    const timeZone = matches[5];
    return (hour <= 23 && minute <= 59 && second <= 59 || hour === 23 && minute === 59 && second === 60) && (!withTimeZone || timeZone !== "");
  }
  function compareTime(t1, t2) {
    if (!(t1 && t2))
      return void 0;
    const a1 = TIME.exec(t1);
    const a2 = TIME.exec(t2);
    if (!(a1 && a2))
      return void 0;
    t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
    t2 = a2[1] + a2[2] + a2[3] + (a2[4] || "");
    if (t1 > t2)
      return 1;
    if (t1 < t2)
      return -1;
    return 0;
  }
  const DATE_TIME_SEPARATOR = /t|\s/i;
  function date_time(str) {
    const dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true);
  }
  function compareDateTime(dt1, dt2) {
    if (!(dt1 && dt2))
      return void 0;
    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
    const res = compareDate(d1, d2);
    if (res === void 0)
      return void 0;
    return res || compareTime(t1, t2);
  }
  const NOT_URI_FRAGMENT = /\/|:/;
  const URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function uri2(str) {
    return NOT_URI_FRAGMENT.test(str) && URI.test(str);
  }
  const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function byte(str) {
    BYTE.lastIndex = 0;
    return BYTE.test(str);
  }
  const MIN_INT32 = -2147483648;
  const MAX_INT32 = 2 ** 31 - 1;
  function validateInt32(value) {
    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
  }
  function validateInt64(value) {
    return Number.isInteger(value);
  }
  function validateNumber3() {
    return true;
  }
  const Z_ANCHOR = /[^\\]\\Z/;
  function regex(str) {
    if (Z_ANCHOR.test(str))
      return false;
    try {
      new RegExp(str);
      return true;
    } catch (e) {
      return false;
    }
  }
})(formats);
var limit = {};
var ajv = { exports: {} };
var core$2 = {};
var validate = {};
var boolSchema = {};
var errors$3 = {};
var codegen = {};
var code$1 = {};
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.regexpCode = exports$1.getEsmExportName = exports$1.getProperty = exports$1.safeStringify = exports$1.stringify = exports$1.strConcat = exports$1.addCodeArg = exports$1.str = exports$1._ = exports$1.nil = exports$1._Code = exports$1.Name = exports$1.IDENTIFIER = exports$1._CodeOrName = void 0;
  class _CodeOrName {
  }
  exports$1._CodeOrName = _CodeOrName;
  exports$1.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class Name extends _CodeOrName {
    constructor(s) {
      super();
      if (!exports$1.IDENTIFIER.test(s))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = s;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  exports$1.Name = Name;
  class _Code extends _CodeOrName {
    constructor(code2) {
      super();
      this._items = typeof code2 === "string" ? [code2] : code2;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return false;
      const item = this._items[0];
      return item === "" || item === '""';
    }
    get str() {
      var _a;
      return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
    }
    get names() {
      var _a;
      return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names2, c) => {
        if (c instanceof Name)
          names2[c.str] = (names2[c.str] || 0) + 1;
        return names2;
      }, {});
    }
  }
  exports$1._Code = _Code;
  exports$1.nil = new _Code("");
  function _(strs, ...args) {
    const code2 = [strs[0]];
    let i = 0;
    while (i < args.length) {
      addCodeArg(code2, args[i]);
      code2.push(strs[++i]);
    }
    return new _Code(code2);
  }
  exports$1._ = _;
  const plus = new _Code("+");
  function str(strs, ...args) {
    const expr = [safeStringify(strs[0])];
    let i = 0;
    while (i < args.length) {
      expr.push(plus);
      addCodeArg(expr, args[i]);
      expr.push(plus, safeStringify(strs[++i]));
    }
    optimize(expr);
    return new _Code(expr);
  }
  exports$1.str = str;
  function addCodeArg(code2, arg) {
    if (arg instanceof _Code)
      code2.push(...arg._items);
    else if (arg instanceof Name)
      code2.push(arg);
    else
      code2.push(interpolate(arg));
  }
  exports$1.addCodeArg = addCodeArg;
  function optimize(expr) {
    let i = 1;
    while (i < expr.length - 1) {
      if (expr[i] === plus) {
        const res = mergeExprItems(expr[i - 1], expr[i + 1]);
        if (res !== void 0) {
          expr.splice(i - 1, 3, res);
          continue;
        }
        expr[i++] = "+";
      }
      i++;
    }
  }
  function mergeExprItems(a, b) {
    if (b === '""')
      return a;
    if (a === '""')
      return b;
    if (typeof a == "string") {
      if (b instanceof Name || a[a.length - 1] !== '"')
        return;
      if (typeof b != "string")
        return `${a.slice(0, -1)}${b}"`;
      if (b[0] === '"')
        return a.slice(0, -1) + b.slice(1);
      return;
    }
    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
      return `"${a}${b.slice(1)}`;
    return;
  }
  function strConcat(c1, c2) {
    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
  }
  exports$1.strConcat = strConcat;
  function interpolate(x) {
    return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
  }
  function stringify(x) {
    return new _Code(safeStringify(x));
  }
  exports$1.stringify = stringify;
  function safeStringify(x) {
    return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  exports$1.safeStringify = safeStringify;
  function getProperty(key2) {
    return typeof key2 == "string" && exports$1.IDENTIFIER.test(key2) ? new _Code(`.${key2}`) : _`[${key2}]`;
  }
  exports$1.getProperty = getProperty;
  function getEsmExportName(key2) {
    if (typeof key2 == "string" && exports$1.IDENTIFIER.test(key2)) {
      return new _Code(`${key2}`);
    }
    throw new Error(`CodeGen: invalid export name: ${key2}, use explicit $id name mapping`);
  }
  exports$1.getEsmExportName = getEsmExportName;
  function regexpCode(rx) {
    return new _Code(rx.toString());
  }
  exports$1.regexpCode = regexpCode;
})(code$1);
var scope = {};
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.ValueScope = exports$1.ValueScopeName = exports$1.Scope = exports$1.varKinds = exports$1.UsedValueState = void 0;
  const code_12 = code$1;
  class ValueError extends Error {
    constructor(name) {
      super(`CodeGen: "code" for ${name} not defined`);
      this.value = name.value;
    }
  }
  var UsedValueState;
  (function(UsedValueState2) {
    UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
    UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
  })(UsedValueState || (exports$1.UsedValueState = UsedValueState = {}));
  exports$1.varKinds = {
    const: new code_12.Name("const"),
    let: new code_12.Name("let"),
    var: new code_12.Name("var")
  };
  class Scope {
    constructor({ prefixes, parent } = {}) {
      this._names = {};
      this._prefixes = prefixes;
      this._parent = parent;
    }
    toName(nameOrPrefix) {
      return nameOrPrefix instanceof code_12.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix) {
      return new code_12.Name(this._newName(prefix));
    }
    _newName(prefix) {
      const ng = this._names[prefix] || this._nameGroup(prefix);
      return `${prefix}${ng.index++}`;
    }
    _nameGroup(prefix) {
      var _a, _b;
      if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
        throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
      }
      return this._names[prefix] = { prefix, index: 0 };
    }
  }
  exports$1.Scope = Scope;
  class ValueScopeName extends code_12.Name {
    constructor(prefix, nameStr) {
      super(nameStr);
      this.prefix = prefix;
    }
    setValue(value, { property, itemIndex }) {
      this.value = value;
      this.scopePath = (0, code_12._)`.${new code_12.Name(property)}[${itemIndex}]`;
    }
  }
  exports$1.ValueScopeName = ValueScopeName;
  const line = (0, code_12._)`\n`;
  class ValueScope extends Scope {
    constructor(opts) {
      super(opts);
      this._values = {};
      this._scope = opts.scope;
      this.opts = { ...opts, _n: opts.lines ? line : code_12.nil };
    }
    get() {
      return this._scope;
    }
    name(prefix) {
      return new ValueScopeName(prefix, this._newName(prefix));
    }
    value(nameOrPrefix, value) {
      var _a;
      if (value.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const name = this.toName(nameOrPrefix);
      const { prefix } = name;
      const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
      let vs = this._values[prefix];
      if (vs) {
        const _name = vs.get(valueKey);
        if (_name)
          return _name;
      } else {
        vs = this._values[prefix] = /* @__PURE__ */ new Map();
      }
      vs.set(valueKey, name);
      const s = this._scope[prefix] || (this._scope[prefix] = []);
      const itemIndex = s.length;
      s[itemIndex] = value.ref;
      name.setValue(value, { property: prefix, itemIndex });
      return name;
    }
    getValue(prefix, keyOrRef) {
      const vs = this._values[prefix];
      if (!vs)
        return;
      return vs.get(keyOrRef);
    }
    scopeRefs(scopeName, values = this._values) {
      return this._reduceValues(values, (name) => {
        if (name.scopePath === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return (0, code_12._)`${scopeName}${name.scopePath}`;
      });
    }
    scopeCode(values = this._values, usedValues, getCode) {
      return this._reduceValues(values, (name) => {
        if (name.value === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return name.value.code;
      }, usedValues, getCode);
    }
    _reduceValues(values, valueCode, usedValues = {}, getCode) {
      let code2 = code_12.nil;
      for (const prefix in values) {
        const vs = values[prefix];
        if (!vs)
          continue;
        const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
        vs.forEach((name) => {
          if (nameSet.has(name))
            return;
          nameSet.set(name, UsedValueState.Started);
          let c = valueCode(name);
          if (c) {
            const def2 = this.opts.es5 ? exports$1.varKinds.var : exports$1.varKinds.const;
            code2 = (0, code_12._)`${code2}${def2} ${name} = ${c};${this.opts._n}`;
          } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
            code2 = (0, code_12._)`${code2}${c}${this.opts._n}`;
          } else {
            throw new ValueError(name);
          }
          nameSet.set(name, UsedValueState.Completed);
        });
      }
      return code2;
    }
  }
  exports$1.ValueScope = ValueScope;
})(scope);
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.or = exports$1.and = exports$1.not = exports$1.CodeGen = exports$1.operators = exports$1.varKinds = exports$1.ValueScopeName = exports$1.ValueScope = exports$1.Scope = exports$1.Name = exports$1.regexpCode = exports$1.stringify = exports$1.getProperty = exports$1.nil = exports$1.strConcat = exports$1.str = exports$1._ = void 0;
  const code_12 = code$1;
  const scope_1 = scope;
  var code_2 = code$1;
  Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
    return code_2._;
  } });
  Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
    return code_2.str;
  } });
  Object.defineProperty(exports$1, "strConcat", { enumerable: true, get: function() {
    return code_2.strConcat;
  } });
  Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
    return code_2.nil;
  } });
  Object.defineProperty(exports$1, "getProperty", { enumerable: true, get: function() {
    return code_2.getProperty;
  } });
  Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
    return code_2.stringify;
  } });
  Object.defineProperty(exports$1, "regexpCode", { enumerable: true, get: function() {
    return code_2.regexpCode;
  } });
  Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
    return code_2.Name;
  } });
  var scope_2 = scope;
  Object.defineProperty(exports$1, "Scope", { enumerable: true, get: function() {
    return scope_2.Scope;
  } });
  Object.defineProperty(exports$1, "ValueScope", { enumerable: true, get: function() {
    return scope_2.ValueScope;
  } });
  Object.defineProperty(exports$1, "ValueScopeName", { enumerable: true, get: function() {
    return scope_2.ValueScopeName;
  } });
  Object.defineProperty(exports$1, "varKinds", { enumerable: true, get: function() {
    return scope_2.varKinds;
  } });
  exports$1.operators = {
    GT: new code_12._Code(">"),
    GTE: new code_12._Code(">="),
    LT: new code_12._Code("<"),
    LTE: new code_12._Code("<="),
    EQ: new code_12._Code("==="),
    NEQ: new code_12._Code("!=="),
    NOT: new code_12._Code("!"),
    OR: new code_12._Code("||"),
    AND: new code_12._Code("&&"),
    ADD: new code_12._Code("+")
  };
  class Node {
    optimizeNodes() {
      return this;
    }
    optimizeNames(_names, _constants) {
      return this;
    }
  }
  class Def extends Node {
    constructor(varKind, name, rhs) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.rhs = rhs;
    }
    render({ es5, _n }) {
      const varKind = es5 ? scope_1.varKinds.var : this.varKind;
      const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${varKind} ${this.name}${rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (!names2[this.name.str])
        return;
      if (this.rhs)
        this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      return this.rhs instanceof code_12._CodeOrName ? this.rhs.names : {};
    }
  }
  class Assign extends Node {
    constructor(lhs, rhs, sideEffects) {
      super();
      this.lhs = lhs;
      this.rhs = rhs;
      this.sideEffects = sideEffects;
    }
    render({ _n }) {
      return `${this.lhs} = ${this.rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (this.lhs instanceof code_12.Name && !names2[this.lhs.str] && !this.sideEffects)
        return;
      this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      const names2 = this.lhs instanceof code_12.Name ? {} : { ...this.lhs.names };
      return addExprNames(names2, this.rhs);
    }
  }
  class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
      super(lhs, rhs, sideEffects);
      this.op = op;
    }
    render({ _n }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
    }
  }
  class Label extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      return `${this.label}:` + _n;
    }
  }
  class Break extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      const label = this.label ? ` ${this.label}` : "";
      return `break${label};` + _n;
    }
  }
  class Throw extends Node {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render({ _n }) {
      return `throw ${this.error};` + _n;
    }
    get names() {
      return this.error.names;
    }
  }
  class AnyCode extends Node {
    constructor(code2) {
      super();
      this.code = code2;
    }
    render({ _n }) {
      return `${this.code};` + _n;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      this.code = optimizeExpr(this.code, names2, constants2);
      return this;
    }
    get names() {
      return this.code instanceof code_12._CodeOrName ? this.code.names : {};
    }
  }
  class ParentNode extends Node {
    constructor(nodes = []) {
      super();
      this.nodes = nodes;
    }
    render(opts) {
      return this.nodes.reduce((code2, n) => code2 + n.render(opts), "");
    }
    optimizeNodes() {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i].optimizeNodes();
        if (Array.isArray(n))
          nodes.splice(i, 1, ...n);
        else if (n)
          nodes[i] = n;
        else
          nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i];
        if (n.optimizeNames(names2, constants2))
          continue;
        subtractNames(names2, n.names);
        nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((names2, n) => addNames(names2, n.names), {});
    }
  }
  class BlockNode extends ParentNode {
    render(opts) {
      return "{" + opts._n + super.render(opts) + "}" + opts._n;
    }
  }
  class Root extends ParentNode {
  }
  class Else extends BlockNode {
  }
  Else.kind = "else";
  class If extends BlockNode {
    constructor(condition, nodes) {
      super(nodes);
      this.condition = condition;
    }
    render(opts) {
      let code2 = `if(${this.condition})` + super.render(opts);
      if (this.else)
        code2 += "else " + this.else.render(opts);
      return code2;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const cond = this.condition;
      if (cond === true)
        return this.nodes;
      let e = this.else;
      if (e) {
        const ns = e.optimizeNodes();
        e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
      }
      if (e) {
        if (cond === false)
          return e instanceof If ? e : e.nodes;
        if (this.nodes.length)
          return this;
        return new If(not2(cond), e instanceof If ? [e] : e.nodes);
      }
      if (cond === false || !this.nodes.length)
        return void 0;
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a;
      this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants2);
      if (!(super.optimizeNames(names2, constants2) || this.else))
        return;
      this.condition = optimizeExpr(this.condition, names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      addExprNames(names2, this.condition);
      if (this.else)
        addNames(names2, this.else.names);
      return names2;
    }
  }
  If.kind = "if";
  class For extends BlockNode {
  }
  For.kind = "for";
  class ForLoop extends For {
    constructor(iteration) {
      super();
      this.iteration = iteration;
    }
    render(opts) {
      return `for(${this.iteration})` + super.render(opts);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iteration = optimizeExpr(this.iteration, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iteration.names);
    }
  }
  class ForRange extends For {
    constructor(varKind, name, from, to) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.from = from;
      this.to = to;
    }
    render(opts) {
      const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
      const { name, from, to } = this;
      return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
    }
    get names() {
      const names2 = addExprNames(super.names, this.from);
      return addExprNames(names2, this.to);
    }
  }
  class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
      super();
      this.loop = loop;
      this.varKind = varKind;
      this.name = name;
      this.iterable = iterable;
    }
    render(opts) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iterable = optimizeExpr(this.iterable, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iterable.names);
    }
  }
  class Func extends BlockNode {
    constructor(name, args, async) {
      super();
      this.name = name;
      this.args = args;
      this.async = async;
    }
    render(opts) {
      const _async = this.async ? "async " : "";
      return `${_async}function ${this.name}(${this.args})` + super.render(opts);
    }
  }
  Func.kind = "func";
  class Return extends ParentNode {
    render(opts) {
      return "return " + super.render(opts);
    }
  }
  Return.kind = "return";
  class Try extends BlockNode {
    render(opts) {
      let code2 = "try" + super.render(opts);
      if (this.catch)
        code2 += this.catch.render(opts);
      if (this.finally)
        code2 += this.finally.render(opts);
      return code2;
    }
    optimizeNodes() {
      var _a, _b;
      super.optimizeNodes();
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a, _b;
      super.optimizeNames(names2, constants2);
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants2);
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      if (this.catch)
        addNames(names2, this.catch.names);
      if (this.finally)
        addNames(names2, this.finally.names);
      return names2;
    }
  }
  class Catch extends BlockNode {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render(opts) {
      return `catch(${this.error})` + super.render(opts);
    }
  }
  Catch.kind = "catch";
  class Finally extends BlockNode {
    render(opts) {
      return "finally" + super.render(opts);
    }
  }
  Finally.kind = "finally";
  class CodeGen {
    constructor(extScope, opts = {}) {
      this._values = {};
      this._blockStarts = [];
      this._constants = {};
      this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
      this._extScope = extScope;
      this._scope = new scope_1.Scope({ parent: extScope });
      this._nodes = [new Root()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(prefix) {
      return this._scope.name(prefix);
    }
    // reserves unique name in the external scope
    scopeName(prefix) {
      return this._extScope.name(prefix);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(prefixOrName, value) {
      const name = this._extScope.value(prefixOrName, value);
      const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
      vs.add(name);
      return name;
    }
    getScopeValue(prefix, keyOrRef) {
      return this._extScope.getValue(prefix, keyOrRef);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(scopeName) {
      return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant) {
      const name = this._scope.toName(nameOrPrefix);
      if (rhs !== void 0 && constant)
        this._constants[name.str] = rhs;
      this._leafNode(new Def(varKind, name, rhs));
      return name;
    }
    // `const` declaration (`var` in es5 mode)
    const(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    // `var` declaration with optional assignment
    var(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    // assignment code
    assign(lhs, rhs, sideEffects) {
      return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    // `+=` code
    add(lhs, rhs) {
      return this._leafNode(new AssignOp(lhs, exports$1.operators.ADD, rhs));
    }
    // appends passed SafeExpr to code or executes Block
    code(c) {
      if (typeof c == "function")
        c();
      else if (c !== code_12.nil)
        this._leafNode(new AnyCode(c));
      return this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...keyValues) {
      const code2 = ["{"];
      for (const [key2, value] of keyValues) {
        if (code2.length > 1)
          code2.push(",");
        code2.push(key2);
        if (key2 !== value || this.opts.es5) {
          code2.push(":");
          (0, code_12.addCodeArg)(code2, value);
        }
      }
      code2.push("}");
      return new code_12._Code(code2);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(condition, thenBody, elseBody) {
      this._blockNode(new If(condition));
      if (thenBody && elseBody) {
        this.code(thenBody).else().code(elseBody).endIf();
      } else if (thenBody) {
        this.code(thenBody).endIf();
      } else if (elseBody) {
        throw new Error('CodeGen: "else" body without "then" body');
      }
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(condition) {
      return this._elseNode(new If(condition));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new Else());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(If, Else);
    }
    _for(node, forBody) {
      this._blockNode(node);
      if (forBody)
        this.code(forBody).endFor();
      return this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(iteration, forBody) {
      return this._for(new ForLoop(iteration), forBody);
    }
    // `for` statement for a range of values
    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
      const name = this._scope.toName(nameOrPrefix);
      if (this.opts.es5) {
        const arr = iterable instanceof code_12.Name ? iterable : this.var("_arr", iterable);
        return this.forRange("_i", 0, (0, code_12._)`${arr}.length`, (i) => {
          this.var(name, (0, code_12._)`${arr}[${i}]`);
          forBody(name);
        });
      }
      return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
      if (this.opts.ownProperties) {
        return this.forOf(nameOrPrefix, (0, code_12._)`Object.keys(${obj})`, forBody);
      }
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(For);
    }
    // `label` statement
    label(label) {
      return this._leafNode(new Label(label));
    }
    // `break` statement
    break(label) {
      return this._leafNode(new Break(label));
    }
    // `return` statement
    return(value) {
      const node = new Return();
      this._blockNode(node);
      this.code(value);
      if (node.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(Return);
    }
    // `try` statement
    try(tryBody, catchCode, finallyCode) {
      if (!catchCode && !finallyCode)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const node = new Try();
      this._blockNode(node);
      this.code(tryBody);
      if (catchCode) {
        const error2 = this.name("e");
        this._currNode = node.catch = new Catch(error2);
        catchCode(error2);
      }
      if (finallyCode) {
        this._currNode = node.finally = new Finally();
        this.code(finallyCode);
      }
      return this._endBlockNode(Catch, Finally);
    }
    // `throw` statement
    throw(error2) {
      return this._leafNode(new Throw(error2));
    }
    // start self-balancing block
    block(body, nodeCount) {
      this._blockStarts.push(this._nodes.length);
      if (body)
        this.code(body).endBlock(nodeCount);
      return this;
    }
    // end the current self-balancing block
    endBlock(nodeCount) {
      const len = this._blockStarts.pop();
      if (len === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const toClose = this._nodes.length - len;
      if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
        throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
      }
      this._nodes.length = len;
      return this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(name, args = code_12.nil, async, funcBody) {
      this._blockNode(new Func(name, args, async));
      if (funcBody)
        this.code(funcBody).endFunc();
      return this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(Func);
    }
    optimize(n = 1) {
      while (n-- > 0) {
        this._root.optimizeNodes();
        this._root.optimizeNames(this._root.names, this._constants);
      }
    }
    _leafNode(node) {
      this._currNode.nodes.push(node);
      return this;
    }
    _blockNode(node) {
      this._currNode.nodes.push(node);
      this._nodes.push(node);
    }
    _endBlockNode(N1, N2) {
      const n = this._currNode;
      if (n instanceof N1 || N2 && n instanceof N2) {
        this._nodes.pop();
        return this;
      }
      throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
    }
    _elseNode(node) {
      const n = this._currNode;
      if (!(n instanceof If)) {
        throw new Error('CodeGen: "else" without "if"');
      }
      this._currNode = n.else = node;
      return this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const ns = this._nodes;
      return ns[ns.length - 1];
    }
    set _currNode(node) {
      const ns = this._nodes;
      ns[ns.length - 1] = node;
    }
  }
  exports$1.CodeGen = CodeGen;
  function addNames(names2, from) {
    for (const n in from)
      names2[n] = (names2[n] || 0) + (from[n] || 0);
    return names2;
  }
  function addExprNames(names2, from) {
    return from instanceof code_12._CodeOrName ? addNames(names2, from.names) : names2;
  }
  function optimizeExpr(expr, names2, constants2) {
    if (expr instanceof code_12.Name)
      return replaceName(expr);
    if (!canOptimize(expr))
      return expr;
    return new code_12._Code(expr._items.reduce((items2, c) => {
      if (c instanceof code_12.Name)
        c = replaceName(c);
      if (c instanceof code_12._Code)
        items2.push(...c._items);
      else
        items2.push(c);
      return items2;
    }, []));
    function replaceName(n) {
      const c = constants2[n.str];
      if (c === void 0 || names2[n.str] !== 1)
        return n;
      delete names2[n.str];
      return c;
    }
    function canOptimize(e) {
      return e instanceof code_12._Code && e._items.some((c) => c instanceof code_12.Name && names2[c.str] === 1 && constants2[c.str] !== void 0);
    }
  }
  function subtractNames(names2, from) {
    for (const n in from)
      names2[n] = (names2[n] || 0) - (from[n] || 0);
  }
  function not2(x) {
    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_12._)`!${par(x)}`;
  }
  exports$1.not = not2;
  const andCode = mappend(exports$1.operators.AND);
  function and(...args) {
    return args.reduce(andCode);
  }
  exports$1.and = and;
  const orCode = mappend(exports$1.operators.OR);
  function or(...args) {
    return args.reduce(orCode);
  }
  exports$1.or = or;
  function mappend(op) {
    return (x, y) => x === code_12.nil ? y : y === code_12.nil ? x : (0, code_12._)`${par(x)} ${op} ${par(y)}`;
  }
  function par(x) {
    return x instanceof code_12.Name ? x : (0, code_12._)`(${x})`;
  }
})(codegen);
var util = {};
Object.defineProperty(util, "__esModule", { value: true });
util.checkStrictMode = util.getErrorPath = util.Type = util.useFunc = util.setEvaluated = util.evaluatedPropsToName = util.mergeEvaluated = util.eachItem = util.unescapeJsonPointer = util.escapeJsonPointer = util.escapeFragment = util.unescapeFragment = util.schemaRefOrVal = util.schemaHasRulesButRef = util.schemaHasRules = util.checkUnknownRules = util.alwaysValidSchema = util.toHash = void 0;
const codegen_1$v = codegen;
const code_1$a = code$1;
function toHash(arr) {
  const hash = {};
  for (const item of arr)
    hash[item] = true;
  return hash;
}
util.toHash = toHash;
function alwaysValidSchema(it, schema) {
  if (typeof schema == "boolean")
    return schema;
  if (Object.keys(schema).length === 0)
    return true;
  checkUnknownRules(it, schema);
  return !schemaHasRules(schema, it.self.RULES.all);
}
util.alwaysValidSchema = alwaysValidSchema;
function checkUnknownRules(it, schema = it.schema) {
  const { opts, self: self2 } = it;
  if (!opts.strictSchema)
    return;
  if (typeof schema === "boolean")
    return;
  const rules2 = self2.RULES.keywords;
  for (const key2 in schema) {
    if (!rules2[key2])
      checkStrictMode(it, `unknown keyword: "${key2}"`);
  }
}
util.checkUnknownRules = checkUnknownRules;
function schemaHasRules(schema, rules2) {
  if (typeof schema == "boolean")
    return !schema;
  for (const key2 in schema)
    if (rules2[key2])
      return true;
  return false;
}
util.schemaHasRules = schemaHasRules;
function schemaHasRulesButRef(schema, RULES) {
  if (typeof schema == "boolean")
    return !schema;
  for (const key2 in schema)
    if (key2 !== "$ref" && RULES.all[key2])
      return true;
  return false;
}
util.schemaHasRulesButRef = schemaHasRulesButRef;
function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword2, $data) {
  if (!$data) {
    if (typeof schema == "number" || typeof schema == "boolean")
      return schema;
    if (typeof schema == "string")
      return (0, codegen_1$v._)`${schema}`;
  }
  return (0, codegen_1$v._)`${topSchemaRef}${schemaPath}${(0, codegen_1$v.getProperty)(keyword2)}`;
}
util.schemaRefOrVal = schemaRefOrVal;
function unescapeFragment(str) {
  return unescapeJsonPointer(decodeURIComponent(str));
}
util.unescapeFragment = unescapeFragment;
function escapeFragment(str) {
  return encodeURIComponent(escapeJsonPointer(str));
}
util.escapeFragment = escapeFragment;
function escapeJsonPointer(str) {
  if (typeof str == "number")
    return `${str}`;
  return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
util.escapeJsonPointer = escapeJsonPointer;
function unescapeJsonPointer(str) {
  return str.replace(/~1/g, "/").replace(/~0/g, "~");
}
util.unescapeJsonPointer = unescapeJsonPointer;
function eachItem(xs, f) {
  if (Array.isArray(xs)) {
    for (const x of xs)
      f(x);
  } else {
    f(xs);
  }
}
util.eachItem = eachItem;
function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
  return (gen, from, to, toName) => {
    const res = to === void 0 ? from : to instanceof codegen_1$v.Name ? (from instanceof codegen_1$v.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1$v.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
    return toName === codegen_1$v.Name && !(res instanceof codegen_1$v.Name) ? resultToName(gen, res) : res;
  };
}
util.mergeEvaluated = {
  props: makeMergeEvaluated({
    mergeNames: (gen, from, to) => gen.if((0, codegen_1$v._)`${to} !== true && ${from} !== undefined`, () => {
      gen.if((0, codegen_1$v._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1$v._)`${to} || {}`).code((0, codegen_1$v._)`Object.assign(${to}, ${from})`));
    }),
    mergeToName: (gen, from, to) => gen.if((0, codegen_1$v._)`${to} !== true`, () => {
      if (from === true) {
        gen.assign(to, true);
      } else {
        gen.assign(to, (0, codegen_1$v._)`${to} || {}`);
        setEvaluated(gen, to, from);
      }
    }),
    mergeValues: (from, to) => from === true ? true : { ...from, ...to },
    resultToName: evaluatedPropsToName
  }),
  items: makeMergeEvaluated({
    mergeNames: (gen, from, to) => gen.if((0, codegen_1$v._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1$v._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
    mergeToName: (gen, from, to) => gen.if((0, codegen_1$v._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1$v._)`${to} > ${from} ? ${to} : ${from}`)),
    mergeValues: (from, to) => from === true ? true : Math.max(from, to),
    resultToName: (gen, items2) => gen.var("items", items2)
  })
};
function evaluatedPropsToName(gen, ps) {
  if (ps === true)
    return gen.var("props", true);
  const props = gen.var("props", (0, codegen_1$v._)`{}`);
  if (ps !== void 0)
    setEvaluated(gen, props, ps);
  return props;
}
util.evaluatedPropsToName = evaluatedPropsToName;
function setEvaluated(gen, props, ps) {
  Object.keys(ps).forEach((p) => gen.assign((0, codegen_1$v._)`${props}${(0, codegen_1$v.getProperty)(p)}`, true));
}
util.setEvaluated = setEvaluated;
const snippets = {};
function useFunc(gen, f) {
  return gen.scopeValue("func", {
    ref: f,
    code: snippets[f.code] || (snippets[f.code] = new code_1$a._Code(f.code))
  });
}
util.useFunc = useFunc;
var Type;
(function(Type2) {
  Type2[Type2["Num"] = 0] = "Num";
  Type2[Type2["Str"] = 1] = "Str";
})(Type || (util.Type = Type = {}));
function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
  if (dataProp instanceof codegen_1$v.Name) {
    const isNumber = dataPropType === Type.Num;
    return jsPropertySyntax ? isNumber ? (0, codegen_1$v._)`"[" + ${dataProp} + "]"` : (0, codegen_1$v._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1$v._)`"/" + ${dataProp}` : (0, codegen_1$v._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
  }
  return jsPropertySyntax ? (0, codegen_1$v.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
}
util.getErrorPath = getErrorPath;
function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
  if (!mode)
    return;
  msg = `strict mode: ${msg}`;
  if (mode === true)
    throw new Error(msg);
  it.self.logger.warn(msg);
}
util.checkStrictMode = checkStrictMode;
var names$1 = {};
Object.defineProperty(names$1, "__esModule", { value: true });
const codegen_1$u = codegen;
const names = {
  // validation function arguments
  data: new codegen_1$u.Name("data"),
  // data passed to validation function
  // args passed from referencing schema
  valCxt: new codegen_1$u.Name("valCxt"),
  // validation/data context - should not be used directly, it is destructured to the names below
  instancePath: new codegen_1$u.Name("instancePath"),
  parentData: new codegen_1$u.Name("parentData"),
  parentDataProperty: new codegen_1$u.Name("parentDataProperty"),
  rootData: new codegen_1$u.Name("rootData"),
  // root data - same as the data passed to the first/top validation function
  dynamicAnchors: new codegen_1$u.Name("dynamicAnchors"),
  // used to support recursiveRef and dynamicRef
  // function scoped variables
  vErrors: new codegen_1$u.Name("vErrors"),
  // null or array of validation errors
  errors: new codegen_1$u.Name("errors"),
  // counter of validation errors
  this: new codegen_1$u.Name("this"),
  // "globals"
  self: new codegen_1$u.Name("self"),
  scope: new codegen_1$u.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new codegen_1$u.Name("json"),
  jsonPos: new codegen_1$u.Name("jsonPos"),
  jsonLen: new codegen_1$u.Name("jsonLen"),
  jsonPart: new codegen_1$u.Name("jsonPart")
};
names$1.default = names;
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.extendErrors = exports$1.resetErrorsCount = exports$1.reportExtraError = exports$1.reportError = exports$1.keyword$DataError = exports$1.keywordError = void 0;
  const codegen_12 = codegen;
  const util_12 = util;
  const names_12 = names$1;
  exports$1.keywordError = {
    message: ({ keyword: keyword2 }) => (0, codegen_12.str)`must pass "${keyword2}" keyword validation`
  };
  exports$1.keyword$DataError = {
    message: ({ keyword: keyword2, schemaType }) => schemaType ? (0, codegen_12.str)`"${keyword2}" keyword must be ${schemaType} ($data)` : (0, codegen_12.str)`"${keyword2}" keyword is invalid ($data)`
  };
  function reportError(cxt, error2 = exports$1.keywordError, errorPaths, overrideAllErrors) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
      addError(gen, errObj);
    } else {
      returnErrors(it, (0, codegen_12._)`[${errObj}]`);
    }
  }
  exports$1.reportError = reportError;
  function reportExtraError(cxt, error2 = exports$1.keywordError, errorPaths) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
      returnErrors(it, names_12.default.vErrors);
    }
  }
  exports$1.reportExtraError = reportExtraError;
  function resetErrorsCount(gen, errsCount) {
    gen.assign(names_12.default.errors, errsCount);
    gen.if((0, codegen_12._)`${names_12.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_12._)`${names_12.default.vErrors}.length`, errsCount), () => gen.assign(names_12.default.vErrors, null)));
  }
  exports$1.resetErrorsCount = resetErrorsCount;
  function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it }) {
    if (errsCount === void 0)
      throw new Error("ajv implementation error");
    const err = gen.name("err");
    gen.forRange("i", errsCount, names_12.default.errors, (i) => {
      gen.const(err, (0, codegen_12._)`${names_12.default.vErrors}[${i}]`);
      gen.if((0, codegen_12._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_12._)`${err}.instancePath`, (0, codegen_12.strConcat)(names_12.default.instancePath, it.errorPath)));
      gen.assign((0, codegen_12._)`${err}.schemaPath`, (0, codegen_12.str)`${it.errSchemaPath}/${keyword2}`);
      if (it.opts.verbose) {
        gen.assign((0, codegen_12._)`${err}.schema`, schemaValue);
        gen.assign((0, codegen_12._)`${err}.data`, data);
      }
    });
  }
  exports$1.extendErrors = extendErrors;
  function addError(gen, errObj) {
    const err = gen.const("err", errObj);
    gen.if((0, codegen_12._)`${names_12.default.vErrors} === null`, () => gen.assign(names_12.default.vErrors, (0, codegen_12._)`[${err}]`), (0, codegen_12._)`${names_12.default.vErrors}.push(${err})`);
    gen.code((0, codegen_12._)`${names_12.default.errors}++`);
  }
  function returnErrors(it, errs) {
    const { gen, validateName, schemaEnv } = it;
    if (schemaEnv.$async) {
      gen.throw((0, codegen_12._)`new ${it.ValidationError}(${errs})`);
    } else {
      gen.assign((0, codegen_12._)`${validateName}.errors`, errs);
      gen.return(false);
    }
  }
  const E = {
    keyword: new codegen_12.Name("keyword"),
    schemaPath: new codegen_12.Name("schemaPath"),
    // also used in JTD errors
    params: new codegen_12.Name("params"),
    propertyName: new codegen_12.Name("propertyName"),
    message: new codegen_12.Name("message"),
    schema: new codegen_12.Name("schema"),
    parentSchema: new codegen_12.Name("parentSchema")
  };
  function errorObjectCode(cxt, error2, errorPaths) {
    const { createErrors } = cxt.it;
    if (createErrors === false)
      return (0, codegen_12._)`{}`;
    return errorObject(cxt, error2, errorPaths);
  }
  function errorObject(cxt, error2, errorPaths = {}) {
    const { gen, it } = cxt;
    const keyValues = [
      errorInstancePath(it, errorPaths),
      errorSchemaPath(cxt, errorPaths)
    ];
    extraErrorProps(cxt, error2, keyValues);
    return gen.object(...keyValues);
  }
  function errorInstancePath({ errorPath }, { instancePath }) {
    const instPath = instancePath ? (0, codegen_12.str)`${errorPath}${(0, util_12.getErrorPath)(instancePath, util_12.Type.Str)}` : errorPath;
    return [names_12.default.instancePath, (0, codegen_12.strConcat)(names_12.default.instancePath, instPath)];
  }
  function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
    let schPath = parentSchema ? errSchemaPath : (0, codegen_12.str)`${errSchemaPath}/${keyword2}`;
    if (schemaPath) {
      schPath = (0, codegen_12.str)`${schPath}${(0, util_12.getErrorPath)(schemaPath, util_12.Type.Str)}`;
    }
    return [E.schemaPath, schPath];
  }
  function extraErrorProps(cxt, { params, message }, keyValues) {
    const { keyword: keyword2, data, schemaValue, it } = cxt;
    const { opts, propertyName, topSchemaRef, schemaPath } = it;
    keyValues.push([E.keyword, keyword2], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_12._)`{}`]);
    if (opts.messages) {
      keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts.verbose) {
      keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_12._)`${topSchemaRef}${schemaPath}`], [names_12.default.data, data]);
    }
    if (propertyName)
      keyValues.push([E.propertyName, propertyName]);
  }
})(errors$3);
Object.defineProperty(boolSchema, "__esModule", { value: true });
boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
const errors_1$3 = errors$3;
const codegen_1$t = codegen;
const names_1$6 = names$1;
const boolError = {
  message: "boolean schema is false"
};
function topBoolOrEmptySchema(it) {
  const { gen, schema, validateName } = it;
  if (schema === false) {
    falseSchemaError(it, false);
  } else if (typeof schema == "object" && schema.$async === true) {
    gen.return(names_1$6.default.data);
  } else {
    gen.assign((0, codegen_1$t._)`${validateName}.errors`, null);
    gen.return(true);
  }
}
boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
function boolOrEmptySchema(it, valid2) {
  const { gen, schema } = it;
  if (schema === false) {
    gen.var(valid2, false);
    falseSchemaError(it);
  } else {
    gen.var(valid2, true);
  }
}
boolSchema.boolOrEmptySchema = boolOrEmptySchema;
function falseSchemaError(it, overrideAllErrors) {
  const { gen, data } = it;
  const cxt = {
    gen,
    keyword: "false schema",
    data,
    schema: false,
    schemaCode: false,
    schemaValue: false,
    params: {},
    it
  };
  (0, errors_1$3.reportError)(cxt, boolError, void 0, overrideAllErrors);
}
var dataType = {};
var rules = {};
Object.defineProperty(rules, "__esModule", { value: true });
rules.getRules = rules.isJSONType = void 0;
const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
const jsonTypes = new Set(_jsonTypes);
function isJSONType(x) {
  return typeof x == "string" && jsonTypes.has(x);
}
rules.isJSONType = isJSONType;
function getRules() {
  const groups = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...groups, integer: true, boolean: true, null: true },
    rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
rules.getRules = getRules;
var applicability = {};
Object.defineProperty(applicability, "__esModule", { value: true });
applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
function schemaHasRulesForType({ schema, self: self2 }, type2) {
  const group = self2.RULES.types[type2];
  return group && group !== true && shouldUseGroup(schema, group);
}
applicability.schemaHasRulesForType = schemaHasRulesForType;
function shouldUseGroup(schema, group) {
  return group.rules.some((rule) => shouldUseRule(schema, rule));
}
applicability.shouldUseGroup = shouldUseGroup;
function shouldUseRule(schema, rule) {
  var _a;
  return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
}
applicability.shouldUseRule = shouldUseRule;
Object.defineProperty(dataType, "__esModule", { value: true });
dataType.reportTypeError = dataType.checkDataTypes = dataType.checkDataType = dataType.coerceAndCheckDataType = dataType.getJSONTypes = dataType.getSchemaTypes = dataType.DataType = void 0;
const rules_1 = rules;
const applicability_1$1 = applicability;
const errors_1$2 = errors$3;
const codegen_1$s = codegen;
const util_1$q = util;
var DataType;
(function(DataType2) {
  DataType2[DataType2["Correct"] = 0] = "Correct";
  DataType2[DataType2["Wrong"] = 1] = "Wrong";
})(DataType || (dataType.DataType = DataType = {}));
function getSchemaTypes(schema) {
  const types2 = getJSONTypes(schema.type);
  const hasNull = types2.includes("null");
  if (hasNull) {
    if (schema.nullable === false)
      throw new Error("type: null contradicts nullable: false");
  } else {
    if (!types2.length && schema.nullable !== void 0) {
      throw new Error('"nullable" cannot be used without "type"');
    }
    if (schema.nullable === true)
      types2.push("null");
  }
  return types2;
}
dataType.getSchemaTypes = getSchemaTypes;
function getJSONTypes(ts) {
  const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
  if (types2.every(rules_1.isJSONType))
    return types2;
  throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
}
dataType.getJSONTypes = getJSONTypes;
function coerceAndCheckDataType(it, types2) {
  const { gen, data, opts } = it;
  const coerceTo = coerceToTypes(types2, opts.coerceTypes);
  const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1$1.schemaHasRulesForType)(it, types2[0]));
  if (checkTypes) {
    const wrongType = checkDataTypes(types2, data, opts.strictNumbers, DataType.Wrong);
    gen.if(wrongType, () => {
      if (coerceTo.length)
        coerceData(it, types2, coerceTo);
      else
        reportTypeError(it);
    });
  }
  return checkTypes;
}
dataType.coerceAndCheckDataType = coerceAndCheckDataType;
const COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
function coerceToTypes(types2, coerceTypes) {
  return coerceTypes ? types2.filter((t2) => COERCIBLE.has(t2) || coerceTypes === "array" && t2 === "array") : [];
}
function coerceData(it, types2, coerceTo) {
  const { gen, data, opts } = it;
  const dataType2 = gen.let("dataType", (0, codegen_1$s._)`typeof ${data}`);
  const coerced = gen.let("coerced", (0, codegen_1$s._)`undefined`);
  if (opts.coerceTypes === "array") {
    gen.if((0, codegen_1$s._)`${dataType2} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1$s._)`${data}[0]`).assign(dataType2, (0, codegen_1$s._)`typeof ${data}`).if(checkDataTypes(types2, data, opts.strictNumbers), () => gen.assign(coerced, data)));
  }
  gen.if((0, codegen_1$s._)`${coerced} !== undefined`);
  for (const t2 of coerceTo) {
    if (COERCIBLE.has(t2) || t2 === "array" && opts.coerceTypes === "array") {
      coerceSpecificType(t2);
    }
  }
  gen.else();
  reportTypeError(it);
  gen.endIf();
  gen.if((0, codegen_1$s._)`${coerced} !== undefined`, () => {
    gen.assign(data, coerced);
    assignParentData(it, coerced);
  });
  function coerceSpecificType(t2) {
    switch (t2) {
      case "string":
        gen.elseIf((0, codegen_1$s._)`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, (0, codegen_1$s._)`"" + ${data}`).elseIf((0, codegen_1$s._)`${data} === null`).assign(coerced, (0, codegen_1$s._)`""`);
        return;
      case "number":
        gen.elseIf((0, codegen_1$s._)`${dataType2} == "boolean" || ${data} === null
              || (${dataType2} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1$s._)`+${data}`);
        return;
      case "integer":
        gen.elseIf((0, codegen_1$s._)`${dataType2} === "boolean" || ${data} === null
              || (${dataType2} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1$s._)`+${data}`);
        return;
      case "boolean":
        gen.elseIf((0, codegen_1$s._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1$s._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
        return;
      case "null":
        gen.elseIf((0, codegen_1$s._)`${data} === "" || ${data} === 0 || ${data} === false`);
        gen.assign(coerced, null);
        return;
      case "array":
        gen.elseIf((0, codegen_1$s._)`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1$s._)`[${data}]`);
    }
  }
}
function assignParentData({ gen, parentData, parentDataProperty }, expr) {
  gen.if((0, codegen_1$s._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1$s._)`${parentData}[${parentDataProperty}]`, expr));
}
function checkDataType(dataType2, data, strictNums, correct = DataType.Correct) {
  const EQ = correct === DataType.Correct ? codegen_1$s.operators.EQ : codegen_1$s.operators.NEQ;
  let cond;
  switch (dataType2) {
    case "null":
      return (0, codegen_1$s._)`${data} ${EQ} null`;
    case "array":
      cond = (0, codegen_1$s._)`Array.isArray(${data})`;
      break;
    case "object":
      cond = (0, codegen_1$s._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
      break;
    case "integer":
      cond = numCond((0, codegen_1$s._)`!(${data} % 1) && !isNaN(${data})`);
      break;
    case "number":
      cond = numCond();
      break;
    default:
      return (0, codegen_1$s._)`typeof ${data} ${EQ} ${dataType2}`;
  }
  return correct === DataType.Correct ? cond : (0, codegen_1$s.not)(cond);
  function numCond(_cond = codegen_1$s.nil) {
    return (0, codegen_1$s.and)((0, codegen_1$s._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1$s._)`isFinite(${data})` : codegen_1$s.nil);
  }
}
dataType.checkDataType = checkDataType;
function checkDataTypes(dataTypes, data, strictNums, correct) {
  if (dataTypes.length === 1) {
    return checkDataType(dataTypes[0], data, strictNums, correct);
  }
  let cond;
  const types2 = (0, util_1$q.toHash)(dataTypes);
  if (types2.array && types2.object) {
    const notObj = (0, codegen_1$s._)`typeof ${data} != "object"`;
    cond = types2.null ? notObj : (0, codegen_1$s._)`!${data} || ${notObj}`;
    delete types2.null;
    delete types2.array;
    delete types2.object;
  } else {
    cond = codegen_1$s.nil;
  }
  if (types2.number)
    delete types2.integer;
  for (const t2 in types2)
    cond = (0, codegen_1$s.and)(cond, checkDataType(t2, data, strictNums, correct));
  return cond;
}
dataType.checkDataTypes = checkDataTypes;
const typeError = {
  message: ({ schema }) => `must be ${schema}`,
  params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1$s._)`{type: ${schema}}` : (0, codegen_1$s._)`{type: ${schemaValue}}`
};
function reportTypeError(it) {
  const cxt = getTypeErrorContext(it);
  (0, errors_1$2.reportError)(cxt, typeError);
}
dataType.reportTypeError = reportTypeError;
function getTypeErrorContext(it) {
  const { gen, data, schema } = it;
  const schemaCode = (0, util_1$q.schemaRefOrVal)(it, schema, "type");
  return {
    gen,
    keyword: "type",
    data,
    schema: schema.type,
    schemaCode,
    schemaValue: schemaCode,
    parentSchema: schema,
    params: {},
    it
  };
}
var defaults = {};
Object.defineProperty(defaults, "__esModule", { value: true });
defaults.assignDefaults = void 0;
const codegen_1$r = codegen;
const util_1$p = util;
function assignDefaults(it, ty) {
  const { properties: properties2, items: items2 } = it.schema;
  if (ty === "object" && properties2) {
    for (const key2 in properties2) {
      assignDefault(it, key2, properties2[key2].default);
    }
  } else if (ty === "array" && Array.isArray(items2)) {
    items2.forEach((sch, i) => assignDefault(it, i, sch.default));
  }
}
defaults.assignDefaults = assignDefaults;
function assignDefault(it, prop, defaultValue) {
  const { gen, compositeRule, data, opts } = it;
  if (defaultValue === void 0)
    return;
  const childData = (0, codegen_1$r._)`${data}${(0, codegen_1$r.getProperty)(prop)}`;
  if (compositeRule) {
    (0, util_1$p.checkStrictMode)(it, `default is ignored for: ${childData}`);
    return;
  }
  let condition = (0, codegen_1$r._)`${childData} === undefined`;
  if (opts.useDefaults === "empty") {
    condition = (0, codegen_1$r._)`${condition} || ${childData} === null || ${childData} === ""`;
  }
  gen.if(condition, (0, codegen_1$r._)`${childData} = ${(0, codegen_1$r.stringify)(defaultValue)}`);
}
var keyword = {};
var code = {};
Object.defineProperty(code, "__esModule", { value: true });
code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
const codegen_1$q = codegen;
const util_1$o = util;
const names_1$5 = names$1;
const util_2$1 = util;
function checkReportMissingProp(cxt, prop) {
  const { gen, data, it } = cxt;
  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
    cxt.setParams({ missingProperty: (0, codegen_1$q._)`${prop}` }, true);
    cxt.error();
  });
}
code.checkReportMissingProp = checkReportMissingProp;
function checkMissingProp({ gen, data, it: { opts } }, properties2, missing) {
  return (0, codegen_1$q.or)(...properties2.map((prop) => (0, codegen_1$q.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1$q._)`${missing} = ${prop}`)));
}
code.checkMissingProp = checkMissingProp;
function reportMissingProp(cxt, missing) {
  cxt.setParams({ missingProperty: missing }, true);
  cxt.error();
}
code.reportMissingProp = reportMissingProp;
function hasPropFunc(gen) {
  return gen.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: (0, codegen_1$q._)`Object.prototype.hasOwnProperty`
  });
}
code.hasPropFunc = hasPropFunc;
function isOwnProperty(gen, data, property) {
  return (0, codegen_1$q._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
}
code.isOwnProperty = isOwnProperty;
function propertyInData(gen, data, property, ownProperties) {
  const cond = (0, codegen_1$q._)`${data}${(0, codegen_1$q.getProperty)(property)} !== undefined`;
  return ownProperties ? (0, codegen_1$q._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
}
code.propertyInData = propertyInData;
function noPropertyInData(gen, data, property, ownProperties) {
  const cond = (0, codegen_1$q._)`${data}${(0, codegen_1$q.getProperty)(property)} === undefined`;
  return ownProperties ? (0, codegen_1$q.or)(cond, (0, codegen_1$q.not)(isOwnProperty(gen, data, property))) : cond;
}
code.noPropertyInData = noPropertyInData;
function allSchemaProperties(schemaMap) {
  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
}
code.allSchemaProperties = allSchemaProperties;
function schemaProperties(it, schemaMap) {
  return allSchemaProperties(schemaMap).filter((p) => !(0, util_1$o.alwaysValidSchema)(it, schemaMap[p]));
}
code.schemaProperties = schemaProperties;
function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
  const dataAndSchema = passSchema ? (0, codegen_1$q._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
  const valCxt = [
    [names_1$5.default.instancePath, (0, codegen_1$q.strConcat)(names_1$5.default.instancePath, errorPath)],
    [names_1$5.default.parentData, it.parentData],
    [names_1$5.default.parentDataProperty, it.parentDataProperty],
    [names_1$5.default.rootData, names_1$5.default.rootData]
  ];
  if (it.opts.dynamicRef)
    valCxt.push([names_1$5.default.dynamicAnchors, names_1$5.default.dynamicAnchors]);
  const args = (0, codegen_1$q._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
  return context !== codegen_1$q.nil ? (0, codegen_1$q._)`${func}.call(${context}, ${args})` : (0, codegen_1$q._)`${func}(${args})`;
}
code.callValidateCode = callValidateCode;
const newRegExp = (0, codegen_1$q._)`new RegExp`;
function usePattern({ gen, it: { opts } }, pattern2) {
  const u = opts.unicodeRegExp ? "u" : "";
  const { regExp } = opts.code;
  const rx = regExp(pattern2, u);
  return gen.scopeValue("pattern", {
    key: rx.toString(),
    ref: rx,
    code: (0, codegen_1$q._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2$1.useFunc)(gen, regExp)}(${pattern2}, ${u})`
  });
}
code.usePattern = usePattern;
function validateArray(cxt) {
  const { gen, data, keyword: keyword2, it } = cxt;
  const valid2 = gen.name("valid");
  if (it.allErrors) {
    const validArr = gen.let("valid", true);
    validateItems(() => gen.assign(validArr, false));
    return validArr;
  }
  gen.var(valid2, true);
  validateItems(() => gen.break());
  return valid2;
  function validateItems(notValid) {
    const len = gen.const("len", (0, codegen_1$q._)`${data}.length`);
    gen.forRange("i", 0, len, (i) => {
      cxt.subschema({
        keyword: keyword2,
        dataProp: i,
        dataPropType: util_1$o.Type.Num
      }, valid2);
      gen.if((0, codegen_1$q.not)(valid2), notValid);
    });
  }
}
code.validateArray = validateArray;
function validateUnion(cxt) {
  const { gen, schema, keyword: keyword2, it } = cxt;
  if (!Array.isArray(schema))
    throw new Error("ajv implementation error");
  const alwaysValid = schema.some((sch) => (0, util_1$o.alwaysValidSchema)(it, sch));
  if (alwaysValid && !it.opts.unevaluated)
    return;
  const valid2 = gen.let("valid", false);
  const schValid = gen.name("_valid");
  gen.block(() => schema.forEach((_sch, i) => {
    const schCxt = cxt.subschema({
      keyword: keyword2,
      schemaProp: i,
      compositeRule: true
    }, schValid);
    gen.assign(valid2, (0, codegen_1$q._)`${valid2} || ${schValid}`);
    const merged = cxt.mergeValidEvaluated(schCxt, schValid);
    if (!merged)
      gen.if((0, codegen_1$q.not)(valid2));
  }));
  cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
}
code.validateUnion = validateUnion;
Object.defineProperty(keyword, "__esModule", { value: true });
keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
const codegen_1$p = codegen;
const names_1$4 = names$1;
const code_1$9 = code;
const errors_1$1 = errors$3;
function macroKeywordCode(cxt, def2) {
  const { gen, keyword: keyword2, schema, parentSchema, it } = cxt;
  const macroSchema = def2.macro.call(it.self, schema, parentSchema, it);
  const schemaRef = useKeyword(gen, keyword2, macroSchema);
  if (it.opts.validateSchema !== false)
    it.self.validateSchema(macroSchema, true);
  const valid2 = gen.name("valid");
  cxt.subschema({
    schema: macroSchema,
    schemaPath: codegen_1$p.nil,
    errSchemaPath: `${it.errSchemaPath}/${keyword2}`,
    topSchemaRef: schemaRef,
    compositeRule: true
  }, valid2);
  cxt.pass(valid2, () => cxt.error(true));
}
keyword.macroKeywordCode = macroKeywordCode;
function funcKeywordCode(cxt, def2) {
  var _a;
  const { gen, keyword: keyword2, schema, parentSchema, $data, it } = cxt;
  checkAsyncKeyword(it, def2);
  const validate2 = !$data && def2.compile ? def2.compile.call(it.self, schema, parentSchema, it) : def2.validate;
  const validateRef = useKeyword(gen, keyword2, validate2);
  const valid2 = gen.let("valid");
  cxt.block$data(valid2, validateKeyword);
  cxt.ok((_a = def2.valid) !== null && _a !== void 0 ? _a : valid2);
  function validateKeyword() {
    if (def2.errors === false) {
      assignValid();
      if (def2.modifying)
        modifyData(cxt);
      reportErrs(() => cxt.error());
    } else {
      const ruleErrs = def2.async ? validateAsync() : validateSync();
      if (def2.modifying)
        modifyData(cxt);
      reportErrs(() => addErrs(cxt, ruleErrs));
    }
  }
  function validateAsync() {
    const ruleErrs = gen.let("ruleErrs", null);
    gen.try(() => assignValid((0, codegen_1$p._)`await `), (e) => gen.assign(valid2, false).if((0, codegen_1$p._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1$p._)`${e}.errors`), () => gen.throw(e)));
    return ruleErrs;
  }
  function validateSync() {
    const validateErrs = (0, codegen_1$p._)`${validateRef}.errors`;
    gen.assign(validateErrs, null);
    assignValid(codegen_1$p.nil);
    return validateErrs;
  }
  function assignValid(_await = def2.async ? (0, codegen_1$p._)`await ` : codegen_1$p.nil) {
    const passCxt = it.opts.passContext ? names_1$4.default.this : names_1$4.default.self;
    const passSchema = !("compile" in def2 && !$data || def2.schema === false);
    gen.assign(valid2, (0, codegen_1$p._)`${_await}${(0, code_1$9.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def2.modifying);
  }
  function reportErrs(errors2) {
    var _a2;
    gen.if((0, codegen_1$p.not)((_a2 = def2.valid) !== null && _a2 !== void 0 ? _a2 : valid2), errors2);
  }
}
keyword.funcKeywordCode = funcKeywordCode;
function modifyData(cxt) {
  const { gen, data, it } = cxt;
  gen.if(it.parentData, () => gen.assign(data, (0, codegen_1$p._)`${it.parentData}[${it.parentDataProperty}]`));
}
function addErrs(cxt, errs) {
  const { gen } = cxt;
  gen.if((0, codegen_1$p._)`Array.isArray(${errs})`, () => {
    gen.assign(names_1$4.default.vErrors, (0, codegen_1$p._)`${names_1$4.default.vErrors} === null ? ${errs} : ${names_1$4.default.vErrors}.concat(${errs})`).assign(names_1$4.default.errors, (0, codegen_1$p._)`${names_1$4.default.vErrors}.length`);
    (0, errors_1$1.extendErrors)(cxt);
  }, () => cxt.error());
}
function checkAsyncKeyword({ schemaEnv }, def2) {
  if (def2.async && !schemaEnv.$async)
    throw new Error("async keyword in sync schema");
}
function useKeyword(gen, keyword2, result) {
  if (result === void 0)
    throw new Error(`keyword "${keyword2}" failed to compile`);
  return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1$p.stringify)(result) });
}
function validSchemaType(schema, schemaType, allowUndefined = false) {
  return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
}
keyword.validSchemaType = validSchemaType;
function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def2, keyword2) {
  if (Array.isArray(def2.keyword) ? !def2.keyword.includes(keyword2) : def2.keyword !== keyword2) {
    throw new Error("ajv implementation error");
  }
  const deps = def2.dependencies;
  if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
    throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
  }
  if (def2.validateSchema) {
    const valid2 = def2.validateSchema(schema[keyword2]);
    if (!valid2) {
      const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def2.validateSchema.errors);
      if (opts.validateSchema === "log")
        self2.logger.error(msg);
      else
        throw new Error(msg);
    }
  }
}
keyword.validateKeywordUsage = validateKeywordUsage;
var subschema = {};
Object.defineProperty(subschema, "__esModule", { value: true });
subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
const codegen_1$o = codegen;
const util_1$n = util;
function getSubschema(it, { keyword: keyword2, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
  if (keyword2 !== void 0 && schema !== void 0) {
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  }
  if (keyword2 !== void 0) {
    const sch = it.schema[keyword2];
    return schemaProp === void 0 ? {
      schema: sch,
      schemaPath: (0, codegen_1$o._)`${it.schemaPath}${(0, codegen_1$o.getProperty)(keyword2)}`,
      errSchemaPath: `${it.errSchemaPath}/${keyword2}`
    } : {
      schema: sch[schemaProp],
      schemaPath: (0, codegen_1$o._)`${it.schemaPath}${(0, codegen_1$o.getProperty)(keyword2)}${(0, codegen_1$o.getProperty)(schemaProp)}`,
      errSchemaPath: `${it.errSchemaPath}/${keyword2}/${(0, util_1$n.escapeFragment)(schemaProp)}`
    };
  }
  if (schema !== void 0) {
    if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    }
    return {
      schema,
      schemaPath,
      topSchemaRef,
      errSchemaPath
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
subschema.getSubschema = getSubschema;
function extendSubschemaData(subschema2, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
  if (data !== void 0 && dataProp !== void 0) {
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  }
  const { gen } = it;
  if (dataProp !== void 0) {
    const { errorPath, dataPathArr, opts } = it;
    const nextData = gen.let("data", (0, codegen_1$o._)`${it.data}${(0, codegen_1$o.getProperty)(dataProp)}`, true);
    dataContextProps(nextData);
    subschema2.errorPath = (0, codegen_1$o.str)`${errorPath}${(0, util_1$n.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
    subschema2.parentDataProperty = (0, codegen_1$o._)`${dataProp}`;
    subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
  }
  if (data !== void 0) {
    const nextData = data instanceof codegen_1$o.Name ? data : gen.let("data", data, true);
    dataContextProps(nextData);
    if (propertyName !== void 0)
      subschema2.propertyName = propertyName;
  }
  if (dataTypes)
    subschema2.dataTypes = dataTypes;
  function dataContextProps(_nextData) {
    subschema2.data = _nextData;
    subschema2.dataLevel = it.dataLevel + 1;
    subschema2.dataTypes = [];
    it.definedProperties = /* @__PURE__ */ new Set();
    subschema2.parentData = it.data;
    subschema2.dataNames = [...it.dataNames, _nextData];
  }
}
subschema.extendSubschemaData = extendSubschemaData;
function extendSubschemaMode(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
  if (compositeRule !== void 0)
    subschema2.compositeRule = compositeRule;
  if (createErrors !== void 0)
    subschema2.createErrors = createErrors;
  if (allErrors !== void 0)
    subschema2.allErrors = allErrors;
  subschema2.jtdDiscriminator = jtdDiscriminator;
  subschema2.jtdMetadata = jtdMetadata;
}
subschema.extendSubschemaMode = extendSubschemaMode;
var resolve$2 = {};
var jsonSchemaTraverse = { exports: {} };
var traverse$1 = jsonSchemaTraverse.exports = function(schema, opts, cb) {
  if (typeof opts == "function") {
    cb = opts;
    opts = {};
  }
  cb = opts.cb || cb;
  var pre = typeof cb == "function" ? cb : cb.pre || function() {
  };
  var post = cb.post || function() {
  };
  _traverse(opts, pre, post, schema, "", schema);
};
traverse$1.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true,
  if: true,
  then: true,
  else: true
};
traverse$1.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};
traverse$1.propsKeywords = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};
traverse$1.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};
function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == "object" && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key2 in schema) {
      var sch = schema[key2];
      if (Array.isArray(sch)) {
        if (key2 in traverse$1.arrayKeywords) {
          for (var i = 0; i < sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key2 + "/" + i, rootSchema, jsonPtr, key2, schema, i);
        }
      } else if (key2 in traverse$1.propsKeywords) {
        if (sch && typeof sch == "object") {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key2 + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key2, schema, prop);
        }
      } else if (key2 in traverse$1.keywords || opts.allKeys && !(key2 in traverse$1.skipKeywords)) {
        _traverse(opts, pre, post, sch, jsonPtr + "/" + key2, rootSchema, jsonPtr, key2, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}
function escapeJsonPtr(str) {
  return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
var jsonSchemaTraverseExports = jsonSchemaTraverse.exports;
Object.defineProperty(resolve$2, "__esModule", { value: true });
resolve$2.getSchemaRefs = resolve$2.resolveUrl = resolve$2.normalizeId = resolve$2._getFullPath = resolve$2.getFullPath = resolve$2.inlineRef = void 0;
const util_1$m = util;
const equal$2 = fastDeepEqual;
const traverse = jsonSchemaTraverseExports;
const SIMPLE_INLINED = /* @__PURE__ */ new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function inlineRef(schema, limit2 = true) {
  if (typeof schema == "boolean")
    return true;
  if (limit2 === true)
    return !hasRef(schema);
  if (!limit2)
    return false;
  return countKeys(schema) <= limit2;
}
resolve$2.inlineRef = inlineRef;
const REF_KEYWORDS = /* @__PURE__ */ new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function hasRef(schema) {
  for (const key2 in schema) {
    if (REF_KEYWORDS.has(key2))
      return true;
    const sch = schema[key2];
    if (Array.isArray(sch) && sch.some(hasRef))
      return true;
    if (typeof sch == "object" && hasRef(sch))
      return true;
  }
  return false;
}
function countKeys(schema) {
  let count = 0;
  for (const key2 in schema) {
    if (key2 === "$ref")
      return Infinity;
    count++;
    if (SIMPLE_INLINED.has(key2))
      continue;
    if (typeof schema[key2] == "object") {
      (0, util_1$m.eachItem)(schema[key2], (sch) => count += countKeys(sch));
    }
    if (count === Infinity)
      return Infinity;
  }
  return count;
}
function getFullPath(resolver, id2 = "", normalize2) {
  if (normalize2 !== false)
    id2 = normalizeId(id2);
  const p = resolver.parse(id2);
  return _getFullPath(resolver, p);
}
resolve$2.getFullPath = getFullPath;
function _getFullPath(resolver, p) {
  const serialized = resolver.serialize(p);
  return serialized.split("#")[0] + "#";
}
resolve$2._getFullPath = _getFullPath;
const TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id2) {
  return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
}
resolve$2.normalizeId = normalizeId;
function resolveUrl(resolver, baseId, id2) {
  id2 = normalizeId(id2);
  return resolver.resolve(baseId, id2);
}
resolve$2.resolveUrl = resolveUrl;
const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
function getSchemaRefs(schema, baseId) {
  if (typeof schema == "boolean")
    return {};
  const { schemaId, uriResolver } = this.opts;
  const schId = normalizeId(schema[schemaId] || baseId);
  const baseIds = { "": schId };
  const pathPrefix = getFullPath(uriResolver, schId, false);
  const localRefs = {};
  const schemaRefs = /* @__PURE__ */ new Set();
  traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
    if (parentJsonPtr === void 0)
      return;
    const fullPath = pathPrefix + jsonPtr;
    let innerBaseId = baseIds[parentJsonPtr];
    if (typeof sch[schemaId] == "string")
      innerBaseId = addRef.call(this, sch[schemaId]);
    addAnchor.call(this, sch.$anchor);
    addAnchor.call(this, sch.$dynamicAnchor);
    baseIds[jsonPtr] = innerBaseId;
    function addRef(ref2) {
      const _resolve = this.opts.uriResolver.resolve;
      ref2 = normalizeId(innerBaseId ? _resolve(innerBaseId, ref2) : ref2);
      if (schemaRefs.has(ref2))
        throw ambiguos(ref2);
      schemaRefs.add(ref2);
      let schOrRef = this.refs[ref2];
      if (typeof schOrRef == "string")
        schOrRef = this.refs[schOrRef];
      if (typeof schOrRef == "object") {
        checkAmbiguosRef(sch, schOrRef.schema, ref2);
      } else if (ref2 !== normalizeId(fullPath)) {
        if (ref2[0] === "#") {
          checkAmbiguosRef(sch, localRefs[ref2], ref2);
          localRefs[ref2] = sch;
        } else {
          this.refs[ref2] = fullPath;
        }
      }
      return ref2;
    }
    function addAnchor(anchor) {
      if (typeof anchor == "string") {
        if (!ANCHOR.test(anchor))
          throw new Error(`invalid anchor "${anchor}"`);
        addRef.call(this, `#${anchor}`);
      }
    }
  });
  return localRefs;
  function checkAmbiguosRef(sch1, sch2, ref2) {
    if (sch2 !== void 0 && !equal$2(sch1, sch2))
      throw ambiguos(ref2);
  }
  function ambiguos(ref2) {
    return new Error(`reference "${ref2}" resolves to more than one schema`);
  }
}
resolve$2.getSchemaRefs = getSchemaRefs;
Object.defineProperty(validate, "__esModule", { value: true });
validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
const boolSchema_1 = boolSchema;
const dataType_1$1 = dataType;
const applicability_1 = applicability;
const dataType_2 = dataType;
const defaults_1 = defaults;
const keyword_1 = keyword;
const subschema_1 = subschema;
const codegen_1$n = codegen;
const names_1$3 = names$1;
const resolve_1$2 = resolve$2;
const util_1$l = util;
const errors_1 = errors$3;
function validateFunctionCode(it) {
  if (isSchemaObj(it)) {
    checkKeywords(it);
    if (schemaCxtHasRules(it)) {
      topSchemaObjCode(it);
      return;
    }
  }
  validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
}
validate.validateFunctionCode = validateFunctionCode;
function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
  if (opts.code.es5) {
    gen.func(validateName, (0, codegen_1$n._)`${names_1$3.default.data}, ${names_1$3.default.valCxt}`, schemaEnv.$async, () => {
      gen.code((0, codegen_1$n._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
      destructureValCxtES5(gen, opts);
      gen.code(body);
    });
  } else {
    gen.func(validateName, (0, codegen_1$n._)`${names_1$3.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
  }
}
function destructureValCxt(opts) {
  return (0, codegen_1$n._)`{${names_1$3.default.instancePath}="", ${names_1$3.default.parentData}, ${names_1$3.default.parentDataProperty}, ${names_1$3.default.rootData}=${names_1$3.default.data}${opts.dynamicRef ? (0, codegen_1$n._)`, ${names_1$3.default.dynamicAnchors}={}` : codegen_1$n.nil}}={}`;
}
function destructureValCxtES5(gen, opts) {
  gen.if(names_1$3.default.valCxt, () => {
    gen.var(names_1$3.default.instancePath, (0, codegen_1$n._)`${names_1$3.default.valCxt}.${names_1$3.default.instancePath}`);
    gen.var(names_1$3.default.parentData, (0, codegen_1$n._)`${names_1$3.default.valCxt}.${names_1$3.default.parentData}`);
    gen.var(names_1$3.default.parentDataProperty, (0, codegen_1$n._)`${names_1$3.default.valCxt}.${names_1$3.default.parentDataProperty}`);
    gen.var(names_1$3.default.rootData, (0, codegen_1$n._)`${names_1$3.default.valCxt}.${names_1$3.default.rootData}`);
    if (opts.dynamicRef)
      gen.var(names_1$3.default.dynamicAnchors, (0, codegen_1$n._)`${names_1$3.default.valCxt}.${names_1$3.default.dynamicAnchors}`);
  }, () => {
    gen.var(names_1$3.default.instancePath, (0, codegen_1$n._)`""`);
    gen.var(names_1$3.default.parentData, (0, codegen_1$n._)`undefined`);
    gen.var(names_1$3.default.parentDataProperty, (0, codegen_1$n._)`undefined`);
    gen.var(names_1$3.default.rootData, names_1$3.default.data);
    if (opts.dynamicRef)
      gen.var(names_1$3.default.dynamicAnchors, (0, codegen_1$n._)`{}`);
  });
}
function topSchemaObjCode(it) {
  const { schema, opts, gen } = it;
  validateFunction(it, () => {
    if (opts.$comment && schema.$comment)
      commentKeyword(it);
    checkNoDefault(it);
    gen.let(names_1$3.default.vErrors, null);
    gen.let(names_1$3.default.errors, 0);
    if (opts.unevaluated)
      resetEvaluated(it);
    typeAndKeywords(it);
    returnResults(it);
  });
  return;
}
function resetEvaluated(it) {
  const { gen, validateName } = it;
  it.evaluated = gen.const("evaluated", (0, codegen_1$n._)`${validateName}.evaluated`);
  gen.if((0, codegen_1$n._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1$n._)`${it.evaluated}.props`, (0, codegen_1$n._)`undefined`));
  gen.if((0, codegen_1$n._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1$n._)`${it.evaluated}.items`, (0, codegen_1$n._)`undefined`));
}
function funcSourceUrl(schema, opts) {
  const schId = typeof schema == "object" && schema[opts.schemaId];
  return schId && (opts.code.source || opts.code.process) ? (0, codegen_1$n._)`/*# sourceURL=${schId} */` : codegen_1$n.nil;
}
function subschemaCode(it, valid2) {
  if (isSchemaObj(it)) {
    checkKeywords(it);
    if (schemaCxtHasRules(it)) {
      subSchemaObjCode(it, valid2);
      return;
    }
  }
  (0, boolSchema_1.boolOrEmptySchema)(it, valid2);
}
function schemaCxtHasRules({ schema, self: self2 }) {
  if (typeof schema == "boolean")
    return !schema;
  for (const key2 in schema)
    if (self2.RULES.all[key2])
      return true;
  return false;
}
function isSchemaObj(it) {
  return typeof it.schema != "boolean";
}
function subSchemaObjCode(it, valid2) {
  const { schema, gen, opts } = it;
  if (opts.$comment && schema.$comment)
    commentKeyword(it);
  updateContext(it);
  checkAsyncSchema(it);
  const errsCount = gen.const("_errs", names_1$3.default.errors);
  typeAndKeywords(it, errsCount);
  gen.var(valid2, (0, codegen_1$n._)`${errsCount} === ${names_1$3.default.errors}`);
}
function checkKeywords(it) {
  (0, util_1$l.checkUnknownRules)(it);
  checkRefsAndKeywords(it);
}
function typeAndKeywords(it, errsCount) {
  if (it.opts.jtd)
    return schemaKeywords(it, [], false, errsCount);
  const types2 = (0, dataType_1$1.getSchemaTypes)(it.schema);
  const checkedTypes = (0, dataType_1$1.coerceAndCheckDataType)(it, types2);
  schemaKeywords(it, types2, !checkedTypes, errsCount);
}
function checkRefsAndKeywords(it) {
  const { schema, errSchemaPath, opts, self: self2 } = it;
  if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1$l.schemaHasRulesButRef)(schema, self2.RULES)) {
    self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
  }
}
function checkNoDefault(it) {
  const { schema, opts } = it;
  if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
    (0, util_1$l.checkStrictMode)(it, "default is ignored in the schema root");
  }
}
function updateContext(it) {
  const schId = it.schema[it.opts.schemaId];
  if (schId)
    it.baseId = (0, resolve_1$2.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
}
function checkAsyncSchema(it) {
  if (it.schema.$async && !it.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
  const msg = schema.$comment;
  if (opts.$comment === true) {
    gen.code((0, codegen_1$n._)`${names_1$3.default.self}.logger.log(${msg})`);
  } else if (typeof opts.$comment == "function") {
    const schemaPath = (0, codegen_1$n.str)`${errSchemaPath}/$comment`;
    const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
    gen.code((0, codegen_1$n._)`${names_1$3.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
  }
}
function returnResults(it) {
  const { gen, schemaEnv, validateName, ValidationError: ValidationError3, opts } = it;
  if (schemaEnv.$async) {
    gen.if((0, codegen_1$n._)`${names_1$3.default.errors} === 0`, () => gen.return(names_1$3.default.data), () => gen.throw((0, codegen_1$n._)`new ${ValidationError3}(${names_1$3.default.vErrors})`));
  } else {
    gen.assign((0, codegen_1$n._)`${validateName}.errors`, names_1$3.default.vErrors);
    if (opts.unevaluated)
      assignEvaluated(it);
    gen.return((0, codegen_1$n._)`${names_1$3.default.errors} === 0`);
  }
}
function assignEvaluated({ gen, evaluated, props, items: items2 }) {
  if (props instanceof codegen_1$n.Name)
    gen.assign((0, codegen_1$n._)`${evaluated}.props`, props);
  if (items2 instanceof codegen_1$n.Name)
    gen.assign((0, codegen_1$n._)`${evaluated}.items`, items2);
}
function schemaKeywords(it, types2, typeErrors, errsCount) {
  const { gen, schema, data, allErrors, opts, self: self2 } = it;
  const { RULES } = self2;
  if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1$l.schemaHasRulesButRef)(schema, RULES))) {
    gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
    return;
  }
  if (!opts.jtd)
    checkStrictTypes(it, types2);
  gen.block(() => {
    for (const group of RULES.rules)
      groupKeywords(group);
    groupKeywords(RULES.post);
  });
  function groupKeywords(group) {
    if (!(0, applicability_1.shouldUseGroup)(schema, group))
      return;
    if (group.type) {
      gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
      iterateKeywords(it, group);
      if (types2.length === 1 && types2[0] === group.type && typeErrors) {
        gen.else();
        (0, dataType_2.reportTypeError)(it);
      }
      gen.endIf();
    } else {
      iterateKeywords(it, group);
    }
    if (!allErrors)
      gen.if((0, codegen_1$n._)`${names_1$3.default.errors} === ${errsCount || 0}`);
  }
}
function iterateKeywords(it, group) {
  const { gen, schema, opts: { useDefaults } } = it;
  if (useDefaults)
    (0, defaults_1.assignDefaults)(it, group.type);
  gen.block(() => {
    for (const rule of group.rules) {
      if ((0, applicability_1.shouldUseRule)(schema, rule)) {
        keywordCode(it, rule.keyword, rule.definition, group.type);
      }
    }
  });
}
function checkStrictTypes(it, types2) {
  if (it.schemaEnv.meta || !it.opts.strictTypes)
    return;
  checkContextTypes(it, types2);
  if (!it.opts.allowUnionTypes)
    checkMultipleTypes(it, types2);
  checkKeywordTypes(it, it.dataTypes);
}
function checkContextTypes(it, types2) {
  if (!types2.length)
    return;
  if (!it.dataTypes.length) {
    it.dataTypes = types2;
    return;
  }
  types2.forEach((t2) => {
    if (!includesType(it.dataTypes, t2)) {
      strictTypesError(it, `type "${t2}" not allowed by context "${it.dataTypes.join(",")}"`);
    }
  });
  narrowSchemaTypes(it, types2);
}
function checkMultipleTypes(it, ts) {
  if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
    strictTypesError(it, "use allowUnionTypes to allow union type keyword");
  }
}
function checkKeywordTypes(it, ts) {
  const rules2 = it.self.RULES.all;
  for (const keyword2 in rules2) {
    const rule = rules2[keyword2];
    if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
      const { type: type2 } = rule.definition;
      if (type2.length && !type2.some((t2) => hasApplicableType(ts, t2))) {
        strictTypesError(it, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
      }
    }
  }
}
function hasApplicableType(schTs, kwdT) {
  return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
}
function includesType(ts, t2) {
  return ts.includes(t2) || t2 === "integer" && ts.includes("number");
}
function narrowSchemaTypes(it, withTypes) {
  const ts = [];
  for (const t2 of it.dataTypes) {
    if (includesType(withTypes, t2))
      ts.push(t2);
    else if (withTypes.includes("integer") && t2 === "number")
      ts.push("integer");
  }
  it.dataTypes = ts;
}
function strictTypesError(it, msg) {
  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
  msg += ` at "${schemaPath}" (strictTypes)`;
  (0, util_1$l.checkStrictMode)(it, msg, it.opts.strictTypes);
}
class KeywordCxt2 {
  constructor(it, def2, keyword2) {
    (0, keyword_1.validateKeywordUsage)(it, def2, keyword2);
    this.gen = it.gen;
    this.allErrors = it.allErrors;
    this.keyword = keyword2;
    this.data = it.data;
    this.schema = it.schema[keyword2];
    this.$data = def2.$data && it.opts.$data && this.schema && this.schema.$data;
    this.schemaValue = (0, util_1$l.schemaRefOrVal)(it, this.schema, keyword2, this.$data);
    this.schemaType = def2.schemaType;
    this.parentSchema = it.schema;
    this.params = {};
    this.it = it;
    this.def = def2;
    if (this.$data) {
      this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
    } else {
      this.schemaCode = this.schemaValue;
      if (!(0, keyword_1.validSchemaType)(this.schema, def2.schemaType, def2.allowUndefined)) {
        throw new Error(`${keyword2} value must be ${JSON.stringify(def2.schemaType)}`);
      }
    }
    if ("code" in def2 ? def2.trackErrors : def2.errors !== false) {
      this.errsCount = it.gen.const("_errs", names_1$3.default.errors);
    }
  }
  result(condition, successAction, failAction) {
    this.failResult((0, codegen_1$n.not)(condition), successAction, failAction);
  }
  failResult(condition, successAction, failAction) {
    this.gen.if(condition);
    if (failAction)
      failAction();
    else
      this.error();
    if (successAction) {
      this.gen.else();
      successAction();
      if (this.allErrors)
        this.gen.endIf();
    } else {
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
  }
  pass(condition, failAction) {
    this.failResult((0, codegen_1$n.not)(condition), void 0, failAction);
  }
  fail(condition) {
    if (condition === void 0) {
      this.error();
      if (!this.allErrors)
        this.gen.if(false);
      return;
    }
    this.gen.if(condition);
    this.error();
    if (this.allErrors)
      this.gen.endIf();
    else
      this.gen.else();
  }
  fail$data(condition) {
    if (!this.$data)
      return this.fail(condition);
    const { schemaCode } = this;
    this.fail((0, codegen_1$n._)`${schemaCode} !== undefined && (${(0, codegen_1$n.or)(this.invalid$data(), condition)})`);
  }
  error(append, errorParams, errorPaths) {
    if (errorParams) {
      this.setParams(errorParams);
      this._error(append, errorPaths);
      this.setParams({});
      return;
    }
    this._error(append, errorPaths);
  }
  _error(append, errorPaths) {
    (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
  }
  $dataError() {
    (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(cond) {
    if (!this.allErrors)
      this.gen.if(cond);
  }
  setParams(obj, assign) {
    if (assign)
      Object.assign(this.params, obj);
    else
      this.params = obj;
  }
  block$data(valid2, codeBlock, $dataValid = codegen_1$n.nil) {
    this.gen.block(() => {
      this.check$data(valid2, $dataValid);
      codeBlock();
    });
  }
  check$data(valid2 = codegen_1$n.nil, $dataValid = codegen_1$n.nil) {
    if (!this.$data)
      return;
    const { gen, schemaCode, schemaType, def: def2 } = this;
    gen.if((0, codegen_1$n.or)((0, codegen_1$n._)`${schemaCode} === undefined`, $dataValid));
    if (valid2 !== codegen_1$n.nil)
      gen.assign(valid2, true);
    if (schemaType.length || def2.validateSchema) {
      gen.elseIf(this.invalid$data());
      this.$dataError();
      if (valid2 !== codegen_1$n.nil)
        gen.assign(valid2, false);
    }
    gen.else();
  }
  invalid$data() {
    const { gen, schemaCode, schemaType, def: def2, it } = this;
    return (0, codegen_1$n.or)(wrong$DataType(), invalid$DataSchema());
    function wrong$DataType() {
      if (schemaType.length) {
        if (!(schemaCode instanceof codegen_1$n.Name))
          throw new Error("ajv implementation error");
        const st = Array.isArray(schemaType) ? schemaType : [schemaType];
        return (0, codegen_1$n._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
      }
      return codegen_1$n.nil;
    }
    function invalid$DataSchema() {
      if (def2.validateSchema) {
        const validateSchemaRef = gen.scopeValue("validate$data", { ref: def2.validateSchema });
        return (0, codegen_1$n._)`!${validateSchemaRef}(${schemaCode})`;
      }
      return codegen_1$n.nil;
    }
  }
  subschema(appl, valid2) {
    const subschema2 = (0, subschema_1.getSubschema)(this.it, appl);
    (0, subschema_1.extendSubschemaData)(subschema2, this.it, appl);
    (0, subschema_1.extendSubschemaMode)(subschema2, appl);
    const nextContext = { ...this.it, ...subschema2, items: void 0, props: void 0 };
    subschemaCode(nextContext, valid2);
    return nextContext;
  }
  mergeEvaluated(schemaCxt, toName) {
    const { it, gen } = this;
    if (!it.opts.unevaluated)
      return;
    if (it.props !== true && schemaCxt.props !== void 0) {
      it.props = util_1$l.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
    }
    if (it.items !== true && schemaCxt.items !== void 0) {
      it.items = util_1$l.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
    }
  }
  mergeValidEvaluated(schemaCxt, valid2) {
    const { it, gen } = this;
    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
      gen.if(valid2, () => this.mergeEvaluated(schemaCxt, codegen_1$n.Name));
      return true;
    }
  }
}
validate.KeywordCxt = KeywordCxt2;
function keywordCode(it, keyword2, def2, ruleType) {
  const cxt = new KeywordCxt2(it, def2, keyword2);
  if ("code" in def2) {
    def2.code(cxt, ruleType);
  } else if (cxt.$data && def2.validate) {
    (0, keyword_1.funcKeywordCode)(cxt, def2);
  } else if ("macro" in def2) {
    (0, keyword_1.macroKeywordCode)(cxt, def2);
  } else if (def2.compile || def2.validate) {
    (0, keyword_1.funcKeywordCode)(cxt, def2);
  }
}
const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, { dataLevel, dataNames, dataPathArr }) {
  let jsonPointer;
  let data;
  if ($data === "")
    return names_1$3.default.rootData;
  if ($data[0] === "/") {
    if (!JSON_POINTER.test($data))
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    jsonPointer = $data;
    data = names_1$3.default.rootData;
  } else {
    const matches = RELATIVE_JSON_POINTER.exec($data);
    if (!matches)
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    const up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer === "#") {
      if (up >= dataLevel)
        throw new Error(errorMsg("property/index", up));
      return dataPathArr[dataLevel - up];
    }
    if (up > dataLevel)
      throw new Error(errorMsg("data", up));
    data = dataNames[dataLevel - up];
    if (!jsonPointer)
      return data;
  }
  let expr = data;
  const segments = jsonPointer.split("/");
  for (const segment of segments) {
    if (segment) {
      data = (0, codegen_1$n._)`${data}${(0, codegen_1$n.getProperty)((0, util_1$l.unescapeJsonPointer)(segment))}`;
      expr = (0, codegen_1$n._)`${expr} && ${data}`;
    }
  }
  return expr;
  function errorMsg(pointerType, up) {
    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
  }
}
validate.getData = getData;
var validation_error = {};
Object.defineProperty(validation_error, "__esModule", { value: true });
class ValidationError2 extends Error {
  constructor(errors2) {
    super("validation failed");
    this.errors = errors2;
    this.ajv = this.validation = true;
  }
}
validation_error.default = ValidationError2;
var ref_error = {};
Object.defineProperty(ref_error, "__esModule", { value: true });
const resolve_1$1 = resolve$2;
class MissingRefError2 extends Error {
  constructor(resolver, baseId, ref2, msg) {
    super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
    this.missingRef = (0, resolve_1$1.resolveUrl)(resolver, baseId, ref2);
    this.missingSchema = (0, resolve_1$1.normalizeId)((0, resolve_1$1.getFullPath)(resolver, this.missingRef));
  }
}
ref_error.default = MissingRefError2;
var compile = {};
Object.defineProperty(compile, "__esModule", { value: true });
compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
const codegen_1$m = codegen;
const validation_error_1 = validation_error;
const names_1$2 = names$1;
const resolve_1 = resolve$2;
const util_1$k = util;
const validate_1$1 = validate;
class SchemaEnv2 {
  constructor(env2) {
    var _a;
    this.refs = {};
    this.dynamicAnchors = {};
    let schema;
    if (typeof env2.schema == "object")
      schema = env2.schema;
    this.schema = env2.schema;
    this.schemaId = env2.schemaId;
    this.root = env2.root || this;
    this.baseId = (_a = env2.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env2.schemaId || "$id"]);
    this.schemaPath = env2.schemaPath;
    this.localRefs = env2.localRefs;
    this.meta = env2.meta;
    this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
    this.refs = {};
  }
}
compile.SchemaEnv = SchemaEnv2;
function compileSchema(sch) {
  const _sch = getCompilingSchema.call(this, sch);
  if (_sch)
    return _sch;
  const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
  const { es5, lines } = this.opts.code;
  const { ownProperties } = this.opts;
  const gen = new codegen_1$m.CodeGen(this.scope, { es5, lines, ownProperties });
  let _ValidationError;
  if (sch.$async) {
    _ValidationError = gen.scopeValue("Error", {
      ref: validation_error_1.default,
      code: (0, codegen_1$m._)`require("ajv/dist/runtime/validation_error").default`
    });
  }
  const validateName = gen.scopeName("validate");
  sch.validateName = validateName;
  const schemaCxt = {
    gen,
    allErrors: this.opts.allErrors,
    data: names_1$2.default.data,
    parentData: names_1$2.default.parentData,
    parentDataProperty: names_1$2.default.parentDataProperty,
    dataNames: [names_1$2.default.data],
    dataPathArr: [codegen_1$m.nil],
    // TODO can its length be used as dataLevel if nil is removed?
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
    topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1$m.stringify)(sch.schema) } : { ref: sch.schema }),
    validateName,
    ValidationError: _ValidationError,
    schema: sch.schema,
    schemaEnv: sch,
    rootId,
    baseId: sch.baseId || rootId,
    schemaPath: codegen_1$m.nil,
    errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, codegen_1$m._)`""`,
    opts: this.opts,
    self: this
  };
  let sourceCode;
  try {
    this._compilations.add(sch);
    (0, validate_1$1.validateFunctionCode)(schemaCxt);
    gen.optimize(this.opts.code.optimize);
    const validateCode = gen.toString();
    sourceCode = `${gen.scopeRefs(names_1$2.default.scope)}return ${validateCode}`;
    if (this.opts.code.process)
      sourceCode = this.opts.code.process(sourceCode, sch);
    const makeValidate = new Function(`${names_1$2.default.self}`, `${names_1$2.default.scope}`, sourceCode);
    const validate2 = makeValidate(this, this.scope.get());
    this.scope.value(validateName, { ref: validate2 });
    validate2.errors = null;
    validate2.schema = sch.schema;
    validate2.schemaEnv = sch;
    if (sch.$async)
      validate2.$async = true;
    if (this.opts.code.source === true) {
      validate2.source = { validateName, validateCode, scopeValues: gen._values };
    }
    if (this.opts.unevaluated) {
      const { props, items: items2 } = schemaCxt;
      validate2.evaluated = {
        props: props instanceof codegen_1$m.Name ? void 0 : props,
        items: items2 instanceof codegen_1$m.Name ? void 0 : items2,
        dynamicProps: props instanceof codegen_1$m.Name,
        dynamicItems: items2 instanceof codegen_1$m.Name
      };
      if (validate2.source)
        validate2.source.evaluated = (0, codegen_1$m.stringify)(validate2.evaluated);
    }
    sch.validate = validate2;
    return sch;
  } catch (e) {
    delete sch.validate;
    delete sch.validateName;
    if (sourceCode)
      this.logger.error("Error compiling schema, function code:", sourceCode);
    throw e;
  } finally {
    this._compilations.delete(sch);
  }
}
compile.compileSchema = compileSchema;
function resolveRef(root, baseId, ref2) {
  var _a;
  ref2 = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref2);
  const schOrFunc = root.refs[ref2];
  if (schOrFunc)
    return schOrFunc;
  let _sch = resolve$1.call(this, root, ref2);
  if (_sch === void 0) {
    const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref2];
    const { schemaId } = this.opts;
    if (schema)
      _sch = new SchemaEnv2({ schema, schemaId, root, baseId });
  }
  if (_sch === void 0)
    return;
  return root.refs[ref2] = inlineOrCompile.call(this, _sch);
}
compile.resolveRef = resolveRef;
function inlineOrCompile(sch) {
  if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
    return sch.schema;
  return sch.validate ? sch : compileSchema.call(this, sch);
}
function getCompilingSchema(schEnv) {
  for (const sch of this._compilations) {
    if (sameSchemaEnv(sch, schEnv))
      return sch;
  }
}
compile.getCompilingSchema = getCompilingSchema;
function sameSchemaEnv(s1, s2) {
  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
}
function resolve$1(root, ref2) {
  let sch;
  while (typeof (sch = this.refs[ref2]) == "string")
    ref2 = sch;
  return sch || this.schemas[ref2] || resolveSchema.call(this, root, ref2);
}
function resolveSchema(root, ref2) {
  const p = this.opts.uriResolver.parse(ref2);
  const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
  let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
  if (Object.keys(root.schema).length > 0 && refPath === baseId) {
    return getJsonPointer.call(this, p, root);
  }
  const id2 = (0, resolve_1.normalizeId)(refPath);
  const schOrRef = this.refs[id2] || this.schemas[id2];
  if (typeof schOrRef == "string") {
    const sch = resolveSchema.call(this, root, schOrRef);
    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
      return;
    return getJsonPointer.call(this, p, sch);
  }
  if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
    return;
  if (!schOrRef.validate)
    compileSchema.call(this, schOrRef);
  if (id2 === (0, resolve_1.normalizeId)(ref2)) {
    const { schema } = schOrRef;
    const { schemaId } = this.opts;
    const schId = schema[schemaId];
    if (schId)
      baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
    return new SchemaEnv2({ schema, schemaId, root, baseId });
  }
  return getJsonPointer.call(this, p, schOrRef);
}
compile.resolveSchema = resolveSchema;
const PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function getJsonPointer(parsedRef, { baseId, schema, root }) {
  var _a;
  if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
    return;
  for (const part of parsedRef.fragment.slice(1).split("/")) {
    if (typeof schema === "boolean")
      return;
    const partSchema = schema[(0, util_1$k.unescapeFragment)(part)];
    if (partSchema === void 0)
      return;
    schema = partSchema;
    const schId = typeof schema === "object" && schema[this.opts.schemaId];
    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
      baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
    }
  }
  let env2;
  if (typeof schema != "boolean" && schema.$ref && !(0, util_1$k.schemaHasRulesButRef)(schema, this.RULES)) {
    const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
    env2 = resolveSchema.call(this, root, $ref);
  }
  const { schemaId } = this.opts;
  env2 = env2 || new SchemaEnv2({ schema, schemaId, root, baseId });
  if (env2.schema !== env2.root.schema)
    return env2;
  return void 0;
}
const $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
const type$1 = "object";
const required$1 = [
  "$data"
];
const properties$2 = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
};
const additionalProperties$1 = false;
const require$$9 = {
  $id: $id$1,
  description,
  type: type$1,
  required: required$1,
  properties: properties$2,
  additionalProperties: additionalProperties$1
};
var uri$1 = {};
Object.defineProperty(uri$1, "__esModule", { value: true });
const uri = fastUriExports;
uri.code = 'require("ajv/dist/runtime/uri").default';
uri$1.default = uri;
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.CodeGen = exports$1.Name = exports$1.nil = exports$1.stringify = exports$1.str = exports$1._ = exports$1.KeywordCxt = void 0;
  var validate_12 = validate;
  Object.defineProperty(exports$1, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports$1, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  const validation_error_12 = validation_error;
  const ref_error_12 = ref_error;
  const rules_12 = rules;
  const compile_12 = compile;
  const codegen_2 = codegen;
  const resolve_12 = resolve$2;
  const dataType_12 = dataType;
  const util_12 = util;
  const $dataRefSchema = require$$9;
  const uri_1 = uri$1;
  const defaultRegExp = (str, flags) => new RegExp(str, flags);
  defaultRegExp.code = "new RegExp";
  const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
  const EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]);
  const removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  };
  const deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  };
  const MAX_EXPRESSION = 200;
  function requiredOptions(o) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
    const s = o.strict;
    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
    const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
    return {
      strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
      strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
      strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
      strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
      strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
      code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
      loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
      loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
      meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
      messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
      inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
      schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
      addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
      validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
      validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
      unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
      int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
      uriResolver
    };
  }
  class Ajv {
    constructor(opts = {}) {
      this.schemas = {};
      this.refs = {};
      this.formats = {};
      this._compilations = /* @__PURE__ */ new Set();
      this._loading = {};
      this._cache = /* @__PURE__ */ new Map();
      opts = this.opts = { ...opts, ...requiredOptions(opts) };
      const { es5, lines } = this.opts.code;
      this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
      this.logger = getLogger(opts.logger);
      const formatOpt = opts.validateFormats;
      opts.validateFormats = false;
      this.RULES = (0, rules_12.getRules)();
      checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
      checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
      this._metaOpts = getMetaSchemaOptions.call(this);
      if (opts.formats)
        addInitialFormats.call(this);
      this._addVocabularies();
      this._addDefaultMetaSchema();
      if (opts.keywords)
        addInitialKeywords.call(this, opts.keywords);
      if (typeof opts.meta == "object")
        this.addMetaSchema(opts.meta);
      addInitialSchemas.call(this);
      opts.validateFormats = formatOpt;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data, meta, schemaId } = this.opts;
      let _dataRefSchema = $dataRefSchema;
      if (schemaId === "id") {
        _dataRefSchema = { ...$dataRefSchema };
        _dataRefSchema.id = _dataRefSchema.$id;
        delete _dataRefSchema.$id;
      }
      if (meta && $data)
        this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
      const { meta, schemaId } = this.opts;
      return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
    }
    validate(schemaKeyRef, data) {
      let v;
      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v)
          throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
      } else {
        v = this.compile(schemaKeyRef);
      }
      const valid2 = v(data);
      if (!("$async" in v))
        this.errors = v.errors;
      return valid2;
    }
    compile(schema, _meta) {
      const sch = this._addSchema(schema, _meta);
      return sch.validate || this._compileSchemaEnv(sch);
    }
    compileAsync(schema, meta) {
      if (typeof this.opts.loadSchema != "function") {
        throw new Error("options.loadSchema should be a function");
      }
      const { loadSchema } = this.opts;
      return runCompileAsync.call(this, schema, meta);
      async function runCompileAsync(_schema, _meta) {
        await loadMetaSchema.call(this, _schema.$schema);
        const sch = this._addSchema(_schema, _meta);
        return sch.validate || _compileAsync.call(this, sch);
      }
      async function loadMetaSchema($ref) {
        if ($ref && !this.getSchema($ref)) {
          await runCompileAsync.call(this, { $ref }, true);
        }
      }
      async function _compileAsync(sch) {
        try {
          return this._compileSchemaEnv(sch);
        } catch (e) {
          if (!(e instanceof ref_error_12.default))
            throw e;
          checkLoaded.call(this, e);
          await loadMissingSchema.call(this, e.missingSchema);
          return _compileAsync.call(this, sch);
        }
      }
      function checkLoaded({ missingSchema: ref2, missingRef }) {
        if (this.refs[ref2]) {
          throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
        }
      }
      async function loadMissingSchema(ref2) {
        const _schema = await _loadSchema.call(this, ref2);
        if (!this.refs[ref2])
          await loadMetaSchema.call(this, _schema.$schema);
        if (!this.refs[ref2])
          this.addSchema(_schema, ref2, meta);
      }
      async function _loadSchema(ref2) {
        const p = this._loading[ref2];
        if (p)
          return p;
        try {
          return await (this._loading[ref2] = loadSchema(ref2));
        } finally {
          delete this._loading[ref2];
        }
      }
    }
    // Adds schema to the instance
    addSchema(schema, key2, _meta, _validateSchema = this.opts.validateSchema) {
      if (Array.isArray(schema)) {
        for (const sch of schema)
          this.addSchema(sch, void 0, _meta, _validateSchema);
        return this;
      }
      let id2;
      if (typeof schema === "object") {
        const { schemaId } = this.opts;
        id2 = schema[schemaId];
        if (id2 !== void 0 && typeof id2 != "string") {
          throw new Error(`schema ${schemaId} must be string`);
        }
      }
      key2 = (0, resolve_12.normalizeId)(key2 || id2);
      this._checkUnique(key2);
      this.schemas[key2] = this._addSchema(schema, _meta, key2, _validateSchema, true);
      return this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(schema, key2, _validateSchema = this.opts.validateSchema) {
      this.addSchema(schema, key2, true, _validateSchema);
      return this;
    }
    //  Validate schema against its meta-schema
    validateSchema(schema, throwOrLogError) {
      if (typeof schema == "boolean")
        return true;
      let $schema2;
      $schema2 = schema.$schema;
      if ($schema2 !== void 0 && typeof $schema2 != "string") {
        throw new Error("$schema must be a string");
      }
      $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
      if (!$schema2) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      const valid2 = this.validate($schema2, schema);
      if (!valid2 && throwOrLogError) {
        const message = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid2;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(keyRef) {
      let sch;
      while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
        keyRef = sch;
      if (sch === void 0) {
        const { schemaId } = this.opts;
        const root = new compile_12.SchemaEnv({ schema: {}, schemaId });
        sch = compile_12.resolveSchema.call(this, root, keyRef);
        if (!sch)
          return;
        this.refs[keyRef] = sch;
      }
      return sch.validate || this._compileSchemaEnv(sch);
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        this._removeAllSchemas(this.schemas, schemaKeyRef);
        this._removeAllSchemas(this.refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          this._removeAllSchemas(this.schemas);
          this._removeAllSchemas(this.refs);
          this._cache.clear();
          return this;
        case "string": {
          const sch = getSchEnv.call(this, schemaKeyRef);
          if (typeof sch == "object")
            this._cache.delete(sch.schema);
          delete this.schemas[schemaKeyRef];
          delete this.refs[schemaKeyRef];
          return this;
        }
        case "object": {
          const cacheKey = schemaKeyRef;
          this._cache.delete(cacheKey);
          let id2 = schemaKeyRef[this.opts.schemaId];
          if (id2) {
            id2 = (0, resolve_12.normalizeId)(id2);
            delete this.schemas[id2];
            delete this.refs[id2];
          }
          return this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(definitions2) {
      for (const def2 of definitions2)
        this.addKeyword(def2);
      return this;
    }
    addKeyword(kwdOrDef, def2) {
      let keyword2;
      if (typeof kwdOrDef == "string") {
        keyword2 = kwdOrDef;
        if (typeof def2 == "object") {
          this.logger.warn("these parameters are deprecated, see docs for addKeyword");
          def2.keyword = keyword2;
        }
      } else if (typeof kwdOrDef == "object" && def2 === void 0) {
        def2 = kwdOrDef;
        keyword2 = def2.keyword;
        if (Array.isArray(keyword2) && !keyword2.length) {
          throw new Error("addKeywords: keyword must be string or non-empty array");
        }
      } else {
        throw new Error("invalid addKeywords parameters");
      }
      checkKeyword.call(this, keyword2, def2);
      if (!def2) {
        (0, util_12.eachItem)(keyword2, (kwd) => addRule.call(this, kwd));
        return this;
      }
      keywordMetaschema.call(this, def2);
      const definition = {
        ...def2,
        type: (0, dataType_12.getJSONTypes)(def2.type),
        schemaType: (0, dataType_12.getJSONTypes)(def2.schemaType)
      };
      (0, util_12.eachItem)(keyword2, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t2) => addRule.call(this, k, definition, t2)));
      return this;
    }
    getKeyword(keyword2) {
      const rule = this.RULES.all[keyword2];
      return typeof rule == "object" ? rule.definition : !!rule;
    }
    // Remove keyword
    removeKeyword(keyword2) {
      const { RULES } = this;
      delete RULES.keywords[keyword2];
      delete RULES.all[keyword2];
      for (const group of RULES.rules) {
        const i = group.rules.findIndex((rule) => rule.keyword === keyword2);
        if (i >= 0)
          group.rules.splice(i, 1);
      }
      return this;
    }
    // Add format
    addFormat(name, format2) {
      if (typeof format2 == "string")
        format2 = new RegExp(format2);
      this.formats[name] = format2;
      return this;
    }
    errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
      if (!errors2 || errors2.length === 0)
        return "No errors";
      return errors2.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
      const rules2 = this.RULES.all;
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      for (const jsonPointer of keywordsJsonPointers) {
        const segments = jsonPointer.split("/").slice(1);
        let keywords = metaSchema;
        for (const seg of segments)
          keywords = keywords[seg];
        for (const key2 in rules2) {
          const rule = rules2[key2];
          if (typeof rule != "object")
            continue;
          const { $data } = rule.definition;
          const schema = keywords[key2];
          if ($data && schema)
            keywords[key2] = schemaOrData(schema);
        }
      }
      return metaSchema;
    }
    _removeAllSchemas(schemas, regex) {
      for (const keyRef in schemas) {
        const sch = schemas[keyRef];
        if (!regex || regex.test(keyRef)) {
          if (typeof sch == "string") {
            delete schemas[keyRef];
          } else if (sch && !sch.meta) {
            this._cache.delete(sch.schema);
            delete schemas[keyRef];
          }
        }
      }
    }
    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
      let id2;
      const { schemaId } = this.opts;
      if (typeof schema == "object") {
        id2 = schema[schemaId];
      } else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        else if (typeof schema != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let sch = this._cache.get(schema);
      if (sch !== void 0)
        return sch;
      baseId = (0, resolve_12.normalizeId)(id2 || baseId);
      const localRefs = resolve_12.getSchemaRefs.call(this, schema, baseId);
      sch = new compile_12.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
      this._cache.set(sch.schema, sch);
      if (addSchema && !baseId.startsWith("#")) {
        if (baseId)
          this._checkUnique(baseId);
        this.refs[baseId] = sch;
      }
      if (validateSchema)
        this.validateSchema(schema, true);
      return sch;
    }
    _checkUnique(id2) {
      if (this.schemas[id2] || this.refs[id2]) {
        throw new Error(`schema with key or id "${id2}" already exists`);
      }
    }
    _compileSchemaEnv(sch) {
      if (sch.meta)
        this._compileMetaSchema(sch);
      else
        compile_12.compileSchema.call(this, sch);
      if (!sch.validate)
        throw new Error("ajv implementation error");
      return sch.validate;
    }
    _compileMetaSchema(sch) {
      const currentOpts = this.opts;
      this.opts = this._metaOpts;
      try {
        compile_12.compileSchema.call(this, sch);
      } finally {
        this.opts = currentOpts;
      }
    }
  }
  Ajv.ValidationError = validation_error_12.default;
  Ajv.MissingRefError = ref_error_12.default;
  exports$1.default = Ajv;
  function checkOptions(checkOpts, options, msg, log = "error") {
    for (const key2 in checkOpts) {
      const opt = key2;
      if (opt in options)
        this.logger[log](`${msg}: option ${key2}. ${checkOpts[opt]}`);
    }
  }
  function getSchEnv(keyRef) {
    keyRef = (0, resolve_12.normalizeId)(keyRef);
    return this.schemas[keyRef] || this.refs[keyRef];
  }
  function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
      return;
    if (Array.isArray(optsSchemas))
      this.addSchema(optsSchemas);
    else
      for (const key2 in optsSchemas)
        this.addSchema(optsSchemas[key2], key2);
  }
  function addInitialFormats() {
    for (const name in this.opts.formats) {
      const format2 = this.opts.formats[name];
      if (format2)
        this.addFormat(name, format2);
    }
  }
  function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
      this.addVocabulary(defs);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword2 in defs) {
      const def2 = defs[keyword2];
      if (!def2.keyword)
        def2.keyword = keyword2;
      this.addKeyword(def2);
    }
  }
  function getMetaSchemaOptions() {
    const metaOpts = { ...this.opts };
    for (const opt of META_IGNORE_OPTIONS)
      delete metaOpts[opt];
    return metaOpts;
  }
  const noLogs = { log() {
  }, warn() {
  }, error() {
  } };
  function getLogger(logger) {
    if (logger === false)
      return noLogs;
    if (logger === void 0)
      return console;
    if (logger.log && logger.warn && logger.error)
      return logger;
    throw new Error("logger must implement log, warn and error methods");
  }
  const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
  function checkKeyword(keyword2, def2) {
    const { RULES } = this;
    (0, util_12.eachItem)(keyword2, (kwd) => {
      if (RULES.keywords[kwd])
        throw new Error(`Keyword ${kwd} is already defined`);
      if (!KEYWORD_NAME.test(kwd))
        throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def2)
      return;
    if (def2.$data && !("code" in def2 || "validate" in def2)) {
      throw new Error('$data keyword must have "code" or "validate" function');
    }
  }
  function addRule(keyword2, definition, dataType2) {
    var _a;
    const post = definition === null || definition === void 0 ? void 0 : definition.post;
    if (dataType2 && post)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t2 }) => t2 === dataType2);
    if (!ruleGroup) {
      ruleGroup = { type: dataType2, rules: [] };
      RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword2] = true;
    if (!definition)
      return;
    const rule = {
      keyword: keyword2,
      definition: {
        ...definition,
        type: (0, dataType_12.getJSONTypes)(definition.type),
        schemaType: (0, dataType_12.getJSONTypes)(definition.schemaType)
      }
    };
    if (definition.before)
      addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
      ruleGroup.rules.push(rule);
    RULES.all[keyword2] = rule;
    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
  }
  function addBeforeRule(ruleGroup, rule, before) {
    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i >= 0) {
      ruleGroup.rules.splice(i, 0, rule);
    } else {
      ruleGroup.rules.push(rule);
      this.logger.warn(`rule ${before} is not defined`);
    }
  }
  function keywordMetaschema(def2) {
    let { metaSchema } = def2;
    if (metaSchema === void 0)
      return;
    if (def2.$data && this.opts.$data)
      metaSchema = schemaOrData(metaSchema);
    def2.validateSchema = this.compile(metaSchema, true);
  }
  const $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function schemaOrData(schema) {
    return { anyOf: [schema, $dataRef] };
  }
})(core$2);
var draft7 = {};
var core$1 = {};
var id = {};
Object.defineProperty(id, "__esModule", { value: true });
const def$s = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
id.default = def$s;
var ref = {};
Object.defineProperty(ref, "__esModule", { value: true });
ref.callRef = ref.getValidate = void 0;
const ref_error_1$1 = ref_error;
const code_1$8 = code;
const codegen_1$l = codegen;
const names_1$1 = names$1;
const compile_1$1 = compile;
const util_1$j = util;
const def$r = {
  keyword: "$ref",
  schemaType: "string",
  code(cxt) {
    const { gen, schema: $ref, it } = cxt;
    const { baseId, schemaEnv: env2, validateName, opts, self: self2 } = it;
    const { root } = env2;
    if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
      return callRootRef();
    const schOrEnv = compile_1$1.resolveRef.call(self2, root, baseId, $ref);
    if (schOrEnv === void 0)
      throw new ref_error_1$1.default(it.opts.uriResolver, baseId, $ref);
    if (schOrEnv instanceof compile_1$1.SchemaEnv)
      return callValidate(schOrEnv);
    return inlineRefSchema(schOrEnv);
    function callRootRef() {
      if (env2 === root)
        return callRef(cxt, validateName, env2, env2.$async);
      const rootName = gen.scopeValue("root", { ref: root });
      return callRef(cxt, (0, codegen_1$l._)`${rootName}.validate`, root, root.$async);
    }
    function callValidate(sch) {
      const v = getValidate(cxt, sch);
      callRef(cxt, v, sch, sch.$async);
    }
    function inlineRefSchema(sch) {
      const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1$l.stringify)(sch) } : { ref: sch });
      const valid2 = gen.name("valid");
      const schCxt = cxt.subschema({
        schema: sch,
        dataTypes: [],
        schemaPath: codegen_1$l.nil,
        topSchemaRef: schName,
        errSchemaPath: $ref
      }, valid2);
      cxt.mergeEvaluated(schCxt);
      cxt.ok(valid2);
    }
  }
};
function getValidate(cxt, sch) {
  const { gen } = cxt;
  return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1$l._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
}
ref.getValidate = getValidate;
function callRef(cxt, v, sch, $async) {
  const { gen, it } = cxt;
  const { allErrors, schemaEnv: env2, opts } = it;
  const passCxt = opts.passContext ? names_1$1.default.this : codegen_1$l.nil;
  if ($async)
    callAsyncRef();
  else
    callSyncRef();
  function callAsyncRef() {
    if (!env2.$async)
      throw new Error("async schema referenced by sync schema");
    const valid2 = gen.let("valid");
    gen.try(() => {
      gen.code((0, codegen_1$l._)`await ${(0, code_1$8.callValidateCode)(cxt, v, passCxt)}`);
      addEvaluatedFrom(v);
      if (!allErrors)
        gen.assign(valid2, true);
    }, (e) => {
      gen.if((0, codegen_1$l._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
      addErrorsFrom(e);
      if (!allErrors)
        gen.assign(valid2, false);
    });
    cxt.ok(valid2);
  }
  function callSyncRef() {
    cxt.result((0, code_1$8.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
  }
  function addErrorsFrom(source2) {
    const errs = (0, codegen_1$l._)`${source2}.errors`;
    gen.assign(names_1$1.default.vErrors, (0, codegen_1$l._)`${names_1$1.default.vErrors} === null ? ${errs} : ${names_1$1.default.vErrors}.concat(${errs})`);
    gen.assign(names_1$1.default.errors, (0, codegen_1$l._)`${names_1$1.default.vErrors}.length`);
  }
  function addEvaluatedFrom(source2) {
    var _a;
    if (!it.opts.unevaluated)
      return;
    const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
    if (it.props !== true) {
      if (schEvaluated && !schEvaluated.dynamicProps) {
        if (schEvaluated.props !== void 0) {
          it.props = util_1$j.mergeEvaluated.props(gen, schEvaluated.props, it.props);
        }
      } else {
        const props = gen.var("props", (0, codegen_1$l._)`${source2}.evaluated.props`);
        it.props = util_1$j.mergeEvaluated.props(gen, props, it.props, codegen_1$l.Name);
      }
    }
    if (it.items !== true) {
      if (schEvaluated && !schEvaluated.dynamicItems) {
        if (schEvaluated.items !== void 0) {
          it.items = util_1$j.mergeEvaluated.items(gen, schEvaluated.items, it.items);
        }
      } else {
        const items2 = gen.var("items", (0, codegen_1$l._)`${source2}.evaluated.items`);
        it.items = util_1$j.mergeEvaluated.items(gen, items2, it.items, codegen_1$l.Name);
      }
    }
  }
}
ref.callRef = callRef;
ref.default = def$r;
Object.defineProperty(core$1, "__esModule", { value: true });
const id_1 = id;
const ref_1 = ref;
const core = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  id_1.default,
  ref_1.default
];
core$1.default = core;
var validation$1 = {};
var limitNumber = {};
Object.defineProperty(limitNumber, "__esModule", { value: true });
const codegen_1$k = codegen;
const ops = codegen_1$k.operators;
const KWDs = {
  maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
  minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
  exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
  exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
};
const error$i = {
  message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1$k.str)`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
  params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1$k._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
};
const def$q = {
  keyword: Object.keys(KWDs),
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$i,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    cxt.fail$data((0, codegen_1$k._)`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
  }
};
limitNumber.default = def$q;
var multipleOf = {};
Object.defineProperty(multipleOf, "__esModule", { value: true });
const codegen_1$j = codegen;
const error$h = {
  message: ({ schemaCode }) => (0, codegen_1$j.str)`must be multiple of ${schemaCode}`,
  params: ({ schemaCode }) => (0, codegen_1$j._)`{multipleOf: ${schemaCode}}`
};
const def$p = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$h,
  code(cxt) {
    const { gen, data, schemaCode, it } = cxt;
    const prec = it.opts.multipleOfPrecision;
    const res = gen.let("res");
    const invalid = prec ? (0, codegen_1$j._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1$j._)`${res} !== parseInt(${res})`;
    cxt.fail$data((0, codegen_1$j._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
  }
};
multipleOf.default = def$p;
var limitLength = {};
var ucs2length$1 = {};
Object.defineProperty(ucs2length$1, "__esModule", { value: true });
function ucs2length(str) {
  const len = str.length;
  let length = 0;
  let pos = 0;
  let value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 55296 && value <= 56319 && pos < len) {
      value = str.charCodeAt(pos);
      if ((value & 64512) === 56320)
        pos++;
    }
  }
  return length;
}
ucs2length$1.default = ucs2length;
ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(limitLength, "__esModule", { value: true });
const codegen_1$i = codegen;
const util_1$i = util;
const ucs2length_1 = ucs2length$1;
const error$g = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxLength" ? "more" : "fewer";
    return (0, codegen_1$i.str)`must NOT have ${comp} than ${schemaCode} characters`;
  },
  params: ({ schemaCode }) => (0, codegen_1$i._)`{limit: ${schemaCode}}`
};
const def$o = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: true,
  error: error$g,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode, it } = cxt;
    const op = keyword2 === "maxLength" ? codegen_1$i.operators.GT : codegen_1$i.operators.LT;
    const len = it.opts.unicode === false ? (0, codegen_1$i._)`${data}.length` : (0, codegen_1$i._)`${(0, util_1$i.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
    cxt.fail$data((0, codegen_1$i._)`${len} ${op} ${schemaCode}`);
  }
};
limitLength.default = def$o;
var pattern = {};
Object.defineProperty(pattern, "__esModule", { value: true });
const code_1$7 = code;
const codegen_1$h = codegen;
const error$f = {
  message: ({ schemaCode }) => (0, codegen_1$h.str)`must match pattern "${schemaCode}"`,
  params: ({ schemaCode }) => (0, codegen_1$h._)`{pattern: ${schemaCode}}`
};
const def$n = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: true,
  error: error$f,
  code(cxt) {
    const { data, $data, schema, schemaCode, it } = cxt;
    const u = it.opts.unicodeRegExp ? "u" : "";
    const regExp = $data ? (0, codegen_1$h._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1$7.usePattern)(cxt, schema);
    cxt.fail$data((0, codegen_1$h._)`!${regExp}.test(${data})`);
  }
};
pattern.default = def$n;
var limitProperties = {};
Object.defineProperty(limitProperties, "__esModule", { value: true });
const codegen_1$g = codegen;
const error$e = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxProperties" ? "more" : "fewer";
    return (0, codegen_1$g.str)`must NOT have ${comp} than ${schemaCode} properties`;
  },
  params: ({ schemaCode }) => (0, codegen_1$g._)`{limit: ${schemaCode}}`
};
const def$m = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: true,
  error: error$e,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxProperties" ? codegen_1$g.operators.GT : codegen_1$g.operators.LT;
    cxt.fail$data((0, codegen_1$g._)`Object.keys(${data}).length ${op} ${schemaCode}`);
  }
};
limitProperties.default = def$m;
var required = {};
Object.defineProperty(required, "__esModule", { value: true });
const code_1$6 = code;
const codegen_1$f = codegen;
const util_1$h = util;
const error$d = {
  message: ({ params: { missingProperty } }) => (0, codegen_1$f.str)`must have required property '${missingProperty}'`,
  params: ({ params: { missingProperty } }) => (0, codegen_1$f._)`{missingProperty: ${missingProperty}}`
};
const def$l = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: true,
  error: error$d,
  code(cxt) {
    const { gen, schema, schemaCode, data, $data, it } = cxt;
    const { opts } = it;
    if (!$data && schema.length === 0)
      return;
    const useLoop = schema.length >= opts.loopRequired;
    if (it.allErrors)
      allErrorsMode();
    else
      exitOnErrorMode();
    if (opts.strictRequired) {
      const props = cxt.parentSchema.properties;
      const { definedProperties } = cxt.it;
      for (const requiredKey of schema) {
        if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
          const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
          (0, util_1$h.checkStrictMode)(it, msg, it.opts.strictRequired);
        }
      }
    }
    function allErrorsMode() {
      if (useLoop || $data) {
        cxt.block$data(codegen_1$f.nil, loopAllRequired);
      } else {
        for (const prop of schema) {
          (0, code_1$6.checkReportMissingProp)(cxt, prop);
        }
      }
    }
    function exitOnErrorMode() {
      const missing = gen.let("missing");
      if (useLoop || $data) {
        const valid2 = gen.let("valid", true);
        cxt.block$data(valid2, () => loopUntilMissing(missing, valid2));
        cxt.ok(valid2);
      } else {
        gen.if((0, code_1$6.checkMissingProp)(cxt, schema, missing));
        (0, code_1$6.reportMissingProp)(cxt, missing);
        gen.else();
      }
    }
    function loopAllRequired() {
      gen.forOf("prop", schemaCode, (prop) => {
        cxt.setParams({ missingProperty: prop });
        gen.if((0, code_1$6.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
      });
    }
    function loopUntilMissing(missing, valid2) {
      cxt.setParams({ missingProperty: missing });
      gen.forOf(missing, schemaCode, () => {
        gen.assign(valid2, (0, code_1$6.propertyInData)(gen, data, missing, opts.ownProperties));
        gen.if((0, codegen_1$f.not)(valid2), () => {
          cxt.error();
          gen.break();
        });
      }, codegen_1$f.nil);
    }
  }
};
required.default = def$l;
var limitItems = {};
Object.defineProperty(limitItems, "__esModule", { value: true });
const codegen_1$e = codegen;
const error$c = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxItems" ? "more" : "fewer";
    return (0, codegen_1$e.str)`must NOT have ${comp} than ${schemaCode} items`;
  },
  params: ({ schemaCode }) => (0, codegen_1$e._)`{limit: ${schemaCode}}`
};
const def$k = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: true,
  error: error$c,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxItems" ? codegen_1$e.operators.GT : codegen_1$e.operators.LT;
    cxt.fail$data((0, codegen_1$e._)`${data}.length ${op} ${schemaCode}`);
  }
};
limitItems.default = def$k;
var uniqueItems = {};
var equal$1 = {};
Object.defineProperty(equal$1, "__esModule", { value: true });
const equal2 = fastDeepEqual;
equal2.code = 'require("ajv/dist/runtime/equal").default';
equal$1.default = equal2;
Object.defineProperty(uniqueItems, "__esModule", { value: true });
const dataType_1 = dataType;
const codegen_1$d = codegen;
const util_1$g = util;
const equal_1$2 = equal$1;
const error$b = {
  message: ({ params: { i, j } }) => (0, codegen_1$d.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
  params: ({ params: { i, j } }) => (0, codegen_1$d._)`{i: ${i}, j: ${j}}`
};
const def$j = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: true,
  error: error$b,
  code(cxt) {
    const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
    if (!$data && !schema)
      return;
    const valid2 = gen.let("valid");
    const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
    cxt.block$data(valid2, validateUniqueItems, (0, codegen_1$d._)`${schemaCode} === false`);
    cxt.ok(valid2);
    function validateUniqueItems() {
      const i = gen.let("i", (0, codegen_1$d._)`${data}.length`);
      const j = gen.let("j");
      cxt.setParams({ i, j });
      gen.assign(valid2, true);
      gen.if((0, codegen_1$d._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
    }
    function canOptimize() {
      return itemTypes.length > 0 && !itemTypes.some((t2) => t2 === "object" || t2 === "array");
    }
    function loopN(i, j) {
      const item = gen.name("item");
      const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
      const indices = gen.const("indices", (0, codegen_1$d._)`{}`);
      gen.for((0, codegen_1$d._)`;${i}--;`, () => {
        gen.let(item, (0, codegen_1$d._)`${data}[${i}]`);
        gen.if(wrongType, (0, codegen_1$d._)`continue`);
        if (itemTypes.length > 1)
          gen.if((0, codegen_1$d._)`typeof ${item} == "string"`, (0, codegen_1$d._)`${item} += "_"`);
        gen.if((0, codegen_1$d._)`typeof ${indices}[${item}] == "number"`, () => {
          gen.assign(j, (0, codegen_1$d._)`${indices}[${item}]`);
          cxt.error();
          gen.assign(valid2, false).break();
        }).code((0, codegen_1$d._)`${indices}[${item}] = ${i}`);
      });
    }
    function loopN2(i, j) {
      const eql = (0, util_1$g.useFunc)(gen, equal_1$2.default);
      const outer = gen.name("outer");
      gen.label(outer).for((0, codegen_1$d._)`;${i}--;`, () => gen.for((0, codegen_1$d._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1$d._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
        cxt.error();
        gen.assign(valid2, false).break(outer);
      })));
    }
  }
};
uniqueItems.default = def$j;
var _const = {};
Object.defineProperty(_const, "__esModule", { value: true });
const codegen_1$c = codegen;
const util_1$f = util;
const equal_1$1 = equal$1;
const error$a = {
  message: "must be equal to constant",
  params: ({ schemaCode }) => (0, codegen_1$c._)`{allowedValue: ${schemaCode}}`
};
const def$i = {
  keyword: "const",
  $data: true,
  error: error$a,
  code(cxt) {
    const { gen, data, $data, schemaCode, schema } = cxt;
    if ($data || schema && typeof schema == "object") {
      cxt.fail$data((0, codegen_1$c._)`!${(0, util_1$f.useFunc)(gen, equal_1$1.default)}(${data}, ${schemaCode})`);
    } else {
      cxt.fail((0, codegen_1$c._)`${schema} !== ${data}`);
    }
  }
};
_const.default = def$i;
var _enum = {};
Object.defineProperty(_enum, "__esModule", { value: true });
const codegen_1$b = codegen;
const util_1$e = util;
const equal_1 = equal$1;
const error$9 = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode }) => (0, codegen_1$b._)`{allowedValues: ${schemaCode}}`
};
const def$h = {
  keyword: "enum",
  schemaType: "array",
  $data: true,
  error: error$9,
  code(cxt) {
    const { gen, data, $data, schema, schemaCode, it } = cxt;
    if (!$data && schema.length === 0)
      throw new Error("enum must have non-empty array");
    const useLoop = schema.length >= it.opts.loopEnum;
    let eql;
    const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1$e.useFunc)(gen, equal_1.default);
    let valid2;
    if (useLoop || $data) {
      valid2 = gen.let("valid");
      cxt.block$data(valid2, loopEnum);
    } else {
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const vSchema = gen.const("vSchema", schemaCode);
      valid2 = (0, codegen_1$b.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
    }
    cxt.pass(valid2);
    function loopEnum() {
      gen.assign(valid2, false);
      gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1$b._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid2, true).break()));
    }
    function equalCode(vSchema, i) {
      const sch = schema[i];
      return typeof sch === "object" && sch !== null ? (0, codegen_1$b._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1$b._)`${data} === ${sch}`;
    }
  }
};
_enum.default = def$h;
Object.defineProperty(validation$1, "__esModule", { value: true });
const limitNumber_1 = limitNumber;
const multipleOf_1 = multipleOf;
const limitLength_1 = limitLength;
const pattern_1 = pattern;
const limitProperties_1 = limitProperties;
const required_1 = required;
const limitItems_1 = limitItems;
const uniqueItems_1 = uniqueItems;
const const_1 = _const;
const enum_1 = _enum;
const validation = [
  // number
  limitNumber_1.default,
  multipleOf_1.default,
  // string
  limitLength_1.default,
  pattern_1.default,
  // object
  limitProperties_1.default,
  required_1.default,
  // array
  limitItems_1.default,
  uniqueItems_1.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  const_1.default,
  enum_1.default
];
validation$1.default = validation;
var applicator = {};
var additionalItems = {};
Object.defineProperty(additionalItems, "__esModule", { value: true });
additionalItems.validateAdditionalItems = void 0;
const codegen_1$a = codegen;
const util_1$d = util;
const error$8 = {
  message: ({ params: { len } }) => (0, codegen_1$a.str)`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => (0, codegen_1$a._)`{limit: ${len}}`
};
const def$g = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: error$8,
  code(cxt) {
    const { parentSchema, it } = cxt;
    const { items: items2 } = parentSchema;
    if (!Array.isArray(items2)) {
      (0, util_1$d.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    validateAdditionalItems(cxt, items2);
  }
};
function validateAdditionalItems(cxt, items2) {
  const { gen, schema, data, keyword: keyword2, it } = cxt;
  it.items = true;
  const len = gen.const("len", (0, codegen_1$a._)`${data}.length`);
  if (schema === false) {
    cxt.setParams({ len: items2.length });
    cxt.pass((0, codegen_1$a._)`${len} <= ${items2.length}`);
  } else if (typeof schema == "object" && !(0, util_1$d.alwaysValidSchema)(it, schema)) {
    const valid2 = gen.var("valid", (0, codegen_1$a._)`${len} <= ${items2.length}`);
    gen.if((0, codegen_1$a.not)(valid2), () => validateItems(valid2));
    cxt.ok(valid2);
  }
  function validateItems(valid2) {
    gen.forRange("i", items2.length, len, (i) => {
      cxt.subschema({ keyword: keyword2, dataProp: i, dataPropType: util_1$d.Type.Num }, valid2);
      if (!it.allErrors)
        gen.if((0, codegen_1$a.not)(valid2), () => gen.break());
    });
  }
}
additionalItems.validateAdditionalItems = validateAdditionalItems;
additionalItems.default = def$g;
var prefixItems = {};
var items = {};
Object.defineProperty(items, "__esModule", { value: true });
items.validateTuple = void 0;
const codegen_1$9 = codegen;
const util_1$c = util;
const code_1$5 = code;
const def$f = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(cxt) {
    const { schema, it } = cxt;
    if (Array.isArray(schema))
      return validateTuple(cxt, "additionalItems", schema);
    it.items = true;
    if ((0, util_1$c.alwaysValidSchema)(it, schema))
      return;
    cxt.ok((0, code_1$5.validateArray)(cxt));
  }
};
function validateTuple(cxt, extraItems, schArr = cxt.schema) {
  const { gen, parentSchema, data, keyword: keyword2, it } = cxt;
  checkStrictTuple(parentSchema);
  if (it.opts.unevaluated && schArr.length && it.items !== true) {
    it.items = util_1$c.mergeEvaluated.items(gen, schArr.length, it.items);
  }
  const valid2 = gen.name("valid");
  const len = gen.const("len", (0, codegen_1$9._)`${data}.length`);
  schArr.forEach((sch, i) => {
    if ((0, util_1$c.alwaysValidSchema)(it, sch))
      return;
    gen.if((0, codegen_1$9._)`${len} > ${i}`, () => cxt.subschema({
      keyword: keyword2,
      schemaProp: i,
      dataProp: i
    }, valid2));
    cxt.ok(valid2);
  });
  function checkStrictTuple(sch) {
    const { opts, errSchemaPath } = it;
    const l = schArr.length;
    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
    if (opts.strictTuples && !fullTuple) {
      const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
      (0, util_1$c.checkStrictMode)(it, msg, opts.strictTuples);
    }
  }
}
items.validateTuple = validateTuple;
items.default = def$f;
Object.defineProperty(prefixItems, "__esModule", { value: true });
const items_1$1 = items;
const def$e = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (cxt) => (0, items_1$1.validateTuple)(cxt, "items")
};
prefixItems.default = def$e;
var items2020 = {};
Object.defineProperty(items2020, "__esModule", { value: true });
const codegen_1$8 = codegen;
const util_1$b = util;
const code_1$4 = code;
const additionalItems_1$1 = additionalItems;
const error$7 = {
  message: ({ params: { len } }) => (0, codegen_1$8.str)`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => (0, codegen_1$8._)`{limit: ${len}}`
};
const def$d = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: error$7,
  code(cxt) {
    const { schema, parentSchema, it } = cxt;
    const { prefixItems: prefixItems2 } = parentSchema;
    it.items = true;
    if ((0, util_1$b.alwaysValidSchema)(it, schema))
      return;
    if (prefixItems2)
      (0, additionalItems_1$1.validateAdditionalItems)(cxt, prefixItems2);
    else
      cxt.ok((0, code_1$4.validateArray)(cxt));
  }
};
items2020.default = def$d;
var contains = {};
Object.defineProperty(contains, "__esModule", { value: true });
const codegen_1$7 = codegen;
const util_1$a = util;
const error$6 = {
  message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$7.str)`must contain at least ${min} valid item(s)` : (0, codegen_1$7.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
  params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$7._)`{minContains: ${min}}` : (0, codegen_1$7._)`{minContains: ${min}, maxContains: ${max}}`
};
const def$c = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: true,
  error: error$6,
  code(cxt) {
    const { gen, schema, parentSchema, data, it } = cxt;
    let min;
    let max;
    const { minContains, maxContains } = parentSchema;
    if (it.opts.next) {
      min = minContains === void 0 ? 1 : minContains;
      max = maxContains;
    } else {
      min = 1;
    }
    const len = gen.const("len", (0, codegen_1$7._)`${data}.length`);
    cxt.setParams({ min, max });
    if (max === void 0 && min === 0) {
      (0, util_1$a.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
      return;
    }
    if (max !== void 0 && min > max) {
      (0, util_1$a.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
      cxt.fail();
      return;
    }
    if ((0, util_1$a.alwaysValidSchema)(it, schema)) {
      let cond = (0, codegen_1$7._)`${len} >= ${min}`;
      if (max !== void 0)
        cond = (0, codegen_1$7._)`${cond} && ${len} <= ${max}`;
      cxt.pass(cond);
      return;
    }
    it.items = true;
    const valid2 = gen.name("valid");
    if (max === void 0 && min === 1) {
      validateItems(valid2, () => gen.if(valid2, () => gen.break()));
    } else if (min === 0) {
      gen.let(valid2, true);
      if (max !== void 0)
        gen.if((0, codegen_1$7._)`${data}.length > 0`, validateItemsWithCount);
    } else {
      gen.let(valid2, false);
      validateItemsWithCount();
    }
    cxt.result(valid2, () => cxt.reset());
    function validateItemsWithCount() {
      const schValid = gen.name("_valid");
      const count = gen.let("count", 0);
      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
    }
    function validateItems(_valid, block) {
      gen.forRange("i", 0, len, (i) => {
        cxt.subschema({
          keyword: "contains",
          dataProp: i,
          dataPropType: util_1$a.Type.Num,
          compositeRule: true
        }, _valid);
        block();
      });
    }
    function checkLimits(count) {
      gen.code((0, codegen_1$7._)`${count}++`);
      if (max === void 0) {
        gen.if((0, codegen_1$7._)`${count} >= ${min}`, () => gen.assign(valid2, true).break());
      } else {
        gen.if((0, codegen_1$7._)`${count} > ${max}`, () => gen.assign(valid2, false).break());
        if (min === 1)
          gen.assign(valid2, true);
        else
          gen.if((0, codegen_1$7._)`${count} >= ${min}`, () => gen.assign(valid2, true));
      }
    }
  }
};
contains.default = def$c;
var dependencies = {};
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.validateSchemaDeps = exports$1.validatePropertyDeps = exports$1.error = void 0;
  const codegen_12 = codegen;
  const util_12 = util;
  const code_12 = code;
  exports$1.error = {
    message: ({ params: { property, depsCount, deps } }) => {
      const property_ies = depsCount === 1 ? "property" : "properties";
      return (0, codegen_12.str)`must have ${property_ies} ${deps} when property ${property} is present`;
    },
    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_12._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
    // TODO change to reference
  };
  const def2 = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports$1.error,
    code(cxt) {
      const [propDeps, schDeps] = splitDependencies(cxt);
      validatePropertyDeps(cxt, propDeps);
      validateSchemaDeps(cxt, schDeps);
    }
  };
  function splitDependencies({ schema }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key2 in schema) {
      if (key2 === "__proto__")
        continue;
      const deps = Array.isArray(schema[key2]) ? propertyDeps : schemaDeps;
      deps[key2] = schema[key2];
    }
    return [propertyDeps, schemaDeps];
  }
  function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
    const { gen, data, it } = cxt;
    if (Object.keys(propertyDeps).length === 0)
      return;
    const missing = gen.let("missing");
    for (const prop in propertyDeps) {
      const deps = propertyDeps[prop];
      if (deps.length === 0)
        continue;
      const hasProperty = (0, code_12.propertyInData)(gen, data, prop, it.opts.ownProperties);
      cxt.setParams({
        property: prop,
        depsCount: deps.length,
        deps: deps.join(", ")
      });
      if (it.allErrors) {
        gen.if(hasProperty, () => {
          for (const depProp of deps) {
            (0, code_12.checkReportMissingProp)(cxt, depProp);
          }
        });
      } else {
        gen.if((0, codegen_12._)`${hasProperty} && (${(0, code_12.checkMissingProp)(cxt, deps, missing)})`);
        (0, code_12.reportMissingProp)(cxt, missing);
        gen.else();
      }
    }
  }
  exports$1.validatePropertyDeps = validatePropertyDeps;
  function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
    const { gen, data, keyword: keyword2, it } = cxt;
    const valid2 = gen.name("valid");
    for (const prop in schemaDeps) {
      if ((0, util_12.alwaysValidSchema)(it, schemaDeps[prop]))
        continue;
      gen.if(
        (0, code_12.propertyInData)(gen, data, prop, it.opts.ownProperties),
        () => {
          const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid2);
          cxt.mergeValidEvaluated(schCxt, valid2);
        },
        () => gen.var(valid2, true)
        // TODO var
      );
      cxt.ok(valid2);
    }
  }
  exports$1.validateSchemaDeps = validateSchemaDeps;
  exports$1.default = def2;
})(dependencies);
var propertyNames = {};
Object.defineProperty(propertyNames, "__esModule", { value: true });
const codegen_1$6 = codegen;
const util_1$9 = util;
const error$5 = {
  message: "property name must be valid",
  params: ({ params }) => (0, codegen_1$6._)`{propertyName: ${params.propertyName}}`
};
const def$b = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: error$5,
  code(cxt) {
    const { gen, schema, data, it } = cxt;
    if ((0, util_1$9.alwaysValidSchema)(it, schema))
      return;
    const valid2 = gen.name("valid");
    gen.forIn("key", data, (key2) => {
      cxt.setParams({ propertyName: key2 });
      cxt.subschema({
        keyword: "propertyNames",
        data: key2,
        dataTypes: ["string"],
        propertyName: key2,
        compositeRule: true
      }, valid2);
      gen.if((0, codegen_1$6.not)(valid2), () => {
        cxt.error(true);
        if (!it.allErrors)
          gen.break();
      });
    });
    cxt.ok(valid2);
  }
};
propertyNames.default = def$b;
var additionalProperties = {};
Object.defineProperty(additionalProperties, "__esModule", { value: true });
const code_1$3 = code;
const codegen_1$5 = codegen;
const names_1 = names$1;
const util_1$8 = util;
const error$4 = {
  message: "must NOT have additional properties",
  params: ({ params }) => (0, codegen_1$5._)`{additionalProperty: ${params.additionalProperty}}`
};
const def$a = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: true,
  trackErrors: true,
  error: error$4,
  code(cxt) {
    const { gen, schema, parentSchema, data, errsCount, it } = cxt;
    if (!errsCount)
      throw new Error("ajv implementation error");
    const { allErrors, opts } = it;
    it.props = true;
    if (opts.removeAdditional !== "all" && (0, util_1$8.alwaysValidSchema)(it, schema))
      return;
    const props = (0, code_1$3.allSchemaProperties)(parentSchema.properties);
    const patProps = (0, code_1$3.allSchemaProperties)(parentSchema.patternProperties);
    checkAdditionalProperties();
    cxt.ok((0, codegen_1$5._)`${errsCount} === ${names_1.default.errors}`);
    function checkAdditionalProperties() {
      gen.forIn("key", data, (key2) => {
        if (!props.length && !patProps.length)
          additionalPropertyCode(key2);
        else
          gen.if(isAdditional(key2), () => additionalPropertyCode(key2));
      });
    }
    function isAdditional(key2) {
      let definedProp;
      if (props.length > 8) {
        const propsSchema = (0, util_1$8.schemaRefOrVal)(it, parentSchema.properties, "properties");
        definedProp = (0, code_1$3.isOwnProperty)(gen, propsSchema, key2);
      } else if (props.length) {
        definedProp = (0, codegen_1$5.or)(...props.map((p) => (0, codegen_1$5._)`${key2} === ${p}`));
      } else {
        definedProp = codegen_1$5.nil;
      }
      if (patProps.length) {
        definedProp = (0, codegen_1$5.or)(definedProp, ...patProps.map((p) => (0, codegen_1$5._)`${(0, code_1$3.usePattern)(cxt, p)}.test(${key2})`));
      }
      return (0, codegen_1$5.not)(definedProp);
    }
    function deleteAdditional(key2) {
      gen.code((0, codegen_1$5._)`delete ${data}[${key2}]`);
    }
    function additionalPropertyCode(key2) {
      if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
        deleteAdditional(key2);
        return;
      }
      if (schema === false) {
        cxt.setParams({ additionalProperty: key2 });
        cxt.error();
        if (!allErrors)
          gen.break();
        return;
      }
      if (typeof schema == "object" && !(0, util_1$8.alwaysValidSchema)(it, schema)) {
        const valid2 = gen.name("valid");
        if (opts.removeAdditional === "failing") {
          applyAdditionalSchema(key2, valid2, false);
          gen.if((0, codegen_1$5.not)(valid2), () => {
            cxt.reset();
            deleteAdditional(key2);
          });
        } else {
          applyAdditionalSchema(key2, valid2);
          if (!allErrors)
            gen.if((0, codegen_1$5.not)(valid2), () => gen.break());
        }
      }
    }
    function applyAdditionalSchema(key2, valid2, errors2) {
      const subschema2 = {
        keyword: "additionalProperties",
        dataProp: key2,
        dataPropType: util_1$8.Type.Str
      };
      if (errors2 === false) {
        Object.assign(subschema2, {
          compositeRule: true,
          createErrors: false,
          allErrors: false
        });
      }
      cxt.subschema(subschema2, valid2);
    }
  }
};
additionalProperties.default = def$a;
var properties$1 = {};
Object.defineProperty(properties$1, "__esModule", { value: true });
const validate_1 = validate;
const code_1$2 = code;
const util_1$7 = util;
const additionalProperties_1$1 = additionalProperties;
const def$9 = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema, parentSchema, data, it } = cxt;
    if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
      additionalProperties_1$1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1$1.default, "additionalProperties"));
    }
    const allProps = (0, code_1$2.allSchemaProperties)(schema);
    for (const prop of allProps) {
      it.definedProperties.add(prop);
    }
    if (it.opts.unevaluated && allProps.length && it.props !== true) {
      it.props = util_1$7.mergeEvaluated.props(gen, (0, util_1$7.toHash)(allProps), it.props);
    }
    const properties2 = allProps.filter((p) => !(0, util_1$7.alwaysValidSchema)(it, schema[p]));
    if (properties2.length === 0)
      return;
    const valid2 = gen.name("valid");
    for (const prop of properties2) {
      if (hasDefault(prop)) {
        applyPropertySchema(prop);
      } else {
        gen.if((0, code_1$2.propertyInData)(gen, data, prop, it.opts.ownProperties));
        applyPropertySchema(prop);
        if (!it.allErrors)
          gen.else().var(valid2, true);
        gen.endIf();
      }
      cxt.it.definedProperties.add(prop);
      cxt.ok(valid2);
    }
    function hasDefault(prop) {
      return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
    }
    function applyPropertySchema(prop) {
      cxt.subschema({
        keyword: "properties",
        schemaProp: prop,
        dataProp: prop
      }, valid2);
    }
  }
};
properties$1.default = def$9;
var patternProperties = {};
Object.defineProperty(patternProperties, "__esModule", { value: true });
const code_1$1 = code;
const codegen_1$4 = codegen;
const util_1$6 = util;
const util_2 = util;
const def$8 = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema, data, parentSchema, it } = cxt;
    const { opts } = it;
    const patterns = (0, code_1$1.allSchemaProperties)(schema);
    const alwaysValidPatterns = patterns.filter((p) => (0, util_1$6.alwaysValidSchema)(it, schema[p]));
    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
      return;
    }
    const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
    const valid2 = gen.name("valid");
    if (it.props !== true && !(it.props instanceof codegen_1$4.Name)) {
      it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
    }
    const { props } = it;
    validatePatternProperties();
    function validatePatternProperties() {
      for (const pat of patterns) {
        if (checkProperties)
          checkMatchingProperties(pat);
        if (it.allErrors) {
          validateProperties(pat);
        } else {
          gen.var(valid2, true);
          validateProperties(pat);
          gen.if(valid2);
        }
      }
    }
    function checkMatchingProperties(pat) {
      for (const prop in checkProperties) {
        if (new RegExp(pat).test(prop)) {
          (0, util_1$6.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
        }
      }
    }
    function validateProperties(pat) {
      gen.forIn("key", data, (key2) => {
        gen.if((0, codegen_1$4._)`${(0, code_1$1.usePattern)(cxt, pat)}.test(${key2})`, () => {
          const alwaysValid = alwaysValidPatterns.includes(pat);
          if (!alwaysValid) {
            cxt.subschema({
              keyword: "patternProperties",
              schemaProp: pat,
              dataProp: key2,
              dataPropType: util_2.Type.Str
            }, valid2);
          }
          if (it.opts.unevaluated && props !== true) {
            gen.assign((0, codegen_1$4._)`${props}[${key2}]`, true);
          } else if (!alwaysValid && !it.allErrors) {
            gen.if((0, codegen_1$4.not)(valid2), () => gen.break());
          }
        });
      });
    }
  }
};
patternProperties.default = def$8;
var not = {};
Object.defineProperty(not, "__esModule", { value: true });
const util_1$5 = util;
const def$7 = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  code(cxt) {
    const { gen, schema, it } = cxt;
    if ((0, util_1$5.alwaysValidSchema)(it, schema)) {
      cxt.fail();
      return;
    }
    const valid2 = gen.name("valid");
    cxt.subschema({
      keyword: "not",
      compositeRule: true,
      createErrors: false,
      allErrors: false
    }, valid2);
    cxt.failResult(valid2, () => cxt.reset(), () => cxt.error());
  },
  error: { message: "must NOT be valid" }
};
not.default = def$7;
var anyOf = {};
Object.defineProperty(anyOf, "__esModule", { value: true });
const code_1 = code;
const def$6 = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: true,
  code: code_1.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
anyOf.default = def$6;
var oneOf$1 = {};
Object.defineProperty(oneOf$1, "__esModule", { value: true });
const codegen_1$3 = codegen;
const util_1$4 = util;
const error$3 = {
  message: "must match exactly one schema in oneOf",
  params: ({ params }) => (0, codegen_1$3._)`{passingSchemas: ${params.passing}}`
};
const def$5 = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: true,
  error: error$3,
  code(cxt) {
    const { gen, schema, parentSchema, it } = cxt;
    if (!Array.isArray(schema))
      throw new Error("ajv implementation error");
    if (it.opts.discriminator && parentSchema.discriminator)
      return;
    const schArr = schema;
    const valid2 = gen.let("valid", false);
    const passing = gen.let("passing", null);
    const schValid = gen.name("_valid");
    cxt.setParams({ passing });
    gen.block(validateOneOf);
    cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
    function validateOneOf() {
      schArr.forEach((sch, i) => {
        let schCxt;
        if ((0, util_1$4.alwaysValidSchema)(it, sch)) {
          gen.var(schValid, true);
        } else {
          schCxt = cxt.subschema({
            keyword: "oneOf",
            schemaProp: i,
            compositeRule: true
          }, schValid);
        }
        if (i > 0) {
          gen.if((0, codegen_1$3._)`${schValid} && ${valid2}`).assign(valid2, false).assign(passing, (0, codegen_1$3._)`[${passing}, ${i}]`).else();
        }
        gen.if(schValid, () => {
          gen.assign(valid2, true);
          gen.assign(passing, i);
          if (schCxt)
            cxt.mergeEvaluated(schCxt, codegen_1$3.Name);
        });
      });
    }
  }
};
oneOf$1.default = def$5;
var allOf = {};
Object.defineProperty(allOf, "__esModule", { value: true });
const util_1$3 = util;
const def$4 = {
  keyword: "allOf",
  schemaType: "array",
  code(cxt) {
    const { gen, schema, it } = cxt;
    if (!Array.isArray(schema))
      throw new Error("ajv implementation error");
    const valid2 = gen.name("valid");
    schema.forEach((sch, i) => {
      if ((0, util_1$3.alwaysValidSchema)(it, sch))
        return;
      const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid2);
      cxt.ok(valid2);
      cxt.mergeEvaluated(schCxt);
    });
  }
};
allOf.default = def$4;
var _if = {};
Object.defineProperty(_if, "__esModule", { value: true });
const codegen_1$2 = codegen;
const util_1$2 = util;
const error$2 = {
  message: ({ params }) => (0, codegen_1$2.str)`must match "${params.ifClause}" schema`,
  params: ({ params }) => (0, codegen_1$2._)`{failingKeyword: ${params.ifClause}}`
};
const def$3 = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  error: error$2,
  code(cxt) {
    const { gen, parentSchema, it } = cxt;
    if (parentSchema.then === void 0 && parentSchema.else === void 0) {
      (0, util_1$2.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
    }
    const hasThen = hasSchema(it, "then");
    const hasElse = hasSchema(it, "else");
    if (!hasThen && !hasElse)
      return;
    const valid2 = gen.let("valid", true);
    const schValid = gen.name("_valid");
    validateIf();
    cxt.reset();
    if (hasThen && hasElse) {
      const ifClause = gen.let("ifClause");
      cxt.setParams({ ifClause });
      gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
    } else if (hasThen) {
      gen.if(schValid, validateClause("then"));
    } else {
      gen.if((0, codegen_1$2.not)(schValid), validateClause("else"));
    }
    cxt.pass(valid2, () => cxt.error(true));
    function validateIf() {
      const schCxt = cxt.subschema({
        keyword: "if",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, schValid);
      cxt.mergeEvaluated(schCxt);
    }
    function validateClause(keyword2, ifClause) {
      return () => {
        const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
        gen.assign(valid2, schValid);
        cxt.mergeValidEvaluated(schCxt, valid2);
        if (ifClause)
          gen.assign(ifClause, (0, codegen_1$2._)`${keyword2}`);
        else
          cxt.setParams({ ifClause: keyword2 });
      };
    }
  }
};
function hasSchema(it, keyword2) {
  const schema = it.schema[keyword2];
  return schema !== void 0 && !(0, util_1$2.alwaysValidSchema)(it, schema);
}
_if.default = def$3;
var thenElse = {};
Object.defineProperty(thenElse, "__esModule", { value: true });
const util_1$1 = util;
const def$2 = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: keyword2, parentSchema, it }) {
    if (parentSchema.if === void 0)
      (0, util_1$1.checkStrictMode)(it, `"${keyword2}" without "if" is ignored`);
  }
};
thenElse.default = def$2;
Object.defineProperty(applicator, "__esModule", { value: true });
const additionalItems_1 = additionalItems;
const prefixItems_1 = prefixItems;
const items_1 = items;
const items2020_1 = items2020;
const contains_1 = contains;
const dependencies_1 = dependencies;
const propertyNames_1 = propertyNames;
const additionalProperties_1 = additionalProperties;
const properties_1 = properties$1;
const patternProperties_1 = patternProperties;
const not_1 = not;
const anyOf_1 = anyOf;
const oneOf_1 = oneOf$1;
const allOf_1 = allOf;
const if_1 = _if;
const thenElse_1 = thenElse;
function getApplicator(draft2020 = false) {
  const applicator2 = [
    // any
    not_1.default,
    anyOf_1.default,
    oneOf_1.default,
    allOf_1.default,
    if_1.default,
    thenElse_1.default,
    // object
    propertyNames_1.default,
    additionalProperties_1.default,
    dependencies_1.default,
    properties_1.default,
    patternProperties_1.default
  ];
  if (draft2020)
    applicator2.push(prefixItems_1.default, items2020_1.default);
  else
    applicator2.push(additionalItems_1.default, items_1.default);
  applicator2.push(contains_1.default);
  return applicator2;
}
applicator.default = getApplicator;
var format$2 = {};
var format$1 = {};
Object.defineProperty(format$1, "__esModule", { value: true });
const codegen_1$1 = codegen;
const error$1 = {
  message: ({ schemaCode }) => (0, codegen_1$1.str)`must match format "${schemaCode}"`,
  params: ({ schemaCode }) => (0, codegen_1$1._)`{format: ${schemaCode}}`
};
const def$1 = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: true,
  error: error$1,
  code(cxt, ruleType) {
    const { gen, data, $data, schema, schemaCode, it } = cxt;
    const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
    if (!opts.validateFormats)
      return;
    if ($data)
      validate$DataFormat();
    else
      validateFormat();
    function validate$DataFormat() {
      const fmts = gen.scopeValue("formats", {
        ref: self2.formats,
        code: opts.code.formats
      });
      const fDef = gen.const("fDef", (0, codegen_1$1._)`${fmts}[${schemaCode}]`);
      const fType = gen.let("fType");
      const format2 = gen.let("format");
      gen.if((0, codegen_1$1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1$1._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1$1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1$1._)`"string"`).assign(format2, fDef));
      cxt.fail$data((0, codegen_1$1.or)(unknownFmt(), invalidFmt()));
      function unknownFmt() {
        if (opts.strictSchema === false)
          return codegen_1$1.nil;
        return (0, codegen_1$1._)`${schemaCode} && !${format2}`;
      }
      function invalidFmt() {
        const callFormat = schemaEnv.$async ? (0, codegen_1$1._)`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : (0, codegen_1$1._)`${format2}(${data})`;
        const validData = (0, codegen_1$1._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
        return (0, codegen_1$1._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
      }
    }
    function validateFormat() {
      const formatDef = self2.formats[schema];
      if (!formatDef) {
        unknownFormat();
        return;
      }
      if (formatDef === true)
        return;
      const [fmtType, format2, fmtRef] = getFormat(formatDef);
      if (fmtType === ruleType)
        cxt.pass(validCondition());
      function unknownFormat() {
        if (opts.strictSchema === false) {
          self2.logger.warn(unknownMsg());
          return;
        }
        throw new Error(unknownMsg());
        function unknownMsg() {
          return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
        }
      }
      function getFormat(fmtDef) {
        const code2 = fmtDef instanceof RegExp ? (0, codegen_1$1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1$1._)`${opts.code.formats}${(0, codegen_1$1.getProperty)(schema)}` : void 0;
        const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code: code2 });
        if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
          return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1$1._)`${fmt}.validate`];
        }
        return ["string", fmtDef, fmt];
      }
      function validCondition() {
        if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
          if (!schemaEnv.$async)
            throw new Error("async format in sync schema");
          return (0, codegen_1$1._)`await ${fmtRef}(${data})`;
        }
        return typeof format2 == "function" ? (0, codegen_1$1._)`${fmtRef}(${data})` : (0, codegen_1$1._)`${fmtRef}.test(${data})`;
      }
    }
  }
};
format$1.default = def$1;
Object.defineProperty(format$2, "__esModule", { value: true });
const format_1$1 = format$1;
const format = [format_1$1.default];
format$2.default = format;
var metadata = {};
Object.defineProperty(metadata, "__esModule", { value: true });
metadata.contentVocabulary = metadata.metadataVocabulary = void 0;
metadata.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
metadata.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(draft7, "__esModule", { value: true });
const core_1 = core$1;
const validation_1 = validation$1;
const applicator_1 = applicator;
const format_1 = format$2;
const metadata_1 = metadata;
const draft7Vocabularies = [
  core_1.default,
  validation_1.default,
  (0, applicator_1.default)(),
  format_1.default,
  metadata_1.metadataVocabulary,
  metadata_1.contentVocabulary
];
draft7.default = draft7Vocabularies;
var discriminator = {};
var types$1 = {};
Object.defineProperty(types$1, "__esModule", { value: true });
types$1.DiscrError = void 0;
var DiscrError;
(function(DiscrError2) {
  DiscrError2["Tag"] = "tag";
  DiscrError2["Mapping"] = "mapping";
})(DiscrError || (types$1.DiscrError = DiscrError = {}));
Object.defineProperty(discriminator, "__esModule", { value: true });
const codegen_1 = codegen;
const types_1 = types$1;
const compile_1 = compile;
const ref_error_1 = ref_error;
const util_1 = util;
const error = {
  message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
  params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
};
const def = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error,
  code(cxt) {
    const { gen, data, schema, parentSchema, it } = cxt;
    const { oneOf: oneOf2 } = parentSchema;
    if (!it.opts.discriminator) {
      throw new Error("discriminator: requires discriminator option");
    }
    const tagName = schema.propertyName;
    if (typeof tagName != "string")
      throw new Error("discriminator: requires propertyName");
    if (schema.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!oneOf2)
      throw new Error("discriminator: requires oneOf keyword");
    const valid2 = gen.let("valid", false);
    const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
    gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
    cxt.ok(valid2);
    function validateMapping() {
      const mapping = getMapping();
      gen.if(false);
      for (const tagValue in mapping) {
        gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
        gen.assign(valid2, applyTagSchema(mapping[tagValue]));
      }
      gen.else();
      cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
      gen.endIf();
    }
    function applyTagSchema(schemaProp) {
      const _valid = gen.name("valid");
      const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
      cxt.mergeEvaluated(schCxt, codegen_1.Name);
      return _valid;
    }
    function getMapping() {
      var _a;
      const oneOfMapping = {};
      const topRequired = hasRequired(parentSchema);
      let tagRequired = true;
      for (let i = 0; i < oneOf2.length; i++) {
        let sch = oneOf2[i];
        if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
          const ref2 = sch.$ref;
          sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref2);
          if (sch instanceof compile_1.SchemaEnv)
            sch = sch.schema;
          if (sch === void 0)
            throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref2);
        }
        const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
        if (typeof propSch != "object") {
          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
        }
        tagRequired = tagRequired && (topRequired || hasRequired(sch));
        addMappings(propSch, i);
      }
      if (!tagRequired)
        throw new Error(`discriminator: "${tagName}" must be required`);
      return oneOfMapping;
      function hasRequired({ required: required2 }) {
        return Array.isArray(required2) && required2.includes(tagName);
      }
      function addMappings(sch, i) {
        if (sch.const) {
          addMapping(sch.const, i);
        } else if (sch.enum) {
          for (const tagValue of sch.enum) {
            addMapping(tagValue, i);
          }
        } else {
          throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
        }
      }
      function addMapping(tagValue, i) {
        if (typeof tagValue != "string" || tagValue in oneOfMapping) {
          throw new Error(`discriminator: "${tagName}" values must be unique strings`);
        }
        oneOfMapping[tagValue] = i;
      }
    }
  }
};
discriminator.default = def;
const $schema = "http://json-schema.org/draft-07/schema#";
const $id = "http://json-schema.org/draft-07/schema#";
const title = "Core schema meta-schema";
const definitions = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        "default": 0
      }
    ]
  },
  simpleTypes: {
    "enum": [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: true,
    "default": []
  }
};
const type = [
  "object",
  "boolean"
];
const properties = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  "default": true,
  readOnly: {
    type: "boolean",
    "default": false
  },
  examples: {
    type: "array",
    items: true
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    "default": true
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    "default": false
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    "default": {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  "const": true,
  "enum": {
    type: "array",
    items: true,
    minItems: 1,
    uniqueItems: true
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: true
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  "if": {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  "else": {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
};
const require$$3 = {
  $schema,
  $id,
  title,
  definitions,
  type,
  properties,
  "default": true
};
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.MissingRefError = exports$1.ValidationError = exports$1.CodeGen = exports$1.Name = exports$1.nil = exports$1.stringify = exports$1.str = exports$1._ = exports$1.KeywordCxt = exports$1.Ajv = void 0;
  const core_12 = core$2;
  const draft7_1 = draft7;
  const discriminator_1 = discriminator;
  const draft7MetaSchema = require$$3;
  const META_SUPPORT_DATA = ["/properties"];
  const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
  class Ajv extends core_12.default {
    _addVocabularies() {
      super._addVocabularies();
      draft7_1.default.forEach((v) => this.addVocabulary(v));
      if (this.opts.discriminator)
        this.addKeyword(discriminator_1.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      if (!this.opts.meta)
        return;
      const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
      this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
      this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
    }
  }
  exports$1.Ajv = Ajv;
  module2.exports = exports$1 = Ajv;
  module2.exports.Ajv = Ajv;
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.default = Ajv;
  var validate_12 = validate;
  Object.defineProperty(exports$1, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports$1, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports$1, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports$1, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports$1, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports$1, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports$1, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  var validation_error_12 = validation_error;
  Object.defineProperty(exports$1, "ValidationError", { enumerable: true, get: function() {
    return validation_error_12.default;
  } });
  var ref_error_12 = ref_error;
  Object.defineProperty(exports$1, "MissingRefError", { enumerable: true, get: function() {
    return ref_error_12.default;
  } });
})(ajv, ajv.exports);
var ajvExports = ajv.exports;
(function(exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.formatLimitDefinition = void 0;
  const ajv_1 = ajvExports;
  const codegen_12 = codegen;
  const ops2 = codegen_12.operators;
  const KWDs2 = {
    formatMaximum: { okStr: "<=", ok: ops2.LTE, fail: ops2.GT },
    formatMinimum: { okStr: ">=", ok: ops2.GTE, fail: ops2.LT },
    formatExclusiveMaximum: { okStr: "<", ok: ops2.LT, fail: ops2.GTE },
    formatExclusiveMinimum: { okStr: ">", ok: ops2.GT, fail: ops2.LTE }
  };
  const error2 = {
    message: ({ keyword: keyword2, schemaCode }) => codegen_12.str`should be ${KWDs2[keyword2].okStr} ${schemaCode}`,
    params: ({ keyword: keyword2, schemaCode }) => codegen_12._`{comparison: ${KWDs2[keyword2].okStr}, limit: ${schemaCode}}`
  };
  exports$1.formatLimitDefinition = {
    keyword: Object.keys(KWDs2),
    type: "string",
    schemaType: "string",
    $data: true,
    error: error2,
    code(cxt) {
      const { gen, data, schemaCode, keyword: keyword2, it } = cxt;
      const { opts, self: self2 } = it;
      if (!opts.validateFormats)
        return;
      const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
      if (fCxt.$data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen.scopeValue("formats", {
          ref: self2.formats,
          code: opts.code.formats
        });
        const fmt = gen.const("fmt", codegen_12._`${fmts}[${fCxt.schemaCode}]`);
        cxt.fail$data(codegen_12.or(codegen_12._`typeof ${fmt} != "object"`, codegen_12._`${fmt} instanceof RegExp`, codegen_12._`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
      }
      function validateFormat() {
        const format2 = fCxt.schema;
        const fmtDef = self2.formats[format2];
        if (!fmtDef || fmtDef === true)
          return;
        if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
          throw new Error(`"${keyword2}": format "${format2}" does not define "compare" function`);
        }
        const fmt = gen.scopeValue("formats", {
          key: format2,
          ref: fmtDef,
          code: opts.code.formats ? codegen_12._`${opts.code.formats}${codegen_12.getProperty(format2)}` : void 0
        });
        cxt.fail$data(compareCode(fmt));
      }
      function compareCode(fmt) {
        return codegen_12._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs2[keyword2].fail} 0`;
      }
    },
    dependencies: ["format"]
  };
  const formatLimitPlugin = (ajv2) => {
    ajv2.addKeyword(exports$1.formatLimitDefinition);
    return ajv2;
  };
  exports$1.default = formatLimitPlugin;
})(limit);
(function(module2, exports$1) {
  Object.defineProperty(exports$1, "__esModule", { value: true });
  const formats_1 = formats;
  const limit_1 = limit;
  const codegen_12 = codegen;
  const fullName = new codegen_12.Name("fullFormats");
  const fastName = new codegen_12.Name("fastFormats");
  const formatsPlugin = (ajv2, opts = { keywords: true }) => {
    if (Array.isArray(opts)) {
      addFormats(ajv2, opts, formats_1.fullFormats, fullName);
      return ajv2;
    }
    const [formats2, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
    const list = opts.formats || formats_1.formatNames;
    addFormats(ajv2, list, formats2, exportName);
    if (opts.keywords)
      limit_1.default(ajv2);
    return ajv2;
  };
  formatsPlugin.get = (name, mode = "full") => {
    const formats2 = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
    const f = formats2[name];
    if (!f)
      throw new Error(`Unknown format "${name}"`);
    return f;
  };
  function addFormats(ajv2, list, fs2, exportName) {
    var _a;
    var _b;
    (_a = (_b = ajv2.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = codegen_12._`require("ajv-formats/dist/formats").${exportName}`;
    for (const f of list)
      ajv2.addFormat(f, fs2[f]);
  }
  module2.exports = exports$1 = formatsPlugin;
  Object.defineProperty(exports$1, "__esModule", { value: true });
  exports$1.default = formatsPlugin;
})(dist, dist.exports);
var distExports = dist.exports;
const copyProperty = (to, from, property, ignoreNonConfigurable) => {
  if (property === "length" || property === "prototype") {
    return;
  }
  if (property === "arguments" || property === "caller") {
    return;
  }
  const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
  const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
    return;
  }
  Object.defineProperty(to, property, fromDescriptor);
};
const canCopyProperty = function(toDescriptor, fromDescriptor) {
  return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
};
const changePrototype = (to, from) => {
  const fromPrototype = Object.getPrototypeOf(from);
  if (fromPrototype === Object.getPrototypeOf(to)) {
    return;
  }
  Object.setPrototypeOf(to, fromPrototype);
};
const wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
const toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
const toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
const changeToString = (to, from, name) => {
  const withName = name === "" ? "" : `with ${name.trim()}() `;
  const newToString = wrappedToString.bind(null, withName, from.toString());
  Object.defineProperty(newToString, "name", toStringName);
  Object.defineProperty(to, "toString", { ...toStringDescriptor, value: newToString });
};
const mimicFn$4 = (to, from, { ignoreNonConfigurable = false } = {}) => {
  const { name } = to;
  for (const property of Reflect.ownKeys(from)) {
    copyProperty(to, from, property, ignoreNonConfigurable);
  }
  changePrototype(to, from);
  changeToString(to, from, name);
  return to;
};
var mimicFn_1 = mimicFn$4;
const mimicFn$3 = mimicFn_1;
var debounceFn = (inputFunction, options = {}) => {
  if (typeof inputFunction !== "function") {
    throw new TypeError(`Expected the first argument to be a function, got \`${typeof inputFunction}\``);
  }
  const {
    wait = 0,
    before = false,
    after = true
  } = options;
  if (!before && !after) {
    throw new Error("Both `before` and `after` are false, function wouldn't be called.");
  }
  let timeout;
  let result;
  const debouncedFunction = function(...arguments_) {
    const context = this;
    const later = () => {
      timeout = void 0;
      if (after) {
        result = inputFunction.apply(context, arguments_);
      }
    };
    const shouldCallNow = before && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (shouldCallNow) {
      result = inputFunction.apply(context, arguments_);
    }
    return result;
  };
  mimicFn$3(debouncedFunction, inputFunction);
  debouncedFunction.cancel = () => {
    if (timeout) {
      clearTimeout(timeout);
      timeout = void 0;
    }
  };
  return debouncedFunction;
};
var re$2 = { exports: {} };
const SEMVER_SPEC_VERSION = "2.0.0";
const MAX_LENGTH$1 = 256;
const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991;
const MAX_SAFE_COMPONENT_LENGTH = 16;
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH$1 - 6;
const RELEASE_TYPES = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var constants$3 = {
  MAX_LENGTH: MAX_LENGTH$1,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const debug$1 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
};
var debug_1 = debug$1;
(function(module2, exports$1) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2,
    MAX_SAFE_BUILD_LENGTH: MAX_SAFE_BUILD_LENGTH2,
    MAX_LENGTH: MAX_LENGTH2
  } = constants$3;
  const debug2 = debug_1;
  exports$1 = module2.exports = {};
  const re2 = exports$1.re = [];
  const safeRe = exports$1.safeRe = [];
  const src = exports$1.src = [];
  const safeSrc = exports$1.safeSrc = [];
  const t2 = exports$1.t = {};
  let R = 0;
  const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  const safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH2],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH2]
  ];
  const makeSafeRegex = (value) => {
    for (const [token, max] of safeRegexReplacements) {
      value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value;
  };
  const createToken = (name, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index = R++;
    debug2(name, index, value);
    t2[name] = index;
    src[index] = value;
    safeSrc[index] = safe;
    re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NONNUMERICIDENTIFIER]}|${src[t2.NUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NONNUMERICIDENTIFIER]}|${src[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`);
  createToken("FULL", `^${src[t2.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`);
  createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?`);
  createToken("COERCE", `${src[t2.COERCEPLAIN]}(?:$|[^\\d])`);
  createToken("COERCEFULL", src[t2.COERCEPLAIN] + `(?:${src[t2.PRERELEASE]})?(?:${src[t2.BUILD]})?(?:$|[^\\d])`);
  createToken("COERCERTL", src[t2.COERCE], true);
  createToken("COERCERTLFULL", src[t2.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true);
  exports$1.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true);
  exports$1.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true);
  exports$1.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(re$2, re$2.exports);
var reExports = re$2.exports;
const looseOption = Object.freeze({ loose: true });
const emptyOpts = Object.freeze({});
const parseOptions$1 = (options) => {
  if (!options) {
    return emptyOpts;
  }
  if (typeof options !== "object") {
    return looseOption;
  }
  return options;
};
var parseOptions_1 = parseOptions$1;
const numeric = /^[0-9]+$/;
const compareIdentifiers$1 = (a, b) => {
  if (typeof a === "number" && typeof b === "number") {
    return a === b ? 0 : a < b ? -1 : 1;
  }
  const anum = numeric.test(a);
  const bnum = numeric.test(b);
  if (anum && bnum) {
    a = +a;
    b = +b;
  }
  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);
var identifiers$1 = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
const debug = debug_1;
const { MAX_LENGTH, MAX_SAFE_INTEGER } = constants$3;
const { safeRe: re$1, t: t$1 } = reExports;
const parseOptions = parseOptions_1;
const { compareIdentifiers } = identifiers$1;
let SemVer$d = class SemVer {
  constructor(version2, options) {
    options = parseOptions(options);
    if (version2 instanceof SemVer) {
      if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
        return version2;
      } else {
        version2 = version2.version;
      }
    } else if (typeof version2 !== "string") {
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
    }
    if (version2.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      );
    }
    debug("SemVer", version2, options);
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    const m = version2.trim().match(options.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL]);
    if (!m) {
      throw new TypeError(`Invalid Version: ${version2}`);
    }
    this.raw = version2;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map((id2) => {
        if (/^[0-9]+$/.test(id2)) {
          const num = +id2;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id2;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join(".")}`;
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.major < other.major) {
      return -1;
    }
    if (this.major > other.major) {
      return 1;
    }
    if (this.minor < other.minor) {
      return -1;
    }
    if (this.minor > other.minor) {
      return 1;
    }
    if (this.patch < other.patch) {
      return -1;
    }
    if (this.patch > other.patch) {
      return 1;
    }
    return 0;
  }
  comparePre(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    let i = 0;
    do {
      const a = this.prerelease[i];
      const b = other.prerelease[i];
      debug("prerelease compare", i, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    let i = 0;
    do {
      const a = this.build[i];
      const b = other.build[i];
      debug("build compare", i, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(release, identifier, identifierBase) {
    if (release.startsWith("pre")) {
      if (!identifier && identifierBase === false) {
        throw new Error("invalid increment argument: identifier is empty");
      }
      if (identifier) {
        const match = `-${identifier}`.match(this.options.loose ? re$1[t$1.PRERELEASELOOSE] : re$1[t$1.PRERELEASE]);
        if (!match || match[1] !== identifier) {
          throw new Error(`invalid identifier: ${identifier}`);
        }
      }
    }
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier, identifierBase);
        this.inc("pre", identifier, identifierBase);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier, identifierBase);
        }
        this.inc("pre", identifier, identifierBase);
        break;
      case "release":
        if (this.prerelease.length === 0) {
          throw new Error(`version ${this.raw} is not a prerelease`);
        }
        this.prerelease.length = 0;
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre": {
        const base = Number(identifierBase) ? 1 : 0;
        if (this.prerelease.length === 0) {
          this.prerelease = [base];
        } else {
          let i = this.prerelease.length;
          while (--i >= 0) {
            if (typeof this.prerelease[i] === "number") {
              this.prerelease[i]++;
              i = -2;
            }
          }
          if (i === -1) {
            if (identifier === this.prerelease.join(".") && identifierBase === false) {
              throw new Error("invalid increment argument: identifier already exists");
            }
            this.prerelease.push(base);
          }
        }
        if (identifier) {
          let prerelease2 = [identifier, base];
          if (identifierBase === false) {
            prerelease2 = [identifier];
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease2;
            }
          } else {
            this.prerelease = prerelease2;
          }
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${release}`);
    }
    this.raw = this.format();
    if (this.build.length) {
      this.raw += `+${this.build.join(".")}`;
    }
    return this;
  }
};
var semver$1 = SemVer$d;
const SemVer$c = semver$1;
const parse$6 = (version2, options, throwErrors = false) => {
  if (version2 instanceof SemVer$c) {
    return version2;
  }
  try {
    return new SemVer$c(version2, options);
  } catch (er) {
    if (!throwErrors) {
      return null;
    }
    throw er;
  }
};
var parse_1 = parse$6;
const parse$5 = parse_1;
const valid$2 = (version2, options) => {
  const v = parse$5(version2, options);
  return v ? v.version : null;
};
var valid_1 = valid$2;
const parse$4 = parse_1;
const clean$1 = (version2, options) => {
  const s = parse$4(version2.trim().replace(/^[=v]+/, ""), options);
  return s ? s.version : null;
};
var clean_1 = clean$1;
const SemVer$b = semver$1;
const inc$1 = (version2, release, options, identifier, identifierBase) => {
  if (typeof options === "string") {
    identifierBase = identifier;
    identifier = options;
    options = void 0;
  }
  try {
    return new SemVer$b(
      version2 instanceof SemVer$b ? version2.version : version2,
      options
    ).inc(release, identifier, identifierBase).version;
  } catch (er) {
    return null;
  }
};
var inc_1 = inc$1;
const parse$3 = parse_1;
const diff$1 = (version1, version2) => {
  const v1 = parse$3(version1, null, true);
  const v2 = parse$3(version2, null, true);
  const comparison = v1.compare(v2);
  if (comparison === 0) {
    return null;
  }
  const v1Higher = comparison > 0;
  const highVersion = v1Higher ? v1 : v2;
  const lowVersion = v1Higher ? v2 : v1;
  const highHasPre = !!highVersion.prerelease.length;
  const lowHasPre = !!lowVersion.prerelease.length;
  if (lowHasPre && !highHasPre) {
    if (!lowVersion.patch && !lowVersion.minor) {
      return "major";
    }
    if (lowVersion.compareMain(highVersion) === 0) {
      if (lowVersion.minor && !lowVersion.patch) {
        return "minor";
      }
      return "patch";
    }
  }
  const prefix = highHasPre ? "pre" : "";
  if (v1.major !== v2.major) {
    return prefix + "major";
  }
  if (v1.minor !== v2.minor) {
    return prefix + "minor";
  }
  if (v1.patch !== v2.patch) {
    return prefix + "patch";
  }
  return "prerelease";
};
var diff_1 = diff$1;
const SemVer$a = semver$1;
const major$1 = (a, loose) => new SemVer$a(a, loose).major;
var major_1 = major$1;
const SemVer$9 = semver$1;
const minor$1 = (a, loose) => new SemVer$9(a, loose).minor;
var minor_1 = minor$1;
const SemVer$8 = semver$1;
const patch$1 = (a, loose) => new SemVer$8(a, loose).patch;
var patch_1 = patch$1;
const parse$2 = parse_1;
const prerelease$1 = (version2, options) => {
  const parsed = parse$2(version2, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
var prerelease_1 = prerelease$1;
const SemVer$7 = semver$1;
const compare$b = (a, b, loose) => new SemVer$7(a, loose).compare(new SemVer$7(b, loose));
var compare_1 = compare$b;
const compare$a = compare_1;
const rcompare$1 = (a, b, loose) => compare$a(b, a, loose);
var rcompare_1 = rcompare$1;
const compare$9 = compare_1;
const compareLoose$1 = (a, b) => compare$9(a, b, true);
var compareLoose_1 = compareLoose$1;
const SemVer$6 = semver$1;
const compareBuild$3 = (a, b, loose) => {
  const versionA = new SemVer$6(a, loose);
  const versionB = new SemVer$6(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
var compareBuild_1 = compareBuild$3;
const compareBuild$2 = compareBuild_1;
const sort$1 = (list, loose) => list.sort((a, b) => compareBuild$2(a, b, loose));
var sort_1 = sort$1;
const compareBuild$1 = compareBuild_1;
const rsort$1 = (list, loose) => list.sort((a, b) => compareBuild$1(b, a, loose));
var rsort_1 = rsort$1;
const compare$8 = compare_1;
const gt$4 = (a, b, loose) => compare$8(a, b, loose) > 0;
var gt_1 = gt$4;
const compare$7 = compare_1;
const lt$3 = (a, b, loose) => compare$7(a, b, loose) < 0;
var lt_1 = lt$3;
const compare$6 = compare_1;
const eq$2 = (a, b, loose) => compare$6(a, b, loose) === 0;
var eq_1 = eq$2;
const compare$5 = compare_1;
const neq$2 = (a, b, loose) => compare$5(a, b, loose) !== 0;
var neq_1 = neq$2;
const compare$4 = compare_1;
const gte$3 = (a, b, loose) => compare$4(a, b, loose) >= 0;
var gte_1 = gte$3;
const compare$3 = compare_1;
const lte$3 = (a, b, loose) => compare$3(a, b, loose) <= 0;
var lte_1 = lte$3;
const eq$1 = eq_1;
const neq$1 = neq_1;
const gt$3 = gt_1;
const gte$2 = gte_1;
const lt$2 = lt_1;
const lte$2 = lte_1;
const cmp$1 = (a, op, b, loose) => {
  switch (op) {
    case "===":
      if (typeof a === "object") {
        a = a.version;
      }
      if (typeof b === "object") {
        b = b.version;
      }
      return a === b;
    case "!==":
      if (typeof a === "object") {
        a = a.version;
      }
      if (typeof b === "object") {
        b = b.version;
      }
      return a !== b;
    case "":
    case "=":
    case "==":
      return eq$1(a, b, loose);
    case "!=":
      return neq$1(a, b, loose);
    case ">":
      return gt$3(a, b, loose);
    case ">=":
      return gte$2(a, b, loose);
    case "<":
      return lt$2(a, b, loose);
    case "<=":
      return lte$2(a, b, loose);
    default:
      throw new TypeError(`Invalid operator: ${op}`);
  }
};
var cmp_1 = cmp$1;
const SemVer$5 = semver$1;
const parse$1 = parse_1;
const { safeRe: re, t } = reExports;
const coerce$1 = (version2, options) => {
  if (version2 instanceof SemVer$5) {
    return version2;
  }
  if (typeof version2 === "number") {
    version2 = String(version2);
  }
  if (typeof version2 !== "string") {
    return null;
  }
  options = options || {};
  let match = null;
  if (!options.rtl) {
    match = version2.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
  } else {
    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
    let next;
    while ((next = coerceRtlRegex.exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
    }
    coerceRtlRegex.lastIndex = -1;
  }
  if (match === null) {
    return null;
  }
  const major2 = match[2];
  const minor2 = match[3] || "0";
  const patch2 = match[4] || "0";
  const prerelease2 = options.includePrerelease && match[5] ? `-${match[5]}` : "";
  const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
  return parse$1(`${major2}.${minor2}.${patch2}${prerelease2}${build}`, options);
};
var coerce_1 = coerce$1;
class LRUCache {
  constructor() {
    this.max = 1e3;
    this.map = /* @__PURE__ */ new Map();
  }
  get(key2) {
    const value = this.map.get(key2);
    if (value === void 0) {
      return void 0;
    } else {
      this.map.delete(key2);
      this.map.set(key2, value);
      return value;
    }
  }
  delete(key2) {
    return this.map.delete(key2);
  }
  set(key2, value) {
    const deleted = this.delete(key2);
    if (!deleted && value !== void 0) {
      if (this.map.size >= this.max) {
        const firstKey = this.map.keys().next().value;
        this.delete(firstKey);
      }
      this.map.set(key2, value);
    }
    return this;
  }
}
var lrucache = LRUCache;
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  const SPACE_CHARACTERS = /\s+/g;
  class Range2 {
    constructor(range2, options) {
      options = parseOptions2(options);
      if (range2 instanceof Range2) {
        if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
          return range2;
        } else {
          return new Range2(range2.raw, options);
        }
      }
      if (range2 instanceof Comparator2) {
        this.raw = range2.value;
        this.set = [[range2]];
        this.formatted = void 0;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range2.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let i = 0; i < this.set.length; i++) {
          if (i > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i];
          for (let k = 0; k < comps.length; k++) {
            if (k > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range2) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range2;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re2[t2.HYPHENRANGELOOSE] : re2[t2.HYPHENRANGE];
      range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug2("hyphen replace", range2);
      range2 = range2.replace(re2[t2.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range2);
      range2 = range2.replace(re2[t2.TILDETRIM], tildeTrimReplace);
      debug2("tilde trim", range2);
      range2 = range2.replace(re2[t2.CARETTRIM], caretTrimReplace);
      debug2("caret trim", range2);
      let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug2("loose invalid filter", comp, this.options);
          return !!comp.match(re2[t2.COMPARATORLOOSE]);
        });
      }
      debug2("range list", rangeList);
      const rangeMap = /* @__PURE__ */ new Map();
      const comparators = rangeList.map((comp) => new Comparator2(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range2, options) {
      if (!(range2 instanceof Range2)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer3(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version2, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range = Range2;
  const LRU = lrucache;
  const cache = new LRU();
  const parseOptions2 = parseOptions_1;
  const Comparator2 = requireComparator();
  const debug2 = debug_1;
  const SemVer3 = semver$1;
  const {
    safeRe: re2,
    t: t2,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = reExports;
  const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = constants$3;
  const isNullSet = (c) => c.value === "<0.0.0-0";
  const isAny = (c) => c.value === "";
  const isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  const parseComparator = (comp, options) => {
    comp = comp.replace(re2[t2.BUILD], "");
    debug2("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug2("caret", comp);
    comp = replaceTildes(comp, options);
    debug2("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug2("xrange", comp);
    comp = replaceStars(comp, options);
    debug2("stars", comp);
    return comp;
  };
  const isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
  const replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
  };
  const replaceTilde = (comp, options) => {
    const r = options.loose ? re2[t2.TILDELOOSE] : re2[t2.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug2("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug2("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug2("tilde return", ret);
      return ret;
    });
  };
  const replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
  };
  const replaceCaret = (comp, options) => {
    debug2("caret", comp, options);
    const r = options.loose ? re2[t2.CARETLOOSE] : re2[t2.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug2("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug2("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug2("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug2("caret return", ret);
      return ret;
    });
  };
  const replaceXRanges = (comp, options) => {
    debug2("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
  };
  const replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re2[t2.XRANGELOOSE] : re2[t2.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug2("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug2("xRange return", ret);
      return ret;
    });
  };
  const replaceStars = (comp, options) => {
    debug2("replaceStars", comp, options);
    return comp.trim().replace(re2[t2.STAR], "");
  };
  const replaceGTE0 = (comp, options) => {
    debug2("replaceGTE0", comp, options);
    return comp.trim().replace(re2[options.includePrerelease ? t2.GTE0PRE : t2.GTE0], "");
  };
  const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  const testSet = (set, version2, options) => {
    for (let i = 0; i < set.length; i++) {
      if (!set[i].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (let i = 0; i < set.length; i++) {
        debug2(set[i].semver);
        if (set[i].semver === Comparator2.ANY) {
          continue;
        }
        if (set[i].semver.prerelease.length > 0) {
          const allowed = set[i].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range;
}
var comparator;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator) return comparator;
  hasRequiredComparator = 1;
  const ANY2 = Symbol("SemVer ANY");
  class Comparator2 {
    static get ANY() {
      return ANY2;
    }
    constructor(comp, options) {
      options = parseOptions2(options);
      if (comp instanceof Comparator2) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug2("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY2) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re2[t2.COMPARATORLOOSE] : re2[t2.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY2;
      } else {
        this.semver = new SemVer3(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version2) {
      debug2("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY2 || version2 === ANY2) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer3(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp2(version2, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator2)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range2(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range2(this.value, options).test(comp.semver);
      }
      options = parseOptions2(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp2(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp2(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  comparator = Comparator2;
  const parseOptions2 = parseOptions_1;
  const { safeRe: re2, t: t2 } = reExports;
  const cmp2 = cmp_1;
  const debug2 = debug_1;
  const SemVer3 = semver$1;
  const Range2 = requireRange();
  return comparator;
}
const Range$9 = requireRange();
const satisfies$4 = (version2, range2, options) => {
  try {
    range2 = new Range$9(range2, options);
  } catch (er) {
    return false;
  }
  return range2.test(version2);
};
var satisfies_1 = satisfies$4;
const Range$8 = requireRange();
const toComparators$1 = (range2, options) => new Range$8(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
var toComparators_1 = toComparators$1;
const SemVer$4 = semver$1;
const Range$7 = requireRange();
const maxSatisfying$1 = (versions, range2, options) => {
  let max = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$7(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!max || maxSV.compare(v) === -1) {
        max = v;
        maxSV = new SemVer$4(max, options);
      }
    }
  });
  return max;
};
var maxSatisfying_1 = maxSatisfying$1;
const SemVer$3 = semver$1;
const Range$6 = requireRange();
const minSatisfying$1 = (versions, range2, options) => {
  let min = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$6(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!min || minSV.compare(v) === 1) {
        min = v;
        minSV = new SemVer$3(min, options);
      }
    }
  });
  return min;
};
var minSatisfying_1 = minSatisfying$1;
const SemVer$2 = semver$1;
const Range$5 = requireRange();
const gt$2 = gt_1;
const minVersion$1 = (range2, loose) => {
  range2 = new Range$5(range2, loose);
  let minver = new SemVer$2("0.0.0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = new SemVer$2("0.0.0-0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = null;
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let setMin = null;
    comparators.forEach((comparator2) => {
      const compver = new SemVer$2(comparator2.semver.version);
      switch (comparator2.operator) {
        case ">":
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
        case "":
        case ">=":
          if (!setMin || gt$2(compver, setMin)) {
            setMin = compver;
          }
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${comparator2.operator}`);
      }
    });
    if (setMin && (!minver || gt$2(minver, setMin))) {
      minver = setMin;
    }
  }
  if (minver && range2.test(minver)) {
    return minver;
  }
  return null;
};
var minVersion_1 = minVersion$1;
const Range$4 = requireRange();
const validRange$1 = (range2, options) => {
  try {
    return new Range$4(range2, options).range || "*";
  } catch (er) {
    return null;
  }
};
var valid$1 = validRange$1;
const SemVer$1 = semver$1;
const Comparator$2 = requireComparator();
const { ANY: ANY$1 } = Comparator$2;
const Range$3 = requireRange();
const satisfies$3 = satisfies_1;
const gt$1 = gt_1;
const lt$1 = lt_1;
const lte$1 = lte_1;
const gte$1 = gte_1;
const outside$3 = (version2, range2, hilo, options) => {
  version2 = new SemVer$1(version2, options);
  range2 = new Range$3(range2, options);
  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case ">":
      gtfn = gt$1;
      ltefn = lte$1;
      ltfn = lt$1;
      comp = ">";
      ecomp = ">=";
      break;
    case "<":
      gtfn = lt$1;
      ltefn = gte$1;
      ltfn = gt$1;
      comp = "<";
      ecomp = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (satisfies$3(version2, range2, options)) {
    return false;
  }
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let high = null;
    let low = null;
    comparators.forEach((comparator2) => {
      if (comparator2.semver === ANY$1) {
        comparator2 = new Comparator$2(">=0.0.0");
      }
      high = high || comparator2;
      low = low || comparator2;
      if (gtfn(comparator2.semver, high.semver, options)) {
        high = comparator2;
      } else if (ltfn(comparator2.semver, low.semver, options)) {
        low = comparator2;
      }
    });
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }
    if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
      return false;
    }
  }
  return true;
};
var outside_1 = outside$3;
const outside$2 = outside_1;
const gtr$1 = (version2, range2, options) => outside$2(version2, range2, ">", options);
var gtr_1 = gtr$1;
const outside$1 = outside_1;
const ltr$1 = (version2, range2, options) => outside$1(version2, range2, "<", options);
var ltr_1 = ltr$1;
const Range$2 = requireRange();
const intersects$1 = (r1, r2, options) => {
  r1 = new Range$2(r1, options);
  r2 = new Range$2(r2, options);
  return r1.intersects(r2, options);
};
var intersects_1 = intersects$1;
const satisfies$2 = satisfies_1;
const compare$2 = compare_1;
var simplify = (versions, range2, options) => {
  const set = [];
  let first = null;
  let prev = null;
  const v = versions.sort((a, b) => compare$2(a, b, options));
  for (const version2 of v) {
    const included = satisfies$2(version2, range2, options);
    if (included) {
      prev = version2;
      if (!first) {
        first = version2;
      }
    } else {
      if (prev) {
        set.push([first, prev]);
      }
      prev = null;
      first = null;
    }
  }
  if (first) {
    set.push([first, null]);
  }
  const ranges = [];
  for (const [min, max] of set) {
    if (min === max) {
      ranges.push(min);
    } else if (!max && min === v[0]) {
      ranges.push("*");
    } else if (!max) {
      ranges.push(`>=${min}`);
    } else if (min === v[0]) {
      ranges.push(`<=${max}`);
    } else {
      ranges.push(`${min} - ${max}`);
    }
  }
  const simplified = ranges.join(" || ");
  const original = typeof range2.raw === "string" ? range2.raw : String(range2);
  return simplified.length < original.length ? simplified : range2;
};
const Range$1 = requireRange();
const Comparator$1 = requireComparator();
const { ANY } = Comparator$1;
const satisfies$1 = satisfies_1;
const compare$1 = compare_1;
const subset$1 = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true;
  }
  sub = new Range$1(sub, options);
  dom = new Range$1(dom, options);
  let sawNonNull = false;
  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options);
      sawNonNull = sawNonNull || isSub !== null;
      if (isSub) {
        continue OUTER;
      }
    }
    if (sawNonNull) {
      return false;
    }
  }
  return true;
};
const minimumVersionWithPreRelease = [new Comparator$1(">=0.0.0-0")];
const minimumVersion = [new Comparator$1(">=0.0.0")];
const simpleSubset = (sub, dom, options) => {
  if (sub === dom) {
    return true;
  }
  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true;
    } else if (options.includePrerelease) {
      sub = minimumVersionWithPreRelease;
    } else {
      sub = minimumVersion;
    }
  }
  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true;
    } else {
      dom = minimumVersion;
    }
  }
  const eqSet = /* @__PURE__ */ new Set();
  let gt2, lt2;
  for (const c of sub) {
    if (c.operator === ">" || c.operator === ">=") {
      gt2 = higherGT(gt2, c, options);
    } else if (c.operator === "<" || c.operator === "<=") {
      lt2 = lowerLT(lt2, c, options);
    } else {
      eqSet.add(c.semver);
    }
  }
  if (eqSet.size > 1) {
    return null;
  }
  let gtltComp;
  if (gt2 && lt2) {
    gtltComp = compare$1(gt2.semver, lt2.semver, options);
    if (gtltComp > 0) {
      return null;
    } else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<=")) {
      return null;
    }
  }
  for (const eq2 of eqSet) {
    if (gt2 && !satisfies$1(eq2, String(gt2), options)) {
      return null;
    }
    if (lt2 && !satisfies$1(eq2, String(lt2), options)) {
      return null;
    }
    for (const c of dom) {
      if (!satisfies$1(eq2, String(c), options)) {
        return false;
      }
    }
    return true;
  }
  let higher, lower;
  let hasDomLT, hasDomGT;
  let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
  let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }
  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
    hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
    if (gt2) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false;
        }
      }
      if (c.operator === ">" || c.operator === ">=") {
        higher = higherGT(gt2, c, options);
        if (higher === c && higher !== gt2) {
          return false;
        }
      } else if (gt2.operator === ">=" && !satisfies$1(gt2.semver, String(c), options)) {
        return false;
      }
    }
    if (lt2) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false;
        }
      }
      if (c.operator === "<" || c.operator === "<=") {
        lower = lowerLT(lt2, c, options);
        if (lower === c && lower !== lt2) {
          return false;
        }
      } else if (lt2.operator === "<=" && !satisfies$1(lt2.semver, String(c), options)) {
        return false;
      }
    }
    if (!c.operator && (lt2 || gt2) && gtltComp !== 0) {
      return false;
    }
  }
  if (gt2 && hasDomLT && !lt2 && gtltComp !== 0) {
    return false;
  }
  if (lt2 && hasDomGT && !gt2 && gtltComp !== 0) {
    return false;
  }
  if (needDomGTPre || needDomLTPre) {
    return false;
  }
  return true;
};
const higherGT = (a, b, options) => {
  if (!a) {
    return b;
  }
  const comp = compare$1(a.semver, b.semver, options);
  return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
};
const lowerLT = (a, b, options) => {
  if (!a) {
    return b;
  }
  const comp = compare$1(a.semver, b.semver, options);
  return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
};
var subset_1 = subset$1;
const internalRe = reExports;
const constants$2 = constants$3;
const SemVer2 = semver$1;
const identifiers = identifiers$1;
const parse = parse_1;
const valid = valid_1;
const clean = clean_1;
const inc = inc_1;
const diff = diff_1;
const major = major_1;
const minor = minor_1;
const patch = patch_1;
const prerelease = prerelease_1;
const compare = compare_1;
const rcompare = rcompare_1;
const compareLoose = compareLoose_1;
const compareBuild = compareBuild_1;
const sort = sort_1;
const rsort = rsort_1;
const gt = gt_1;
const lt = lt_1;
const eq = eq_1;
const neq = neq_1;
const gte = gte_1;
const lte = lte_1;
const cmp = cmp_1;
const coerce = coerce_1;
const Comparator = requireComparator();
const Range = requireRange();
const satisfies = satisfies_1;
const toComparators = toComparators_1;
const maxSatisfying = maxSatisfying_1;
const minSatisfying = minSatisfying_1;
const minVersion = minVersion_1;
const validRange = valid$1;
const outside = outside_1;
const gtr = gtr_1;
const ltr = ltr_1;
const intersects = intersects_1;
const simplifyRange = simplify;
const subset = subset_1;
var semver = {
  parse,
  valid,
  clean,
  inc,
  diff,
  major,
  minor,
  patch,
  prerelease,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer: SemVer2,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants$2.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants$2.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers
};
var onetime$1 = { exports: {} };
var mimicFn$2 = { exports: {} };
const mimicFn$1 = (to, from) => {
  for (const prop of Reflect.ownKeys(from)) {
    Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
  }
  return to;
};
mimicFn$2.exports = mimicFn$1;
mimicFn$2.exports.default = mimicFn$1;
var mimicFnExports = mimicFn$2.exports;
const mimicFn = mimicFnExports;
const calledFunctions = /* @__PURE__ */ new WeakMap();
const onetime = (function_, options = {}) => {
  if (typeof function_ !== "function") {
    throw new TypeError("Expected a function");
  }
  let returnValue;
  let callCount = 0;
  const functionName = function_.displayName || function_.name || "<anonymous>";
  const onetime2 = function(...arguments_) {
    calledFunctions.set(onetime2, ++callCount);
    if (callCount === 1) {
      returnValue = function_.apply(this, arguments_);
      function_ = null;
    } else if (options.throw === true) {
      throw new Error(`Function \`${functionName}\` can only be called once`);
    }
    return returnValue;
  };
  mimicFn(onetime2, function_);
  calledFunctions.set(onetime2, callCount);
  return onetime2;
};
onetime$1.exports = onetime;
onetime$1.exports.default = onetime;
onetime$1.exports.callCount = (function_) => {
  if (!calledFunctions.has(function_)) {
    throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
  }
  return calledFunctions.get(function_);
};
var onetimeExports = onetime$1.exports;
(function(module2, exports$1) {
  var __classPrivateFieldSet = commonjsGlobal && commonjsGlobal.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = commonjsGlobal && commonjsGlobal.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _a, _b;
  var _Conf_validator, _Conf_encryptionKey, _Conf_options, _Conf_defaultValues;
  Object.defineProperty(exports$1, "__esModule", { value: true });
  const util_12 = require$$0$1;
  const fs2 = require$$1;
  const path2 = require$$0;
  const crypto2 = require$$0$3;
  const assert2 = require$$0$2;
  const events_1 = require$$5;
  const dotProp$1 = dotProp;
  const pkgUp2 = pkgUpExports;
  const envPaths2 = envPathsExports;
  const atomically = dist$1;
  const ajv_1 = ajvExports$1;
  const ajv_formats_1 = distExports;
  const debounceFn$1 = debounceFn;
  const semver$12 = semver;
  const onetime2 = onetimeExports;
  const encryptionAlgorithm = "aes-256-cbc";
  const createPlainObject = () => {
    return /* @__PURE__ */ Object.create(null);
  };
  const isExist = (data) => {
    return data !== void 0 && data !== null;
  };
  let parentDir = "";
  try {
    delete require.cache[__filename];
    parentDir = path2.dirname((_b = (_a = module2.parent) === null || _a === void 0 ? void 0 : _a.filename) !== null && _b !== void 0 ? _b : ".");
  } catch (_c) {
  }
  const checkValueType = (key2, value) => {
    const nonJsonTypes = /* @__PURE__ */ new Set([
      "undefined",
      "symbol",
      "function"
    ]);
    const type2 = typeof value;
    if (nonJsonTypes.has(type2)) {
      throw new TypeError(`Setting a value of type \`${type2}\` for key \`${key2}\` is not allowed as it's not supported by JSON`);
    }
  };
  const INTERNAL_KEY = "__internal__";
  const MIGRATION_KEY = `${INTERNAL_KEY}.migrations.version`;
  class Conf2 {
    constructor(partialOptions = {}) {
      var _a2;
      _Conf_validator.set(this, void 0);
      _Conf_encryptionKey.set(this, void 0);
      _Conf_options.set(this, void 0);
      _Conf_defaultValues.set(this, {});
      this._deserialize = (value) => JSON.parse(value);
      this._serialize = (value) => JSON.stringify(value, void 0, "	");
      const options = {
        configName: "config",
        fileExtension: "json",
        projectSuffix: "nodejs",
        clearInvalidConfig: false,
        accessPropertiesByDotNotation: true,
        configFileMode: 438,
        ...partialOptions
      };
      const getPackageData = onetime2(() => {
        const packagePath = pkgUp2.sync({ cwd: parentDir });
        const packageData = packagePath && JSON.parse(fs2.readFileSync(packagePath, "utf8"));
        return packageData !== null && packageData !== void 0 ? packageData : {};
      });
      if (!options.cwd) {
        if (!options.projectName) {
          options.projectName = getPackageData().name;
        }
        if (!options.projectName) {
          throw new Error("Project name could not be inferred. Please specify the `projectName` option.");
        }
        options.cwd = envPaths2(options.projectName, { suffix: options.projectSuffix }).config;
      }
      __classPrivateFieldSet(this, _Conf_options, options, "f");
      if (options.schema) {
        if (typeof options.schema !== "object") {
          throw new TypeError("The `schema` option must be an object.");
        }
        const ajv2 = new ajv_1.default({
          allErrors: true,
          useDefaults: true
        });
        (0, ajv_formats_1.default)(ajv2);
        const schema = {
          type: "object",
          properties: options.schema
        };
        __classPrivateFieldSet(this, _Conf_validator, ajv2.compile(schema), "f");
        for (const [key2, value] of Object.entries(options.schema)) {
          if (value === null || value === void 0 ? void 0 : value.default) {
            __classPrivateFieldGet(this, _Conf_defaultValues, "f")[key2] = value.default;
          }
        }
      }
      if (options.defaults) {
        __classPrivateFieldSet(this, _Conf_defaultValues, {
          ...__classPrivateFieldGet(this, _Conf_defaultValues, "f"),
          ...options.defaults
        }, "f");
      }
      if (options.serialize) {
        this._serialize = options.serialize;
      }
      if (options.deserialize) {
        this._deserialize = options.deserialize;
      }
      this.events = new events_1.EventEmitter();
      __classPrivateFieldSet(this, _Conf_encryptionKey, options.encryptionKey, "f");
      const fileExtension = options.fileExtension ? `.${options.fileExtension}` : "";
      this.path = path2.resolve(options.cwd, `${(_a2 = options.configName) !== null && _a2 !== void 0 ? _a2 : "config"}${fileExtension}`);
      const fileStore = this.store;
      const store2 = Object.assign(createPlainObject(), options.defaults, fileStore);
      this._validate(store2);
      try {
        assert2.deepEqual(fileStore, store2);
      } catch (_b2) {
        this.store = store2;
      }
      if (options.watch) {
        this._watch();
      }
      if (options.migrations) {
        if (!options.projectVersion) {
          options.projectVersion = getPackageData().version;
        }
        if (!options.projectVersion) {
          throw new Error("Project version could not be inferred. Please specify the `projectVersion` option.");
        }
        this._migrate(options.migrations, options.projectVersion, options.beforeEachMigration);
      }
    }
    get(key2, defaultValue) {
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        return this._get(key2, defaultValue);
      }
      const { store: store2 } = this;
      return key2 in store2 ? store2[key2] : defaultValue;
    }
    set(key2, value) {
      if (typeof key2 !== "string" && typeof key2 !== "object") {
        throw new TypeError(`Expected \`key\` to be of type \`string\` or \`object\`, got ${typeof key2}`);
      }
      if (typeof key2 !== "object" && value === void 0) {
        throw new TypeError("Use `delete()` to clear values");
      }
      if (this._containsReservedKey(key2)) {
        throw new TypeError(`Please don't use the ${INTERNAL_KEY} key, as it's used to manage this module internal operations.`);
      }
      const { store: store2 } = this;
      const set = (key22, value2) => {
        checkValueType(key22, value2);
        if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
          dotProp$1.set(store2, key22, value2);
        } else {
          store2[key22] = value2;
        }
      };
      if (typeof key2 === "object") {
        const object = key2;
        for (const [key22, value2] of Object.entries(object)) {
          set(key22, value2);
        }
      } else {
        set(key2, value);
      }
      this.store = store2;
    }
    /**
        Check if an item exists.
    
        @param key - The key of the item to check.
        */
    has(key2) {
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        return dotProp$1.has(this.store, key2);
      }
      return key2 in this.store;
    }
    /**
        Reset items to their default values, as defined by the `defaults` or `schema` option.
    
        @see `clear()` to reset all items.
    
        @param keys - The keys of the items to reset.
        */
    reset(...keys) {
      for (const key2 of keys) {
        if (isExist(__classPrivateFieldGet(this, _Conf_defaultValues, "f")[key2])) {
          this.set(key2, __classPrivateFieldGet(this, _Conf_defaultValues, "f")[key2]);
        }
      }
    }
    /**
        Delete an item.
    
        @param key - The key of the item to delete.
        */
    delete(key2) {
      const { store: store2 } = this;
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        dotProp$1.delete(store2, key2);
      } else {
        delete store2[key2];
      }
      this.store = store2;
    }
    /**
        Delete all items.
    
        This resets known items to their default values, if defined by the `defaults` or `schema` option.
        */
    clear() {
      this.store = createPlainObject();
      for (const key2 of Object.keys(__classPrivateFieldGet(this, _Conf_defaultValues, "f"))) {
        this.reset(key2);
      }
    }
    /**
        Watches the given `key`, calling `callback` on any changes.
    
        @param key - The key wo watch.
        @param callback - A callback function that is called on any changes. When a `key` is first set `oldValue` will be `undefined`, and when a key is deleted `newValue` will be `undefined`.
        @returns A function, that when called, will unsubscribe.
        */
    onDidChange(key2, callback) {
      if (typeof key2 !== "string") {
        throw new TypeError(`Expected \`key\` to be of type \`string\`, got ${typeof key2}`);
      }
      if (typeof callback !== "function") {
        throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof callback}`);
      }
      return this._handleChange(() => this.get(key2), callback);
    }
    /**
        Watches the whole config object, calling `callback` on any changes.
    
        @param callback - A callback function that is called on any changes. When a `key` is first set `oldValue` will be `undefined`, and when a key is deleted `newValue` will be `undefined`.
        @returns A function, that when called, will unsubscribe.
        */
    onDidAnyChange(callback) {
      if (typeof callback !== "function") {
        throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof callback}`);
      }
      return this._handleChange(() => this.store, callback);
    }
    get size() {
      return Object.keys(this.store).length;
    }
    get store() {
      try {
        const data = fs2.readFileSync(this.path, __classPrivateFieldGet(this, _Conf_encryptionKey, "f") ? null : "utf8");
        const dataString = this._encryptData(data);
        const deserializedData = this._deserialize(dataString);
        this._validate(deserializedData);
        return Object.assign(createPlainObject(), deserializedData);
      } catch (error2) {
        if ((error2 === null || error2 === void 0 ? void 0 : error2.code) === "ENOENT") {
          this._ensureDirectory();
          return createPlainObject();
        }
        if (__classPrivateFieldGet(this, _Conf_options, "f").clearInvalidConfig && error2.name === "SyntaxError") {
          return createPlainObject();
        }
        throw error2;
      }
    }
    set store(value) {
      this._ensureDirectory();
      this._validate(value);
      this._write(value);
      this.events.emit("change");
    }
    *[(_Conf_validator = /* @__PURE__ */ new WeakMap(), _Conf_encryptionKey = /* @__PURE__ */ new WeakMap(), _Conf_options = /* @__PURE__ */ new WeakMap(), _Conf_defaultValues = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
      for (const [key2, value] of Object.entries(this.store)) {
        yield [key2, value];
      }
    }
    _encryptData(data) {
      if (!__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
        return data.toString();
      }
      try {
        if (__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
          try {
            if (data.slice(16, 17).toString() === ":") {
              const initializationVector = data.slice(0, 16);
              const password = crypto2.pbkdf2Sync(__classPrivateFieldGet(this, _Conf_encryptionKey, "f"), initializationVector.toString(), 1e4, 32, "sha512");
              const decipher = crypto2.createDecipheriv(encryptionAlgorithm, password, initializationVector);
              data = Buffer.concat([decipher.update(Buffer.from(data.slice(17))), decipher.final()]).toString("utf8");
            } else {
              const decipher = crypto2.createDecipher(encryptionAlgorithm, __classPrivateFieldGet(this, _Conf_encryptionKey, "f"));
              data = Buffer.concat([decipher.update(Buffer.from(data)), decipher.final()]).toString("utf8");
            }
          } catch (_a2) {
          }
        }
      } catch (_b2) {
      }
      return data.toString();
    }
    _handleChange(getter, callback) {
      let currentValue = getter();
      const onChange = () => {
        const oldValue = currentValue;
        const newValue = getter();
        if ((0, util_12.isDeepStrictEqual)(newValue, oldValue)) {
          return;
        }
        currentValue = newValue;
        callback.call(this, newValue, oldValue);
      };
      this.events.on("change", onChange);
      return () => this.events.removeListener("change", onChange);
    }
    _validate(data) {
      if (!__classPrivateFieldGet(this, _Conf_validator, "f")) {
        return;
      }
      const valid2 = __classPrivateFieldGet(this, _Conf_validator, "f").call(this, data);
      if (valid2 || !__classPrivateFieldGet(this, _Conf_validator, "f").errors) {
        return;
      }
      const errors2 = __classPrivateFieldGet(this, _Conf_validator, "f").errors.map(({ instancePath, message = "" }) => `\`${instancePath.slice(1)}\` ${message}`);
      throw new Error("Config schema violation: " + errors2.join("; "));
    }
    _ensureDirectory() {
      fs2.mkdirSync(path2.dirname(this.path), { recursive: true });
    }
    _write(value) {
      let data = this._serialize(value);
      if (__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
        const initializationVector = crypto2.randomBytes(16);
        const password = crypto2.pbkdf2Sync(__classPrivateFieldGet(this, _Conf_encryptionKey, "f"), initializationVector.toString(), 1e4, 32, "sha512");
        const cipher = crypto2.createCipheriv(encryptionAlgorithm, password, initializationVector);
        data = Buffer.concat([initializationVector, Buffer.from(":"), cipher.update(Buffer.from(data)), cipher.final()]);
      }
      if (process.env.SNAP) {
        fs2.writeFileSync(this.path, data, { mode: __classPrivateFieldGet(this, _Conf_options, "f").configFileMode });
      } else {
        try {
          atomically.writeFileSync(this.path, data, { mode: __classPrivateFieldGet(this, _Conf_options, "f").configFileMode });
        } catch (error2) {
          if ((error2 === null || error2 === void 0 ? void 0 : error2.code) === "EXDEV") {
            fs2.writeFileSync(this.path, data, { mode: __classPrivateFieldGet(this, _Conf_options, "f").configFileMode });
            return;
          }
          throw error2;
        }
      }
    }
    _watch() {
      this._ensureDirectory();
      if (!fs2.existsSync(this.path)) {
        this._write(createPlainObject());
      }
      if (process.platform === "win32") {
        fs2.watch(this.path, { persistent: false }, debounceFn$1(() => {
          this.events.emit("change");
        }, { wait: 100 }));
      } else {
        fs2.watchFile(this.path, { persistent: false }, debounceFn$1(() => {
          this.events.emit("change");
        }, { wait: 5e3 }));
      }
    }
    _migrate(migrations, versionToMigrate, beforeEachMigration) {
      let previousMigratedVersion = this._get(MIGRATION_KEY, "0.0.0");
      const newerVersions = Object.keys(migrations).filter((candidateVersion) => this._shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate));
      let storeBackup = { ...this.store };
      for (const version2 of newerVersions) {
        try {
          if (beforeEachMigration) {
            beforeEachMigration(this, {
              fromVersion: previousMigratedVersion,
              toVersion: version2,
              finalVersion: versionToMigrate,
              versions: newerVersions
            });
          }
          const migration = migrations[version2];
          migration(this);
          this._set(MIGRATION_KEY, version2);
          previousMigratedVersion = version2;
          storeBackup = { ...this.store };
        } catch (error2) {
          this.store = storeBackup;
          throw new Error(`Something went wrong during the migration! Changes applied to the store until this failed migration will be restored. ${error2}`);
        }
      }
      if (this._isVersionInRangeFormat(previousMigratedVersion) || !semver$12.eq(previousMigratedVersion, versionToMigrate)) {
        this._set(MIGRATION_KEY, versionToMigrate);
      }
    }
    _containsReservedKey(key2) {
      if (typeof key2 === "object") {
        const firsKey = Object.keys(key2)[0];
        if (firsKey === INTERNAL_KEY) {
          return true;
        }
      }
      if (typeof key2 !== "string") {
        return false;
      }
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        if (key2.startsWith(`${INTERNAL_KEY}.`)) {
          return true;
        }
        return false;
      }
      return false;
    }
    _isVersionInRangeFormat(version2) {
      return semver$12.clean(version2) === null;
    }
    _shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate) {
      if (this._isVersionInRangeFormat(candidateVersion)) {
        if (previousMigratedVersion !== "0.0.0" && semver$12.satisfies(previousMigratedVersion, candidateVersion)) {
          return false;
        }
        return semver$12.satisfies(versionToMigrate, candidateVersion);
      }
      if (semver$12.lte(candidateVersion, previousMigratedVersion)) {
        return false;
      }
      if (semver$12.gt(candidateVersion, versionToMigrate)) {
        return false;
      }
      return true;
    }
    _get(key2, defaultValue) {
      return dotProp$1.get(this.store, key2, defaultValue);
    }
    _set(key2, value) {
      const { store: store2 } = this;
      dotProp$1.set(store2, key2, value);
      this.store = store2;
    }
  }
  exports$1.default = Conf2;
  module2.exports = Conf2;
  module2.exports.default = Conf2;
})(source, source.exports);
var sourceExports = source.exports;
const path = require$$0;
const { app, ipcMain, ipcRenderer, shell } = require$$1$2;
const Conf = sourceExports;
let isInitialized = false;
const initDataListener = () => {
  if (!ipcMain || !app) {
    throw new Error("Electron Store: You need to call `.initRenderer()` from the main process.");
  }
  const appData = {
    defaultCwd: app.getPath("userData"),
    appVersion: app.getVersion()
  };
  if (isInitialized) {
    return appData;
  }
  ipcMain.on("electron-store-get-data", (event) => {
    event.returnValue = appData;
  });
  isInitialized = true;
  return appData;
};
class ElectronStore extends Conf {
  constructor(options) {
    let defaultCwd;
    let appVersion;
    if (ipcRenderer) {
      const appData = ipcRenderer.sendSync("electron-store-get-data");
      if (!appData) {
        throw new Error("Electron Store: You need to call `.initRenderer()` from the main process.");
      }
      ({ defaultCwd, appVersion } = appData);
    } else if (ipcMain && app) {
      ({ defaultCwd, appVersion } = initDataListener());
    }
    options = {
      name: "config",
      ...options
    };
    if (!options.projectVersion) {
      options.projectVersion = appVersion;
    }
    if (options.cwd) {
      options.cwd = path.isAbsolute(options.cwd) ? options.cwd : path.join(defaultCwd, options.cwd);
    } else {
      options.cwd = defaultCwd;
    }
    options.configName = options.name;
    delete options.name;
    super(options);
  }
  static initRenderer() {
    initDataListener();
  }
  async openInEditor() {
    const error2 = await shell.openPath(this.path);
    if (error2) {
      throw new Error(error2);
    }
  }
}
var electronStore = ElectronStore;
const Store = /* @__PURE__ */ getDefaultExportFromCjs(electronStore);
const store = new Store({
  defaults: {
    vps: {
      host: "",
      username: "root",
      port: 22
    },
    apps: {}
  }
});
const ConfigStore = {
  get: (key2) => store.get(key2),
  set: (key2, value) => store.set(key2, value),
  getAll: () => store.store,
  clear: () => store.clear()
};
var ber = { exports: {} };
var errors$2 = {
  newInvalidAsn1Error: function(msg) {
    var e = new Error();
    e.name = "InvalidAsn1Error";
    e.message = msg || "";
    return e;
  }
};
var types = {
  EOC: 0,
  Boolean: 1,
  Integer: 2,
  BitString: 3,
  OctetString: 4,
  Null: 5,
  OID: 6,
  ObjectDescriptor: 7,
  External: 8,
  Real: 9,
  // float
  Enumeration: 10,
  PDV: 11,
  Utf8String: 12,
  RelativeOID: 13,
  Sequence: 16,
  Set: 17,
  NumericString: 18,
  PrintableString: 19,
  T61String: 20,
  VideotexString: 21,
  IA5String: 22,
  UTCTime: 23,
  GeneralizedTime: 24,
  GraphicString: 25,
  VisibleString: 26,
  GeneralString: 28,
  UniversalString: 29,
  CharacterString: 30,
  BMPString: 31,
  Constructor: 32,
  Context: 128
};
var buffer = require$$0$4;
var Buffer$3 = buffer.Buffer;
var safer = {};
var key;
for (key in buffer) {
  if (!buffer.hasOwnProperty(key)) continue;
  if (key === "SlowBuffer" || key === "Buffer") continue;
  safer[key] = buffer[key];
}
var Safer = safer.Buffer = {};
for (key in Buffer$3) {
  if (!Buffer$3.hasOwnProperty(key)) continue;
  if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
  Safer[key] = Buffer$3[key];
}
safer.Buffer.prototype = Buffer$3.prototype;
if (!Safer.from || Safer.from === Uint8Array.from) {
  Safer.from = function(value, encodingOrOffset, length) {
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
    }
    if (value && typeof value.length === "undefined") {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    return Buffer$3(value, encodingOrOffset, length);
  };
}
if (!Safer.alloc) {
  Safer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
    }
    if (size < 0 || size >= 2 * (1 << 30)) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
    var buf = Buffer$3(size);
    if (!fill || fill.length === 0) {
      buf.fill(0);
    } else if (typeof encoding === "string") {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
    return buf;
  };
}
if (!safer.kStringMaxLength) {
  try {
    safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
  } catch (e) {
  }
}
if (!safer.constants) {
  safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  };
  if (safer.kStringMaxLength) {
    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
  }
}
var safer_1 = safer;
var assert$2 = require$$0$2;
var Buffer$2 = safer_1.Buffer;
var ASN1$1 = types;
var errors$1 = errors$2;
var newInvalidAsn1Error$1 = errors$1.newInvalidAsn1Error;
function Reader(data) {
  if (!data || !Buffer$2.isBuffer(data))
    throw new TypeError("data must be a node Buffer");
  this._buf = data;
  this._size = data.length;
  this._len = 0;
  this._offset = 0;
}
Object.defineProperty(Reader.prototype, "length", {
  enumerable: true,
  get: function() {
    return this._len;
  }
});
Object.defineProperty(Reader.prototype, "offset", {
  enumerable: true,
  get: function() {
    return this._offset;
  }
});
Object.defineProperty(Reader.prototype, "remain", {
  get: function() {
    return this._size - this._offset;
  }
});
Object.defineProperty(Reader.prototype, "buffer", {
  get: function() {
    return this._buf.slice(this._offset);
  }
});
Reader.prototype.readByte = function(peek) {
  if (this._size - this._offset < 1)
    return null;
  var b = this._buf[this._offset] & 255;
  if (!peek)
    this._offset += 1;
  return b;
};
Reader.prototype.peek = function() {
  return this.readByte(true);
};
Reader.prototype.readLength = function(offset) {
  if (offset === void 0)
    offset = this._offset;
  if (offset >= this._size)
    return null;
  var lenB = this._buf[offset++] & 255;
  if (lenB === null)
    return null;
  if ((lenB & 128) === 128) {
    lenB &= 127;
    if (lenB === 0)
      throw newInvalidAsn1Error$1("Indefinite length not supported");
    if (lenB > 4)
      throw newInvalidAsn1Error$1("encoding too long");
    if (this._size - offset < lenB)
      return null;
    this._len = 0;
    for (var i = 0; i < lenB; i++)
      this._len = (this._len << 8) + (this._buf[offset++] & 255);
  } else {
    this._len = lenB;
  }
  return offset;
};
Reader.prototype.readSequence = function(tag) {
  var seq = this.peek();
  if (seq === null)
    return null;
  if (tag !== void 0 && tag !== seq)
    throw newInvalidAsn1Error$1("Expected 0x" + tag.toString(16) + ": got 0x" + seq.toString(16));
  var o = this.readLength(this._offset + 1);
  if (o === null)
    return null;
  this._offset = o;
  return seq;
};
Reader.prototype.readInt = function() {
  return this._readTag(ASN1$1.Integer);
};
Reader.prototype.readBoolean = function() {
  return this._readTag(ASN1$1.Boolean) === 0 ? false : true;
};
Reader.prototype.readEnumeration = function() {
  return this._readTag(ASN1$1.Enumeration);
};
Reader.prototype.readString = function(tag, retbuf) {
  if (!tag)
    tag = ASN1$1.OctetString;
  var b = this.peek();
  if (b === null)
    return null;
  if (b !== tag)
    throw newInvalidAsn1Error$1("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
  var o = this.readLength(this._offset + 1);
  if (o === null)
    return null;
  if (this.length > this._size - o)
    return null;
  this._offset = o;
  if (this.length === 0)
    return retbuf ? Buffer$2.alloc(0) : "";
  var str = this._buf.slice(this._offset, this._offset + this.length);
  this._offset += this.length;
  return retbuf ? str : str.toString("utf8");
};
Reader.prototype.readOID = function(tag) {
  if (!tag)
    tag = ASN1$1.OID;
  var b = this.readString(tag, true);
  if (b === null)
    return null;
  var values = [];
  var value = 0;
  for (var i = 0; i < b.length; i++) {
    var byte = b[i] & 255;
    value <<= 7;
    value += byte & 127;
    if ((byte & 128) === 0) {
      values.push(value);
      value = 0;
    }
  }
  value = values.shift();
  values.unshift(value % 40);
  values.unshift(value / 40 >> 0);
  return values.join(".");
};
Reader.prototype._readTag = function(tag) {
  assert$2.ok(tag !== void 0);
  var b = this.peek();
  if (b === null)
    return null;
  if (b !== tag)
    throw newInvalidAsn1Error$1("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
  var o = this.readLength(this._offset + 1);
  if (o === null)
    return null;
  if (this.length > 4)
    throw newInvalidAsn1Error$1("Integer too long: " + this.length);
  if (this.length > this._size - o)
    return null;
  this._offset = o;
  var fb = this._buf[this._offset];
  var value = 0;
  for (var i = 0; i < this.length; i++) {
    value <<= 8;
    value |= this._buf[this._offset++] & 255;
  }
  if ((fb & 128) === 128 && i !== 4)
    value -= 1 << i * 8;
  return value >> 0;
};
var reader = Reader;
var assert$1 = require$$0$2;
var Buffer$1 = safer_1.Buffer;
var ASN1 = types;
var errors = errors$2;
var newInvalidAsn1Error = errors.newInvalidAsn1Error;
var DEFAULT_OPTS = {
  size: 1024,
  growthFactor: 8
};
function merge(from, to) {
  assert$1.ok(from);
  assert$1.equal(typeof from, "object");
  assert$1.ok(to);
  assert$1.equal(typeof to, "object");
  var keys = Object.getOwnPropertyNames(from);
  keys.forEach(function(key2) {
    if (to[key2])
      return;
    var value = Object.getOwnPropertyDescriptor(from, key2);
    Object.defineProperty(to, key2, value);
  });
  return to;
}
function Writer(options) {
  options = merge(DEFAULT_OPTS, options || {});
  this._buf = Buffer$1.alloc(options.size || 1024);
  this._size = this._buf.length;
  this._offset = 0;
  this._options = options;
  this._seq = [];
}
Object.defineProperty(Writer.prototype, "buffer", {
  get: function() {
    if (this._seq.length)
      throw newInvalidAsn1Error(this._seq.length + " unended sequence(s)");
    return this._buf.slice(0, this._offset);
  }
});
Writer.prototype.writeByte = function(b) {
  if (typeof b !== "number")
    throw new TypeError("argument must be a Number");
  this._ensure(1);
  this._buf[this._offset++] = b;
};
Writer.prototype.writeInt = function(i, tag) {
  if (typeof i !== "number")
    throw new TypeError("argument must be a Number");
  if (typeof tag !== "number")
    tag = ASN1.Integer;
  var sz = 4;
  while (((i & 4286578688) === 0 || (i & 4286578688) === 4286578688 >> 0) && sz > 1) {
    sz--;
    i <<= 8;
  }
  if (sz > 4)
    throw newInvalidAsn1Error("BER ints cannot be > 0xffffffff");
  this._ensure(2 + sz);
  this._buf[this._offset++] = tag;
  this._buf[this._offset++] = sz;
  while (sz-- > 0) {
    this._buf[this._offset++] = (i & 4278190080) >>> 24;
    i <<= 8;
  }
};
Writer.prototype.writeNull = function() {
  this.writeByte(ASN1.Null);
  this.writeByte(0);
};
Writer.prototype.writeEnumeration = function(i, tag) {
  if (typeof i !== "number")
    throw new TypeError("argument must be a Number");
  if (typeof tag !== "number")
    tag = ASN1.Enumeration;
  return this.writeInt(i, tag);
};
Writer.prototype.writeBoolean = function(b, tag) {
  if (typeof b !== "boolean")
    throw new TypeError("argument must be a Boolean");
  if (typeof tag !== "number")
    tag = ASN1.Boolean;
  this._ensure(3);
  this._buf[this._offset++] = tag;
  this._buf[this._offset++] = 1;
  this._buf[this._offset++] = b ? 255 : 0;
};
Writer.prototype.writeString = function(s, tag) {
  if (typeof s !== "string")
    throw new TypeError("argument must be a string (was: " + typeof s + ")");
  if (typeof tag !== "number")
    tag = ASN1.OctetString;
  var len = Buffer$1.byteLength(s);
  this.writeByte(tag);
  this.writeLength(len);
  if (len) {
    this._ensure(len);
    this._buf.write(s, this._offset);
    this._offset += len;
  }
};
Writer.prototype.writeBuffer = function(buf, tag) {
  if (typeof tag !== "number")
    throw new TypeError("tag must be a number");
  if (!Buffer$1.isBuffer(buf))
    throw new TypeError("argument must be a buffer");
  this.writeByte(tag);
  this.writeLength(buf.length);
  this._ensure(buf.length);
  buf.copy(this._buf, this._offset, 0, buf.length);
  this._offset += buf.length;
};
Writer.prototype.writeStringArray = function(strings) {
  if (!strings instanceof Array)
    throw new TypeError("argument must be an Array[String]");
  var self2 = this;
  strings.forEach(function(s) {
    self2.writeString(s);
  });
};
Writer.prototype.writeOID = function(s, tag) {
  if (typeof s !== "string")
    throw new TypeError("argument must be a string");
  if (typeof tag !== "number")
    tag = ASN1.OID;
  if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
    throw new Error("argument is not a valid OID string");
  function encodeOctet(bytes2, octet) {
    if (octet < 128) {
      bytes2.push(octet);
    } else if (octet < 16384) {
      bytes2.push(octet >>> 7 | 128);
      bytes2.push(octet & 127);
    } else if (octet < 2097152) {
      bytes2.push(octet >>> 14 | 128);
      bytes2.push((octet >>> 7 | 128) & 255);
      bytes2.push(octet & 127);
    } else if (octet < 268435456) {
      bytes2.push(octet >>> 21 | 128);
      bytes2.push((octet >>> 14 | 128) & 255);
      bytes2.push((octet >>> 7 | 128) & 255);
      bytes2.push(octet & 127);
    } else {
      bytes2.push((octet >>> 28 | 128) & 255);
      bytes2.push((octet >>> 21 | 128) & 255);
      bytes2.push((octet >>> 14 | 128) & 255);
      bytes2.push((octet >>> 7 | 128) & 255);
      bytes2.push(octet & 127);
    }
  }
  var tmp = s.split(".");
  var bytes = [];
  bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
  tmp.slice(2).forEach(function(b) {
    encodeOctet(bytes, parseInt(b, 10));
  });
  var self2 = this;
  this._ensure(2 + bytes.length);
  this.writeByte(tag);
  this.writeLength(bytes.length);
  bytes.forEach(function(b) {
    self2.writeByte(b);
  });
};
Writer.prototype.writeLength = function(len) {
  if (typeof len !== "number")
    throw new TypeError("argument must be a Number");
  this._ensure(4);
  if (len <= 127) {
    this._buf[this._offset++] = len;
  } else if (len <= 255) {
    this._buf[this._offset++] = 129;
    this._buf[this._offset++] = len;
  } else if (len <= 65535) {
    this._buf[this._offset++] = 130;
    this._buf[this._offset++] = len >> 8;
    this._buf[this._offset++] = len;
  } else if (len <= 16777215) {
    this._buf[this._offset++] = 131;
    this._buf[this._offset++] = len >> 16;
    this._buf[this._offset++] = len >> 8;
    this._buf[this._offset++] = len;
  } else {
    throw newInvalidAsn1Error("Length too long (> 4 bytes)");
  }
};
Writer.prototype.startSequence = function(tag) {
  if (typeof tag !== "number")
    tag = ASN1.Sequence | ASN1.Constructor;
  this.writeByte(tag);
  this._seq.push(this._offset);
  this._ensure(3);
  this._offset += 3;
};
Writer.prototype.endSequence = function() {
  var seq = this._seq.pop();
  var start = seq + 3;
  var len = this._offset - start;
  if (len <= 127) {
    this._shift(start, len, -2);
    this._buf[seq] = len;
  } else if (len <= 255) {
    this._shift(start, len, -1);
    this._buf[seq] = 129;
    this._buf[seq + 1] = len;
  } else if (len <= 65535) {
    this._buf[seq] = 130;
    this._buf[seq + 1] = len >> 8;
    this._buf[seq + 2] = len;
  } else if (len <= 16777215) {
    this._shift(start, len, 1);
    this._buf[seq] = 131;
    this._buf[seq + 1] = len >> 16;
    this._buf[seq + 2] = len >> 8;
    this._buf[seq + 3] = len;
  } else {
    throw newInvalidAsn1Error("Sequence too long");
  }
};
Writer.prototype._shift = function(start, len, shift) {
  assert$1.ok(start !== void 0);
  assert$1.ok(len !== void 0);
  assert$1.ok(shift);
  this._buf.copy(this._buf, start + shift, start, start + len);
  this._offset += shift;
};
Writer.prototype._ensure = function(len) {
  assert$1.ok(len);
  if (this._size - this._offset < len) {
    var sz = this._size * this._options.growthFactor;
    if (sz - this._offset < len)
      sz += len;
    var buf = Buffer$1.alloc(sz);
    this._buf.copy(buf, 0, 0, this._offset);
    this._buf = buf;
    this._size = sz;
  }
};
var writer = Writer;
(function(module2) {
  var errors2 = errors$2;
  var types$12 = types;
  var Reader2 = reader;
  var Writer2 = writer;
  module2.exports = {
    Reader: Reader2,
    Writer: Writer2
  };
  for (var t2 in types$12) {
    if (types$12.hasOwnProperty(t2))
      module2.exports[t2] = types$12[t2];
  }
  for (var e in errors2) {
    if (errors2.hasOwnProperty(e))
      module2.exports[e] = errors2[e];
  }
})(ber);
var berExports = ber.exports;
var Ber$2 = berExports;
var lib$1 = {
  Ber: Ber$2,
  BerReader: Ber$2.Reader,
  BerWriter: Ber$2.Writer
};
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var naclFast = { exports: {} };
(function(module2) {
  (function(nacl) {
    var gf = function(init) {
      var i, r = new Float64Array(16);
      if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
      return r;
    };
    var randombytes = function() {
      throw new Error("no PRNG");
    };
    var _0 = new Uint8Array(16);
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function ts64(x, i, h, l) {
      x[i] = h >> 24 & 255;
      x[i + 1] = h >> 16 & 255;
      x[i + 2] = h >> 8 & 255;
      x[i + 3] = h & 255;
      x[i + 4] = l >> 24 & 255;
      x[i + 5] = l >> 16 & 255;
      x[i + 6] = l >> 8 & 255;
      x[i + 7] = l & 255;
    }
    function vn(x, xi, y, yi, n) {
      var i, d = 0;
      for (i = 0; i < n; i++) d |= x[xi + i] ^ y[yi + i];
      return (1 & d - 1 >>> 8) - 1;
    }
    function crypto_verify_16(x, xi, y, yi) {
      return vn(x, xi, y, yi, 16);
    }
    function crypto_verify_32(x, xi, y, yi) {
      return vn(x, xi, y, yi, 32);
    }
    function core_salsa20(o, p, k, c) {
      var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
      for (var i = 0; i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> 32 - 7;
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> 32 - 13;
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 32 - 7;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 32 - 13;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 32 - 7;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 32 - 13;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 32 - 7;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 32 - 13;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> 32 - 7;
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 32 - 13;
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> 32 - 7;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> 32 - 13;
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 32 - 7;
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> 32 - 13;
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 32 - 7;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 32 - 13;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
      }
      x0 = x0 + j0 | 0;
      x1 = x1 + j1 | 0;
      x2 = x2 + j2 | 0;
      x3 = x3 + j3 | 0;
      x4 = x4 + j4 | 0;
      x5 = x5 + j5 | 0;
      x6 = x6 + j6 | 0;
      x7 = x7 + j7 | 0;
      x8 = x8 + j8 | 0;
      x9 = x9 + j9 | 0;
      x10 = x10 + j10 | 0;
      x11 = x11 + j11 | 0;
      x12 = x12 + j12 | 0;
      x13 = x13 + j13 | 0;
      x14 = x14 + j14 | 0;
      x15 = x15 + j15 | 0;
      o[0] = x0 >>> 0 & 255;
      o[1] = x0 >>> 8 & 255;
      o[2] = x0 >>> 16 & 255;
      o[3] = x0 >>> 24 & 255;
      o[4] = x1 >>> 0 & 255;
      o[5] = x1 >>> 8 & 255;
      o[6] = x1 >>> 16 & 255;
      o[7] = x1 >>> 24 & 255;
      o[8] = x2 >>> 0 & 255;
      o[9] = x2 >>> 8 & 255;
      o[10] = x2 >>> 16 & 255;
      o[11] = x2 >>> 24 & 255;
      o[12] = x3 >>> 0 & 255;
      o[13] = x3 >>> 8 & 255;
      o[14] = x3 >>> 16 & 255;
      o[15] = x3 >>> 24 & 255;
      o[16] = x4 >>> 0 & 255;
      o[17] = x4 >>> 8 & 255;
      o[18] = x4 >>> 16 & 255;
      o[19] = x4 >>> 24 & 255;
      o[20] = x5 >>> 0 & 255;
      o[21] = x5 >>> 8 & 255;
      o[22] = x5 >>> 16 & 255;
      o[23] = x5 >>> 24 & 255;
      o[24] = x6 >>> 0 & 255;
      o[25] = x6 >>> 8 & 255;
      o[26] = x6 >>> 16 & 255;
      o[27] = x6 >>> 24 & 255;
      o[28] = x7 >>> 0 & 255;
      o[29] = x7 >>> 8 & 255;
      o[30] = x7 >>> 16 & 255;
      o[31] = x7 >>> 24 & 255;
      o[32] = x8 >>> 0 & 255;
      o[33] = x8 >>> 8 & 255;
      o[34] = x8 >>> 16 & 255;
      o[35] = x8 >>> 24 & 255;
      o[36] = x9 >>> 0 & 255;
      o[37] = x9 >>> 8 & 255;
      o[38] = x9 >>> 16 & 255;
      o[39] = x9 >>> 24 & 255;
      o[40] = x10 >>> 0 & 255;
      o[41] = x10 >>> 8 & 255;
      o[42] = x10 >>> 16 & 255;
      o[43] = x10 >>> 24 & 255;
      o[44] = x11 >>> 0 & 255;
      o[45] = x11 >>> 8 & 255;
      o[46] = x11 >>> 16 & 255;
      o[47] = x11 >>> 24 & 255;
      o[48] = x12 >>> 0 & 255;
      o[49] = x12 >>> 8 & 255;
      o[50] = x12 >>> 16 & 255;
      o[51] = x12 >>> 24 & 255;
      o[52] = x13 >>> 0 & 255;
      o[53] = x13 >>> 8 & 255;
      o[54] = x13 >>> 16 & 255;
      o[55] = x13 >>> 24 & 255;
      o[56] = x14 >>> 0 & 255;
      o[57] = x14 >>> 8 & 255;
      o[58] = x14 >>> 16 & 255;
      o[59] = x14 >>> 24 & 255;
      o[60] = x15 >>> 0 & 255;
      o[61] = x15 >>> 8 & 255;
      o[62] = x15 >>> 16 & 255;
      o[63] = x15 >>> 24 & 255;
    }
    function core_hsalsa20(o, p, k, c) {
      var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
      for (var i = 0; i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> 32 - 7;
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> 32 - 13;
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 32 - 7;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 32 - 13;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 32 - 7;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 32 - 13;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 32 - 7;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 32 - 13;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> 32 - 7;
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 32 - 13;
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> 32 - 7;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> 32 - 13;
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 32 - 7;
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> 32 - 13;
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 32 - 7;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 32 - 13;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
      }
      o[0] = x0 >>> 0 & 255;
      o[1] = x0 >>> 8 & 255;
      o[2] = x0 >>> 16 & 255;
      o[3] = x0 >>> 24 & 255;
      o[4] = x5 >>> 0 & 255;
      o[5] = x5 >>> 8 & 255;
      o[6] = x5 >>> 16 & 255;
      o[7] = x5 >>> 24 & 255;
      o[8] = x10 >>> 0 & 255;
      o[9] = x10 >>> 8 & 255;
      o[10] = x10 >>> 16 & 255;
      o[11] = x10 >>> 24 & 255;
      o[12] = x15 >>> 0 & 255;
      o[13] = x15 >>> 8 & 255;
      o[14] = x15 >>> 16 & 255;
      o[15] = x15 >>> 24 & 255;
      o[16] = x6 >>> 0 & 255;
      o[17] = x6 >>> 8 & 255;
      o[18] = x6 >>> 16 & 255;
      o[19] = x6 >>> 24 & 255;
      o[20] = x7 >>> 0 & 255;
      o[21] = x7 >>> 8 & 255;
      o[22] = x7 >>> 16 & 255;
      o[23] = x7 >>> 24 & 255;
      o[24] = x8 >>> 0 & 255;
      o[25] = x8 >>> 8 & 255;
      o[26] = x8 >>> 16 & 255;
      o[27] = x8 >>> 24 & 255;
      o[28] = x9 >>> 0 & 255;
      o[29] = x9 >>> 8 & 255;
      o[30] = x9 >>> 16 & 255;
      o[31] = x9 >>> 24 & 255;
    }
    function crypto_core_salsa20(out, inp, k, c) {
      core_salsa20(out, inp, k, c);
    }
    function crypto_core_hsalsa20(out, inp, k, c) {
      core_hsalsa20(out, inp, k, c);
    }
    var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
      var z = new Uint8Array(16), x = new Uint8Array(64);
      var u, i;
      for (i = 0; i < 16; i++) z[i] = 0;
      for (i = 0; i < 8; i++) z[i] = n[i];
      while (b >= 64) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0; i < 64; i++) c[cpos + i] = m[mpos + i] ^ x[i];
        u = 1;
        for (i = 8; i < 16; i++) {
          u = u + (z[i] & 255) | 0;
          z[i] = u & 255;
          u >>>= 8;
        }
        b -= 64;
        cpos += 64;
        mpos += 64;
      }
      if (b > 0) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0; i < b; i++) c[cpos + i] = m[mpos + i] ^ x[i];
      }
      return 0;
    }
    function crypto_stream_salsa20(c, cpos, b, n, k) {
      var z = new Uint8Array(16), x = new Uint8Array(64);
      var u, i;
      for (i = 0; i < 16; i++) z[i] = 0;
      for (i = 0; i < 8; i++) z[i] = n[i];
      while (b >= 64) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0; i < 64; i++) c[cpos + i] = x[i];
        u = 1;
        for (i = 8; i < 16; i++) {
          u = u + (z[i] & 255) | 0;
          z[i] = u & 255;
          u >>>= 8;
        }
        b -= 64;
        cpos += 64;
      }
      if (b > 0) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0; i < b; i++) c[cpos + i] = x[i];
      }
      return 0;
    }
    function crypto_stream(c, cpos, d, n, k) {
      var s = new Uint8Array(32);
      crypto_core_hsalsa20(s, n, k, sigma);
      var sn = new Uint8Array(8);
      for (var i = 0; i < 8; i++) sn[i] = n[i + 16];
      return crypto_stream_salsa20(c, cpos, d, sn, s);
    }
    function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
      var s = new Uint8Array(32);
      crypto_core_hsalsa20(s, n, k, sigma);
      var sn = new Uint8Array(8);
      for (var i = 0; i < 8; i++) sn[i] = n[i + 16];
      return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
    }
    var poly13052 = function(key2) {
      this.buffer = new Uint8Array(16);
      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.leftover = 0;
      this.fin = 0;
      var t0, t1, t2, t3, t4, t5, t6, t7;
      t0 = key2[0] & 255 | (key2[1] & 255) << 8;
      this.r[0] = t0 & 8191;
      t1 = key2[2] & 255 | (key2[3] & 255) << 8;
      this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
      t2 = key2[4] & 255 | (key2[5] & 255) << 8;
      this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
      t3 = key2[6] & 255 | (key2[7] & 255) << 8;
      this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
      t4 = key2[8] & 255 | (key2[9] & 255) << 8;
      this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
      this.r[5] = t4 >>> 1 & 8190;
      t5 = key2[10] & 255 | (key2[11] & 255) << 8;
      this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
      t6 = key2[12] & 255 | (key2[13] & 255) << 8;
      this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
      t7 = key2[14] & 255 | (key2[15] & 255) << 8;
      this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
      this.r[9] = t7 >>> 5 & 127;
      this.pad[0] = key2[16] & 255 | (key2[17] & 255) << 8;
      this.pad[1] = key2[18] & 255 | (key2[19] & 255) << 8;
      this.pad[2] = key2[20] & 255 | (key2[21] & 255) << 8;
      this.pad[3] = key2[22] & 255 | (key2[23] & 255) << 8;
      this.pad[4] = key2[24] & 255 | (key2[25] & 255) << 8;
      this.pad[5] = key2[26] & 255 | (key2[27] & 255) << 8;
      this.pad[6] = key2[28] & 255 | (key2[29] & 255) << 8;
      this.pad[7] = key2[30] & 255 | (key2[31] & 255) << 8;
    };
    poly13052.prototype.blocks = function(m, mpos, bytes) {
      var hibit = this.fin ? 0 : 1 << 11;
      var t0, t1, t2, t3, t4, t5, t6, t7, c;
      var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
      var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
      var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
      while (bytes >= 16) {
        t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
        h0 += t0 & 8191;
        t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
        h1 += (t0 >>> 13 | t1 << 3) & 8191;
        t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
        h2 += (t1 >>> 10 | t2 << 6) & 8191;
        t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
        h3 += (t2 >>> 7 | t3 << 9) & 8191;
        t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
        h4 += (t3 >>> 4 | t4 << 12) & 8191;
        h5 += t4 >>> 1 & 8191;
        t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
        h6 += (t4 >>> 14 | t5 << 2) & 8191;
        t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
        h7 += (t5 >>> 11 | t6 << 5) & 8191;
        t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
        h8 += (t6 >>> 8 | t7 << 8) & 8191;
        h9 += t7 >>> 5 | hibit;
        c = 0;
        d0 = c;
        d0 += h0 * r0;
        d0 += h1 * (5 * r9);
        d0 += h2 * (5 * r8);
        d0 += h3 * (5 * r7);
        d0 += h4 * (5 * r6);
        c = d0 >>> 13;
        d0 &= 8191;
        d0 += h5 * (5 * r5);
        d0 += h6 * (5 * r4);
        d0 += h7 * (5 * r3);
        d0 += h8 * (5 * r2);
        d0 += h9 * (5 * r1);
        c += d0 >>> 13;
        d0 &= 8191;
        d1 = c;
        d1 += h0 * r1;
        d1 += h1 * r0;
        d1 += h2 * (5 * r9);
        d1 += h3 * (5 * r8);
        d1 += h4 * (5 * r7);
        c = d1 >>> 13;
        d1 &= 8191;
        d1 += h5 * (5 * r6);
        d1 += h6 * (5 * r5);
        d1 += h7 * (5 * r4);
        d1 += h8 * (5 * r3);
        d1 += h9 * (5 * r2);
        c += d1 >>> 13;
        d1 &= 8191;
        d2 = c;
        d2 += h0 * r2;
        d2 += h1 * r1;
        d2 += h2 * r0;
        d2 += h3 * (5 * r9);
        d2 += h4 * (5 * r8);
        c = d2 >>> 13;
        d2 &= 8191;
        d2 += h5 * (5 * r7);
        d2 += h6 * (5 * r6);
        d2 += h7 * (5 * r5);
        d2 += h8 * (5 * r4);
        d2 += h9 * (5 * r3);
        c += d2 >>> 13;
        d2 &= 8191;
        d3 = c;
        d3 += h0 * r3;
        d3 += h1 * r2;
        d3 += h2 * r1;
        d3 += h3 * r0;
        d3 += h4 * (5 * r9);
        c = d3 >>> 13;
        d3 &= 8191;
        d3 += h5 * (5 * r8);
        d3 += h6 * (5 * r7);
        d3 += h7 * (5 * r6);
        d3 += h8 * (5 * r5);
        d3 += h9 * (5 * r4);
        c += d3 >>> 13;
        d3 &= 8191;
        d4 = c;
        d4 += h0 * r4;
        d4 += h1 * r3;
        d4 += h2 * r2;
        d4 += h3 * r1;
        d4 += h4 * r0;
        c = d4 >>> 13;
        d4 &= 8191;
        d4 += h5 * (5 * r9);
        d4 += h6 * (5 * r8);
        d4 += h7 * (5 * r7);
        d4 += h8 * (5 * r6);
        d4 += h9 * (5 * r5);
        c += d4 >>> 13;
        d4 &= 8191;
        d5 = c;
        d5 += h0 * r5;
        d5 += h1 * r4;
        d5 += h2 * r3;
        d5 += h3 * r2;
        d5 += h4 * r1;
        c = d5 >>> 13;
        d5 &= 8191;
        d5 += h5 * r0;
        d5 += h6 * (5 * r9);
        d5 += h7 * (5 * r8);
        d5 += h8 * (5 * r7);
        d5 += h9 * (5 * r6);
        c += d5 >>> 13;
        d5 &= 8191;
        d6 = c;
        d6 += h0 * r6;
        d6 += h1 * r5;
        d6 += h2 * r4;
        d6 += h3 * r3;
        d6 += h4 * r2;
        c = d6 >>> 13;
        d6 &= 8191;
        d6 += h5 * r1;
        d6 += h6 * r0;
        d6 += h7 * (5 * r9);
        d6 += h8 * (5 * r8);
        d6 += h9 * (5 * r7);
        c += d6 >>> 13;
        d6 &= 8191;
        d7 = c;
        d7 += h0 * r7;
        d7 += h1 * r6;
        d7 += h2 * r5;
        d7 += h3 * r4;
        d7 += h4 * r3;
        c = d7 >>> 13;
        d7 &= 8191;
        d7 += h5 * r2;
        d7 += h6 * r1;
        d7 += h7 * r0;
        d7 += h8 * (5 * r9);
        d7 += h9 * (5 * r8);
        c += d7 >>> 13;
        d7 &= 8191;
        d8 = c;
        d8 += h0 * r8;
        d8 += h1 * r7;
        d8 += h2 * r6;
        d8 += h3 * r5;
        d8 += h4 * r4;
        c = d8 >>> 13;
        d8 &= 8191;
        d8 += h5 * r3;
        d8 += h6 * r2;
        d8 += h7 * r1;
        d8 += h8 * r0;
        d8 += h9 * (5 * r9);
        c += d8 >>> 13;
        d8 &= 8191;
        d9 = c;
        d9 += h0 * r9;
        d9 += h1 * r8;
        d9 += h2 * r7;
        d9 += h3 * r6;
        d9 += h4 * r5;
        c = d9 >>> 13;
        d9 &= 8191;
        d9 += h5 * r4;
        d9 += h6 * r3;
        d9 += h7 * r2;
        d9 += h8 * r1;
        d9 += h9 * r0;
        c += d9 >>> 13;
        d9 &= 8191;
        c = (c << 2) + c | 0;
        c = c + d0 | 0;
        d0 = c & 8191;
        c = c >>> 13;
        d1 += c;
        h0 = d0;
        h1 = d1;
        h2 = d2;
        h3 = d3;
        h4 = d4;
        h5 = d5;
        h6 = d6;
        h7 = d7;
        h8 = d8;
        h9 = d9;
        mpos += 16;
        bytes -= 16;
      }
      this.h[0] = h0;
      this.h[1] = h1;
      this.h[2] = h2;
      this.h[3] = h3;
      this.h[4] = h4;
      this.h[5] = h5;
      this.h[6] = h6;
      this.h[7] = h7;
      this.h[8] = h8;
      this.h[9] = h9;
    };
    poly13052.prototype.finish = function(mac, macpos) {
      var g = new Uint16Array(10);
      var c, mask, f, i;
      if (this.leftover) {
        i = this.leftover;
        this.buffer[i++] = 1;
        for (; i < 16; i++) this.buffer[i] = 0;
        this.fin = 1;
        this.blocks(this.buffer, 0, 16);
      }
      c = this.h[1] >>> 13;
      this.h[1] &= 8191;
      for (i = 2; i < 10; i++) {
        this.h[i] += c;
        c = this.h[i] >>> 13;
        this.h[i] &= 8191;
      }
      this.h[0] += c * 5;
      c = this.h[0] >>> 13;
      this.h[0] &= 8191;
      this.h[1] += c;
      c = this.h[1] >>> 13;
      this.h[1] &= 8191;
      this.h[2] += c;
      g[0] = this.h[0] + 5;
      c = g[0] >>> 13;
      g[0] &= 8191;
      for (i = 1; i < 10; i++) {
        g[i] = this.h[i] + c;
        c = g[i] >>> 13;
        g[i] &= 8191;
      }
      g[9] -= 1 << 13;
      mask = (c ^ 1) - 1;
      for (i = 0; i < 10; i++) g[i] &= mask;
      mask = ~mask;
      for (i = 0; i < 10; i++) this.h[i] = this.h[i] & mask | g[i];
      this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
      this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
      this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
      this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
      this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
      this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
      this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
      this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
      f = this.h[0] + this.pad[0];
      this.h[0] = f & 65535;
      for (i = 1; i < 8; i++) {
        f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
        this.h[i] = f & 65535;
      }
      mac[macpos + 0] = this.h[0] >>> 0 & 255;
      mac[macpos + 1] = this.h[0] >>> 8 & 255;
      mac[macpos + 2] = this.h[1] >>> 0 & 255;
      mac[macpos + 3] = this.h[1] >>> 8 & 255;
      mac[macpos + 4] = this.h[2] >>> 0 & 255;
      mac[macpos + 5] = this.h[2] >>> 8 & 255;
      mac[macpos + 6] = this.h[3] >>> 0 & 255;
      mac[macpos + 7] = this.h[3] >>> 8 & 255;
      mac[macpos + 8] = this.h[4] >>> 0 & 255;
      mac[macpos + 9] = this.h[4] >>> 8 & 255;
      mac[macpos + 10] = this.h[5] >>> 0 & 255;
      mac[macpos + 11] = this.h[5] >>> 8 & 255;
      mac[macpos + 12] = this.h[6] >>> 0 & 255;
      mac[macpos + 13] = this.h[6] >>> 8 & 255;
      mac[macpos + 14] = this.h[7] >>> 0 & 255;
      mac[macpos + 15] = this.h[7] >>> 8 & 255;
    };
    poly13052.prototype.update = function(m, mpos, bytes) {
      var i, want;
      if (this.leftover) {
        want = 16 - this.leftover;
        if (want > bytes)
          want = bytes;
        for (i = 0; i < want; i++)
          this.buffer[this.leftover + i] = m[mpos + i];
        bytes -= want;
        mpos += want;
        this.leftover += want;
        if (this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16);
        this.leftover = 0;
      }
      if (bytes >= 16) {
        want = bytes - bytes % 16;
        this.blocks(m, mpos, want);
        mpos += want;
        bytes -= want;
      }
      if (bytes) {
        for (i = 0; i < bytes; i++)
          this.buffer[this.leftover + i] = m[mpos + i];
        this.leftover += bytes;
      }
    };
    function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
      var s = new poly13052(k);
      s.update(m, mpos, n);
      s.finish(out, outpos);
      return 0;
    }
    function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
      var x = new Uint8Array(16);
      crypto_onetimeauth(x, 0, m, mpos, n, k);
      return crypto_verify_16(h, hpos, x, 0);
    }
    function crypto_secretbox(c, m, d, n, k) {
      var i;
      if (d < 32) return -1;
      crypto_stream_xor(c, 0, m, 0, d, n, k);
      crypto_onetimeauth(c, 16, c, 32, d - 32, c);
      for (i = 0; i < 16; i++) c[i] = 0;
      return 0;
    }
    function crypto_secretbox_open(m, c, d, n, k) {
      var i;
      var x = new Uint8Array(32);
      if (d < 32) return -1;
      crypto_stream(x, 0, 32, n, k);
      if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;
      crypto_stream_xor(m, 0, c, 0, d, n, k);
      for (i = 0; i < 32; i++) m[i] = 0;
      return 0;
    }
    function set25519(r, a) {
      var i;
      for (i = 0; i < 16; i++) r[i] = a[i] | 0;
    }
    function car25519(o) {
      var i, v, c = 1;
      for (i = 0; i < 16; i++) {
        v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
      }
      o[0] += c - 1 + 37 * (c - 1);
    }
    function sel25519(p, q, b) {
      var t2, c = ~(b - 1);
      for (var i = 0; i < 16; i++) {
        t2 = c & (p[i] ^ q[i]);
        p[i] ^= t2;
        q[i] ^= t2;
      }
    }
    function pack25519(o, n) {
      var i, j, b;
      var m = gf(), t2 = gf();
      for (i = 0; i < 16; i++) t2[i] = n[i];
      car25519(t2);
      car25519(t2);
      car25519(t2);
      for (j = 0; j < 2; j++) {
        m[0] = t2[0] - 65517;
        for (i = 1; i < 15; i++) {
          m[i] = t2[i] - 65535 - (m[i - 1] >> 16 & 1);
          m[i - 1] &= 65535;
        }
        m[15] = t2[15] - 32767 - (m[14] >> 16 & 1);
        b = m[15] >> 16 & 1;
        m[14] &= 65535;
        sel25519(t2, m, 1 - b);
      }
      for (i = 0; i < 16; i++) {
        o[2 * i] = t2[i] & 255;
        o[2 * i + 1] = t2[i] >> 8;
      }
    }
    function neq25519(a, b) {
      var c = new Uint8Array(32), d = new Uint8Array(32);
      pack25519(c, a);
      pack25519(d, b);
      return crypto_verify_32(c, 0, d, 0);
    }
    function par25519(a) {
      var d = new Uint8Array(32);
      pack25519(d, a);
      return d[0] & 1;
    }
    function unpack25519(o, n) {
      var i;
      for (i = 0; i < 16; i++) o[i] = n[2 * i] + (n[2 * i + 1] << 8);
      o[15] &= 32767;
    }
    function A(o, a, b) {
      for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
    }
    function Z(o, a, b) {
      for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
    }
    function M(o, a, b) {
      var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    function S(o, a) {
      M(o, a, a);
    }
    function inv25519(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; a++) c[a] = i[a];
      for (a = 253; a >= 0; a--) {
        S(c, c);
        if (a !== 2 && a !== 4) M(c, c, i);
      }
      for (a = 0; a < 16; a++) o[a] = c[a];
    }
    function pow2523(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; a++) c[a] = i[a];
      for (a = 250; a >= 0; a--) {
        S(c, c);
        if (a !== 1) M(c, c, i);
      }
      for (a = 0; a < 16; a++) o[a] = c[a];
    }
    function crypto_scalarmult(q, n, p) {
      var z = new Uint8Array(32);
      var x = new Float64Array(80), r, i;
      var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
      for (i = 0; i < 31; i++) z[i] = n[i];
      z[31] = n[31] & 127 | 64;
      z[0] &= 248;
      unpack25519(x, p);
      for (i = 0; i < 16; i++) {
        b[i] = x[i];
        d[i] = a[i] = c[i] = 0;
      }
      a[0] = d[0] = 1;
      for (i = 254; i >= 0; --i) {
        r = z[i >>> 3] >>> (i & 7) & 1;
        sel25519(a, b, r);
        sel25519(c, d, r);
        A(e, a, c);
        Z(a, a, c);
        A(c, b, d);
        Z(b, b, d);
        S(d, e);
        S(f, a);
        M(a, c, a);
        M(c, b, e);
        A(e, a, c);
        Z(a, a, c);
        S(b, a);
        Z(c, d, f);
        M(a, c, _121665);
        A(a, a, d);
        M(c, c, a);
        M(a, d, f);
        M(d, b, x);
        S(b, e);
        sel25519(a, b, r);
        sel25519(c, d, r);
      }
      for (i = 0; i < 16; i++) {
        x[i + 16] = a[i];
        x[i + 32] = c[i];
        x[i + 48] = b[i];
        x[i + 64] = d[i];
      }
      var x32 = x.subarray(32);
      var x16 = x.subarray(16);
      inv25519(x32, x32);
      M(x16, x16, x32);
      pack25519(q, x16);
      return 0;
    }
    function crypto_scalarmult_base(q, n) {
      return crypto_scalarmult(q, n, _9);
    }
    function crypto_box_keypair(y, x) {
      randombytes(x, 32);
      return crypto_scalarmult_base(y, x);
    }
    function crypto_box_beforenm(k, y, x) {
      var s = new Uint8Array(32);
      crypto_scalarmult(s, x, y);
      return crypto_core_hsalsa20(k, _0, s, sigma);
    }
    var crypto_box_afternm = crypto_secretbox;
    var crypto_box_open_afternm = crypto_secretbox_open;
    function crypto_box(c, m, d, n, y, x) {
      var k = new Uint8Array(32);
      crypto_box_beforenm(k, y, x);
      return crypto_box_afternm(c, m, d, n, k);
    }
    function crypto_box_open(m, c, d, n, y, x) {
      var k = new Uint8Array(32);
      crypto_box_beforenm(k, y, x);
      return crypto_box_open_afternm(m, c, d, n, k);
    }
    var K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function crypto_hashblocks_hl(hh, hl, m, n) {
      var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
      var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
      var pos = 0;
      while (n >= 128) {
        for (i = 0; i < 16; i++) {
          j = 8 * i + pos;
          wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
          wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
        }
        for (i = 0; i < 80; i++) {
          bh0 = ah0;
          bh1 = ah1;
          bh2 = ah2;
          bh3 = ah3;
          bh4 = ah4;
          bh5 = ah5;
          bh6 = ah6;
          bh7 = ah7;
          bl0 = al0;
          bl1 = al1;
          bl2 = al2;
          bl3 = al3;
          bl4 = al4;
          bl5 = al5;
          bl6 = al6;
          bl7 = al7;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = ah4 & ah5 ^ ~ah4 & ah6;
          l = al4 & al5 ^ ~al4 & al6;
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = K[i * 2];
          l = K[i * 2 + 1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = wh[i % 16];
          l = wl[i % 16];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          th = c & 65535 | d << 16;
          tl = a & 65535 | b << 16;
          h = th;
          l = tl;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          bh7 = c & 65535 | d << 16;
          bl7 = a & 65535 | b << 16;
          h = bh3;
          l = bl3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = th;
          l = tl;
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          bh3 = c & 65535 | d << 16;
          bl3 = a & 65535 | b << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i % 16 === 15) {
            for (j = 0; j < 16; j++) {
              h = wh[j];
              l = wl[j];
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = wh[(j + 9) % 16];
              l = wl[(j + 9) % 16];
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              th = wh[(j + 1) % 16];
              tl = wl[(j + 1) % 16];
              h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
              l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              th = wh[(j + 14) % 16];
              tl = wl[(j + 14) % 16];
              h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
              l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              wh[j] = c & 65535 | d << 16;
              wl[j] = a & 65535 | b << 16;
            }
          }
        }
        h = ah0;
        l = al0;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[0];
        l = hl[0];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[0] = ah0 = c & 65535 | d << 16;
        hl[0] = al0 = a & 65535 | b << 16;
        h = ah1;
        l = al1;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[1];
        l = hl[1];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[1] = ah1 = c & 65535 | d << 16;
        hl[1] = al1 = a & 65535 | b << 16;
        h = ah2;
        l = al2;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[2];
        l = hl[2];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[2] = ah2 = c & 65535 | d << 16;
        hl[2] = al2 = a & 65535 | b << 16;
        h = ah3;
        l = al3;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[3];
        l = hl[3];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[3] = ah3 = c & 65535 | d << 16;
        hl[3] = al3 = a & 65535 | b << 16;
        h = ah4;
        l = al4;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[4];
        l = hl[4];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[4] = ah4 = c & 65535 | d << 16;
        hl[4] = al4 = a & 65535 | b << 16;
        h = ah5;
        l = al5;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[5];
        l = hl[5];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[5] = ah5 = c & 65535 | d << 16;
        hl[5] = al5 = a & 65535 | b << 16;
        h = ah6;
        l = al6;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[6];
        l = hl[6];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[6] = ah6 = c & 65535 | d << 16;
        hl[6] = al6 = a & 65535 | b << 16;
        h = ah7;
        l = al7;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[7];
        l = hl[7];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[7] = ah7 = c & 65535 | d << 16;
        hl[7] = al7 = a & 65535 | b << 16;
        pos += 128;
        n -= 128;
      }
      return n;
    }
    function crypto_hash(out, m, n) {
      var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
      hh[0] = 1779033703;
      hh[1] = 3144134277;
      hh[2] = 1013904242;
      hh[3] = 2773480762;
      hh[4] = 1359893119;
      hh[5] = 2600822924;
      hh[6] = 528734635;
      hh[7] = 1541459225;
      hl[0] = 4089235720;
      hl[1] = 2227873595;
      hl[2] = 4271175723;
      hl[3] = 1595750129;
      hl[4] = 2917565137;
      hl[5] = 725511199;
      hl[6] = 4215389547;
      hl[7] = 327033209;
      crypto_hashblocks_hl(hh, hl, m, n);
      n %= 128;
      for (i = 0; i < n; i++) x[i] = m[b - n + i];
      x[n] = 128;
      n = 256 - 128 * (n < 112 ? 1 : 0);
      x[n - 9] = 0;
      ts64(x, n - 8, b / 536870912 | 0, b << 3);
      crypto_hashblocks_hl(hh, hl, x, n);
      for (i = 0; i < 8; i++) ts64(out, 8 * i, hh[i], hl[i]);
      return 0;
    }
    function add(p, q) {
      var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t2 = gf();
      Z(a, p[1], p[0]);
      Z(t2, q[1], q[0]);
      M(a, a, t2);
      A(b, p[0], p[1]);
      A(t2, q[0], q[1]);
      M(b, b, t2);
      M(c, p[3], q[3]);
      M(c, c, D2);
      M(d, p[2], q[2]);
      A(d, d, d);
      Z(e, b, a);
      Z(f, d, c);
      A(g, d, c);
      A(h, b, a);
      M(p[0], e, f);
      M(p[1], h, g);
      M(p[2], g, f);
      M(p[3], e, h);
    }
    function cswap(p, q, b) {
      var i;
      for (i = 0; i < 4; i++) {
        sel25519(p[i], q[i], b);
      }
    }
    function pack(r, p) {
      var tx = gf(), ty = gf(), zi = gf();
      inv25519(zi, p[2]);
      M(tx, p[0], zi);
      M(ty, p[1], zi);
      pack25519(r, ty);
      r[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p, q, s) {
      var b, i;
      set25519(p[0], gf0);
      set25519(p[1], gf1);
      set25519(p[2], gf1);
      set25519(p[3], gf0);
      for (i = 255; i >= 0; --i) {
        b = s[i / 8 | 0] >> (i & 7) & 1;
        cswap(p, q, b);
        add(q, p);
        add(p, p);
        cswap(p, q, b);
      }
    }
    function scalarbase(p, s) {
      var q = [gf(), gf(), gf(), gf()];
      set25519(q[0], X);
      set25519(q[1], Y);
      set25519(q[2], gf1);
      M(q[3], X, Y);
      scalarmult(p, q, s);
    }
    function crypto_sign_keypair(pk, sk, seeded) {
      var d = new Uint8Array(64);
      var p = [gf(), gf(), gf(), gf()];
      var i;
      if (!seeded) randombytes(sk, 32);
      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      scalarbase(p, d);
      pack(pk, p);
      for (i = 0; i < 32; i++) sk[i + 32] = pk[i];
      return 0;
    }
    var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function modL(r, x) {
      var carry, i, j, k;
      for (i = 63; i >= 32; --i) {
        carry = 0;
        for (j = i - 32, k = i - 12; j < k; ++j) {
          x[j] += carry - 16 * x[i] * L[j - (i - 32)];
          carry = x[j] + 128 >> 8;
          x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i] = 0;
      }
      carry = 0;
      for (j = 0; j < 32; j++) {
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
      }
      for (j = 0; j < 32; j++) x[j] -= carry * L[j];
      for (i = 0; i < 32; i++) {
        x[i + 1] += x[i] >> 8;
        r[i] = x[i] & 255;
      }
    }
    function reduce(r) {
      var x = new Float64Array(64), i;
      for (i = 0; i < 64; i++) x[i] = r[i];
      for (i = 0; i < 64; i++) r[i] = 0;
      modL(r, x);
    }
    function crypto_sign(sm, m, n, sk) {
      var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
      var i, j, x = new Float64Array(64);
      var p = [gf(), gf(), gf(), gf()];
      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      var smlen = n + 64;
      for (i = 0; i < n; i++) sm[64 + i] = m[i];
      for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];
      crypto_hash(r, sm.subarray(32), n + 32);
      reduce(r);
      scalarbase(p, r);
      pack(sm, p);
      for (i = 32; i < 64; i++) sm[i] = sk[i];
      crypto_hash(h, sm, n + 64);
      reduce(h);
      for (i = 0; i < 64; i++) x[i] = 0;
      for (i = 0; i < 32; i++) x[i] = r[i];
      for (i = 0; i < 32; i++) {
        for (j = 0; j < 32; j++) {
          x[i + j] += h[i] * d[j];
        }
      }
      modL(sm.subarray(32), x);
      return smlen;
    }
    function unpackneg(r, p) {
      var t2 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r[2], gf1);
      unpack25519(r[1], p);
      S(num, r[1]);
      M(den, num, D);
      Z(num, num, r[2]);
      A(den, r[2], den);
      S(den2, den);
      S(den4, den2);
      M(den6, den4, den2);
      M(t2, den6, num);
      M(t2, t2, den);
      pow2523(t2, t2);
      M(t2, t2, num);
      M(t2, t2, den);
      M(t2, t2, den);
      M(r[0], t2, den);
      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num)) M(r[0], r[0], I);
      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num)) return -1;
      if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
      M(r[3], r[0], r[1]);
      return 0;
    }
    function crypto_sign_open(m, sm, n, pk) {
      var i, mlen;
      var t2 = new Uint8Array(32), h = new Uint8Array(64);
      var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
      mlen = -1;
      if (n < 64) return -1;
      if (unpackneg(q, pk)) return -1;
      for (i = 0; i < n; i++) m[i] = sm[i];
      for (i = 0; i < 32; i++) m[i + 32] = pk[i];
      crypto_hash(h, m, n);
      reduce(h);
      scalarmult(p, q, h);
      scalarbase(q, sm.subarray(32));
      add(p, q);
      pack(t2, p);
      n -= 64;
      if (crypto_verify_32(sm, 0, t2, 0)) {
        for (i = 0; i < n; i++) m[i] = 0;
        return -1;
      }
      for (i = 0; i < n; i++) m[i] = sm[i + 64];
      mlen = n;
      return mlen;
    }
    var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
    nacl.lowlevel = {
      crypto_core_hsalsa20,
      crypto_stream_xor,
      crypto_stream,
      crypto_stream_salsa20_xor,
      crypto_stream_salsa20,
      crypto_onetimeauth,
      crypto_onetimeauth_verify,
      crypto_verify_16,
      crypto_verify_32,
      crypto_secretbox,
      crypto_secretbox_open,
      crypto_scalarmult,
      crypto_scalarmult_base,
      crypto_box_beforenm,
      crypto_box_afternm,
      crypto_box,
      crypto_box_open,
      crypto_box_keypair,
      crypto_hash,
      crypto_sign,
      crypto_sign_keypair,
      crypto_sign_open,
      crypto_secretbox_KEYBYTES,
      crypto_secretbox_NONCEBYTES,
      crypto_secretbox_ZEROBYTES,
      crypto_secretbox_BOXZEROBYTES,
      crypto_scalarmult_BYTES,
      crypto_scalarmult_SCALARBYTES,
      crypto_box_PUBLICKEYBYTES,
      crypto_box_SECRETKEYBYTES,
      crypto_box_BEFORENMBYTES,
      crypto_box_NONCEBYTES,
      crypto_box_ZEROBYTES,
      crypto_box_BOXZEROBYTES,
      crypto_sign_BYTES,
      crypto_sign_PUBLICKEYBYTES,
      crypto_sign_SECRETKEYBYTES,
      crypto_sign_SEEDBYTES,
      crypto_hash_BYTES
    };
    function checkLengths(k, n) {
      if (k.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
      if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
    }
    function checkBoxLengths(pk, sk) {
      if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
      if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
    }
    function checkArrayTypes() {
      var t2, i;
      for (i = 0; i < arguments.length; i++) {
        if ((t2 = Object.prototype.toString.call(arguments[i])) !== "[object Uint8Array]")
          throw new TypeError("unexpected type " + t2 + ", use Uint8Array");
      }
    }
    function cleanup(arr) {
      for (var i = 0; i < arr.length; i++) arr[i] = 0;
    }
    if (!nacl.util) {
      nacl.util = {};
      nacl.util.decodeUTF8 = nacl.util.encodeUTF8 = nacl.util.encodeBase64 = nacl.util.decodeBase64 = function() {
        throw new Error("nacl.util moved into separate package: https://github.com/dchest/tweetnacl-util-js");
      };
    }
    nacl.randomBytes = function(n) {
      var b = new Uint8Array(n);
      randombytes(b, n);
      return b;
    };
    nacl.secretbox = function(msg, nonce, key2) {
      checkArrayTypes(msg, nonce, key2);
      checkLengths(key2, nonce);
      var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
      var c = new Uint8Array(m.length);
      for (var i = 0; i < msg.length; i++) m[i + crypto_secretbox_ZEROBYTES] = msg[i];
      crypto_secretbox(c, m, m.length, nonce, key2);
      return c.subarray(crypto_secretbox_BOXZEROBYTES);
    };
    nacl.secretbox.open = function(box, nonce, key2) {
      checkArrayTypes(box, nonce, key2);
      checkLengths(key2, nonce);
      var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
      var m = new Uint8Array(c.length);
      for (var i = 0; i < box.length; i++) c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
      if (c.length < 32) return false;
      if (crypto_secretbox_open(m, c, c.length, nonce, key2) !== 0) return false;
      return m.subarray(crypto_secretbox_ZEROBYTES);
    };
    nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
    nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
    nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
    nacl.scalarMult = function(n, p) {
      checkArrayTypes(n, p);
      if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
      if (p.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
      var q = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult(q, n, p);
      return q;
    };
    nacl.scalarMult.base = function(n) {
      checkArrayTypes(n);
      if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
      var q = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult_base(q, n);
      return q;
    };
    nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
    nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
    nacl.box = function(msg, nonce, publicKey, secretKey) {
      var k = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox(msg, nonce, k);
    };
    nacl.box.before = function(publicKey, secretKey) {
      checkArrayTypes(publicKey, secretKey);
      checkBoxLengths(publicKey, secretKey);
      var k = new Uint8Array(crypto_box_BEFORENMBYTES);
      crypto_box_beforenm(k, publicKey, secretKey);
      return k;
    };
    nacl.box.after = nacl.secretbox;
    nacl.box.open = function(msg, nonce, publicKey, secretKey) {
      var k = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox.open(msg, nonce, k);
    };
    nacl.box.open.after = nacl.secretbox.open;
    nacl.box.keyPair = function() {
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
      crypto_box_keypair(pk, sk);
      return { publicKey: pk, secretKey: sk };
    };
    nacl.box.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      crypto_scalarmult_base(pk, secretKey);
      return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
    };
    nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
    nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
    nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
    nacl.box.nonceLength = crypto_box_NONCEBYTES;
    nacl.box.overheadLength = nacl.secretbox.overheadLength;
    nacl.sign = function(msg, secretKey) {
      checkArrayTypes(msg, secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
      crypto_sign(signedMsg, msg, msg.length, secretKey);
      return signedMsg;
    };
    nacl.sign.open = function(signedMsg, publicKey) {
      if (arguments.length !== 2)
        throw new Error("nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?");
      checkArrayTypes(signedMsg, publicKey);
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var tmp = new Uint8Array(signedMsg.length);
      var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
      if (mlen < 0) return null;
      var m = new Uint8Array(mlen);
      for (var i = 0; i < m.length; i++) m[i] = tmp[i];
      return m;
    };
    nacl.sign.detached = function(msg, secretKey) {
      var signedMsg = nacl.sign(msg, secretKey);
      var sig = new Uint8Array(crypto_sign_BYTES);
      for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
      return sig;
    };
    nacl.sign.detached.verify = function(msg, sig, publicKey) {
      checkArrayTypes(msg, sig, publicKey);
      if (sig.length !== crypto_sign_BYTES)
        throw new Error("bad signature size");
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
      var m = new Uint8Array(crypto_sign_BYTES + msg.length);
      var i;
      for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
      for (i = 0; i < msg.length; i++) sm[i + crypto_sign_BYTES] = msg[i];
      return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
    };
    nacl.sign.keyPair = function() {
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      crypto_sign_keypair(pk, sk);
      return { publicKey: pk, secretKey: sk };
    };
    nacl.sign.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32 + i];
      return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
    };
    nacl.sign.keyPair.fromSeed = function(seed) {
      checkArrayTypes(seed);
      if (seed.length !== crypto_sign_SEEDBYTES)
        throw new Error("bad seed size");
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      for (var i = 0; i < 32; i++) sk[i] = seed[i];
      crypto_sign_keypair(pk, sk, true);
      return { publicKey: pk, secretKey: sk };
    };
    nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
    nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
    nacl.sign.seedLength = crypto_sign_SEEDBYTES;
    nacl.sign.signatureLength = crypto_sign_BYTES;
    nacl.hash = function(msg) {
      checkArrayTypes(msg);
      var h = new Uint8Array(crypto_hash_BYTES);
      crypto_hash(h, msg, msg.length);
      return h;
    };
    nacl.hash.hashLength = crypto_hash_BYTES;
    nacl.verify = function(x, y) {
      checkArrayTypes(x, y);
      if (x.length === 0 || y.length === 0) return false;
      if (x.length !== y.length) return false;
      return vn(x, 0, y, 0, x.length) === 0 ? true : false;
    };
    nacl.setPRNG = function(fn) {
      randombytes = fn;
    };
    (function() {
      var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
      if (crypto2 && crypto2.getRandomValues) {
        var QUOTA = 65536;
        nacl.setPRNG(function(x, n) {
          var i, v = new Uint8Array(n);
          for (i = 0; i < n; i += QUOTA) {
            crypto2.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
          }
          for (i = 0; i < n; i++) x[i] = v[i];
          cleanup(v);
        });
      } else if (typeof commonjsRequire !== "undefined") {
        crypto2 = require$$0$3;
        if (crypto2 && crypto2.randomBytes) {
          nacl.setPRNG(function(x, n) {
            var i, v = crypto2.randomBytes(n);
            for (i = 0; i < n; i++) x[i] = v[i];
            cleanup(v);
          });
        }
      }
    })();
  })(module2.exports ? module2.exports : self.nacl = self.nacl || {});
})(naclFast);
var naclFastExports = naclFast.exports;
var crypto_hash_sha512 = naclFastExports.lowlevel.crypto_hash;
var BLF_J = 0;
var Blowfish = function() {
  this.S = [
    new Uint32Array([
      3509652390,
      2564797868,
      805139163,
      3491422135,
      3101798381,
      1780907670,
      3128725573,
      4046225305,
      614570311,
      3012652279,
      134345442,
      2240740374,
      1667834072,
      1901547113,
      2757295779,
      4103290238,
      227898511,
      1921955416,
      1904987480,
      2182433518,
      2069144605,
      3260701109,
      2620446009,
      720527379,
      3318853667,
      677414384,
      3393288472,
      3101374703,
      2390351024,
      1614419982,
      1822297739,
      2954791486,
      3608508353,
      3174124327,
      2024746970,
      1432378464,
      3864339955,
      2857741204,
      1464375394,
      1676153920,
      1439316330,
      715854006,
      3033291828,
      289532110,
      2706671279,
      2087905683,
      3018724369,
      1668267050,
      732546397,
      1947742710,
      3462151702,
      2609353502,
      2950085171,
      1814351708,
      2050118529,
      680887927,
      999245976,
      1800124847,
      3300911131,
      1713906067,
      1641548236,
      4213287313,
      1216130144,
      1575780402,
      4018429277,
      3917837745,
      3693486850,
      3949271944,
      596196993,
      3549867205,
      258830323,
      2213823033,
      772490370,
      2760122372,
      1774776394,
      2652871518,
      566650946,
      4142492826,
      1728879713,
      2882767088,
      1783734482,
      3629395816,
      2517608232,
      2874225571,
      1861159788,
      326777828,
      3124490320,
      2130389656,
      2716951837,
      967770486,
      1724537150,
      2185432712,
      2364442137,
      1164943284,
      2105845187,
      998989502,
      3765401048,
      2244026483,
      1075463327,
      1455516326,
      1322494562,
      910128902,
      469688178,
      1117454909,
      936433444,
      3490320968,
      3675253459,
      1240580251,
      122909385,
      2157517691,
      634681816,
      4142456567,
      3825094682,
      3061402683,
      2540495037,
      79693498,
      3249098678,
      1084186820,
      1583128258,
      426386531,
      1761308591,
      1047286709,
      322548459,
      995290223,
      1845252383,
      2603652396,
      3431023940,
      2942221577,
      3202600964,
      3727903485,
      1712269319,
      422464435,
      3234572375,
      1170764815,
      3523960633,
      3117677531,
      1434042557,
      442511882,
      3600875718,
      1076654713,
      1738483198,
      4213154764,
      2393238008,
      3677496056,
      1014306527,
      4251020053,
      793779912,
      2902807211,
      842905082,
      4246964064,
      1395751752,
      1040244610,
      2656851899,
      3396308128,
      445077038,
      3742853595,
      3577915638,
      679411651,
      2892444358,
      2354009459,
      1767581616,
      3150600392,
      3791627101,
      3102740896,
      284835224,
      4246832056,
      1258075500,
      768725851,
      2589189241,
      3069724005,
      3532540348,
      1274779536,
      3789419226,
      2764799539,
      1660621633,
      3471099624,
      4011903706,
      913787905,
      3497959166,
      737222580,
      2514213453,
      2928710040,
      3937242737,
      1804850592,
      3499020752,
      2949064160,
      2386320175,
      2390070455,
      2415321851,
      4061277028,
      2290661394,
      2416832540,
      1336762016,
      1754252060,
      3520065937,
      3014181293,
      791618072,
      3188594551,
      3933548030,
      2332172193,
      3852520463,
      3043980520,
      413987798,
      3465142937,
      3030929376,
      4245938359,
      2093235073,
      3534596313,
      375366246,
      2157278981,
      2479649556,
      555357303,
      3870105701,
      2008414854,
      3344188149,
      4221384143,
      3956125452,
      2067696032,
      3594591187,
      2921233993,
      2428461,
      544322398,
      577241275,
      1471733935,
      610547355,
      4027169054,
      1432588573,
      1507829418,
      2025931657,
      3646575487,
      545086370,
      48609733,
      2200306550,
      1653985193,
      298326376,
      1316178497,
      3007786442,
      2064951626,
      458293330,
      2589141269,
      3591329599,
      3164325604,
      727753846,
      2179363840,
      146436021,
      1461446943,
      4069977195,
      705550613,
      3059967265,
      3887724982,
      4281599278,
      3313849956,
      1404054877,
      2845806497,
      146425753,
      1854211946
    ]),
    new Uint32Array([
      1266315497,
      3048417604,
      3681880366,
      3289982499,
      290971e4,
      1235738493,
      2632868024,
      2414719590,
      3970600049,
      1771706367,
      1449415276,
      3266420449,
      422970021,
      1963543593,
      2690192192,
      3826793022,
      1062508698,
      1531092325,
      1804592342,
      2583117782,
      2714934279,
      4024971509,
      1294809318,
      4028980673,
      1289560198,
      2221992742,
      1669523910,
      35572830,
      157838143,
      1052438473,
      1016535060,
      1802137761,
      1753167236,
      1386275462,
      3080475397,
      2857371447,
      1040679964,
      2145300060,
      2390574316,
      1461121720,
      2956646967,
      4031777805,
      4028374788,
      33600511,
      2920084762,
      1018524850,
      629373528,
      3691585981,
      3515945977,
      2091462646,
      2486323059,
      586499841,
      988145025,
      935516892,
      3367335476,
      2599673255,
      2839830854,
      265290510,
      3972581182,
      2759138881,
      3795373465,
      1005194799,
      847297441,
      406762289,
      1314163512,
      1332590856,
      1866599683,
      4127851711,
      750260880,
      613907577,
      1450815602,
      3165620655,
      3734664991,
      3650291728,
      3012275730,
      3704569646,
      1427272223,
      778793252,
      1343938022,
      2676280711,
      2052605720,
      1946737175,
      3164576444,
      3914038668,
      3967478842,
      3682934266,
      1661551462,
      3294938066,
      4011595847,
      840292616,
      3712170807,
      616741398,
      312560963,
      711312465,
      1351876610,
      322626781,
      1910503582,
      271666773,
      2175563734,
      1594956187,
      70604529,
      3617834859,
      1007753275,
      1495573769,
      4069517037,
      2549218298,
      2663038764,
      504708206,
      2263041392,
      3941167025,
      2249088522,
      1514023603,
      1998579484,
      1312622330,
      694541497,
      2582060303,
      2151582166,
      1382467621,
      776784248,
      2618340202,
      3323268794,
      2497899128,
      2784771155,
      503983604,
      4076293799,
      907881277,
      423175695,
      432175456,
      1378068232,
      4145222326,
      3954048622,
      3938656102,
      3820766613,
      2793130115,
      2977904593,
      26017576,
      3274890735,
      3194772133,
      1700274565,
      1756076034,
      4006520079,
      3677328699,
      720338349,
      1533947780,
      354530856,
      688349552,
      3973924725,
      1637815568,
      332179504,
      3949051286,
      53804574,
      2852348879,
      3044236432,
      1282449977,
      3583942155,
      3416972820,
      4006381244,
      1617046695,
      2628476075,
      3002303598,
      1686838959,
      431878346,
      2686675385,
      1700445008,
      1080580658,
      1009431731,
      832498133,
      3223435511,
      2605976345,
      2271191193,
      2516031870,
      1648197032,
      4164389018,
      2548247927,
      300782431,
      375919233,
      238389289,
      3353747414,
      2531188641,
      2019080857,
      1475708069,
      455242339,
      2609103871,
      448939670,
      3451063019,
      1395535956,
      2413381860,
      1841049896,
      1491858159,
      885456874,
      4264095073,
      4001119347,
      1565136089,
      3898914787,
      1108368660,
      540939232,
      1173283510,
      2745871338,
      3681308437,
      4207628240,
      3343053890,
      4016749493,
      1699691293,
      1103962373,
      3625875870,
      2256883143,
      3830138730,
      1031889488,
      3479347698,
      1535977030,
      4236805024,
      3251091107,
      2132092099,
      1774941330,
      1199868427,
      1452454533,
      157007616,
      2904115357,
      342012276,
      595725824,
      1480756522,
      206960106,
      497939518,
      591360097,
      863170706,
      2375253569,
      3596610801,
      1814182875,
      2094937945,
      3421402208,
      1082520231,
      3463918190,
      2785509508,
      435703966,
      3908032597,
      1641649973,
      2842273706,
      3305899714,
      1510255612,
      2148256476,
      2655287854,
      3276092548,
      4258621189,
      236887753,
      3681803219,
      274041037,
      1734335097,
      3815195456,
      3317970021,
      1899903192,
      1026095262,
      4050517792,
      356393447,
      2410691914,
      3873677099,
      3682840055
    ]),
    new Uint32Array([
      3913112168,
      2491498743,
      4132185628,
      2489919796,
      1091903735,
      1979897079,
      3170134830,
      3567386728,
      3557303409,
      857797738,
      1136121015,
      1342202287,
      507115054,
      2535736646,
      337727348,
      3213592640,
      1301675037,
      2528481711,
      1895095763,
      1721773893,
      3216771564,
      62756741,
      2142006736,
      835421444,
      2531993523,
      1442658625,
      3659876326,
      2882144922,
      676362277,
      1392781812,
      170690266,
      3921047035,
      1759253602,
      3611846912,
      1745797284,
      664899054,
      1329594018,
      3901205900,
      3045908486,
      2062866102,
      2865634940,
      3543621612,
      3464012697,
      1080764994,
      553557557,
      3656615353,
      3996768171,
      991055499,
      499776247,
      1265440854,
      648242737,
      3940784050,
      980351604,
      3713745714,
      1749149687,
      3396870395,
      4211799374,
      3640570775,
      1161844396,
      3125318951,
      1431517754,
      545492359,
      4268468663,
      3499529547,
      1437099964,
      2702547544,
      3433638243,
      2581715763,
      2787789398,
      1060185593,
      1593081372,
      2418618748,
      4260947970,
      69676912,
      2159744348,
      86519011,
      2512459080,
      3838209314,
      1220612927,
      3339683548,
      133810670,
      1090789135,
      1078426020,
      1569222167,
      845107691,
      3583754449,
      4072456591,
      1091646820,
      628848692,
      1613405280,
      3757631651,
      526609435,
      236106946,
      48312990,
      2942717905,
      3402727701,
      1797494240,
      859738849,
      992217954,
      4005476642,
      2243076622,
      3870952857,
      3732016268,
      765654824,
      3490871365,
      2511836413,
      1685915746,
      3888969200,
      1414112111,
      2273134842,
      3281911079,
      4080962846,
      172450625,
      2569994100,
      980381355,
      4109958455,
      2819808352,
      2716589560,
      2568741196,
      3681446669,
      3329971472,
      1835478071,
      660984891,
      3704678404,
      4045999559,
      3422617507,
      3040415634,
      1762651403,
      1719377915,
      3470491036,
      2693910283,
      3642056355,
      3138596744,
      1364962596,
      2073328063,
      1983633131,
      926494387,
      3423689081,
      2150032023,
      4096667949,
      1749200295,
      3328846651,
      309677260,
      2016342300,
      1779581495,
      3079819751,
      111262694,
      1274766160,
      443224088,
      298511866,
      1025883608,
      3806446537,
      1145181785,
      168956806,
      3641502830,
      3584813610,
      1689216846,
      3666258015,
      3200248200,
      1692713982,
      2646376535,
      4042768518,
      1618508792,
      1610833997,
      3523052358,
      4130873264,
      2001055236,
      3610705100,
      2202168115,
      4028541809,
      2961195399,
      1006657119,
      2006996926,
      3186142756,
      1430667929,
      3210227297,
      1314452623,
      4074634658,
      4101304120,
      2273951170,
      1399257539,
      3367210612,
      3027628629,
      1190975929,
      2062231137,
      2333990788,
      2221543033,
      2438960610,
      1181637006,
      548689776,
      2362791313,
      3372408396,
      3104550113,
      3145860560,
      296247880,
      1970579870,
      3078560182,
      3769228297,
      1714227617,
      3291629107,
      3898220290,
      166772364,
      1251581989,
      493813264,
      448347421,
      195405023,
      2709975567,
      677966185,
      3703036547,
      1463355134,
      2715995803,
      1338867538,
      1343315457,
      2802222074,
      2684532164,
      233230375,
      2599980071,
      2000651841,
      3277868038,
      1638401717,
      4028070440,
      3237316320,
      6314154,
      819756386,
      300326615,
      590932579,
      1405279636,
      3267499572,
      3150704214,
      2428286686,
      3959192993,
      3461946742,
      1862657033,
      1266418056,
      963775037,
      2089974820,
      2263052895,
      1917689273,
      448879540,
      3550394620,
      3981727096,
      150775221,
      3627908307,
      1303187396,
      508620638,
      2975983352,
      2726630617,
      1817252668,
      1876281319,
      1457606340,
      908771278,
      3720792119,
      3617206836,
      2455994898,
      1729034894,
      1080033504
    ]),
    new Uint32Array([
      976866871,
      3556439503,
      2881648439,
      1522871579,
      1555064734,
      1336096578,
      3548522304,
      2579274686,
      3574697629,
      3205460757,
      3593280638,
      3338716283,
      3079412587,
      564236357,
      2993598910,
      1781952180,
      1464380207,
      3163844217,
      3332601554,
      1699332808,
      1393555694,
      1183702653,
      3581086237,
      1288719814,
      691649499,
      2847557200,
      2895455976,
      3193889540,
      2717570544,
      1781354906,
      1676643554,
      2592534050,
      3230253752,
      1126444790,
      2770207658,
      2633158820,
      2210423226,
      2615765581,
      2414155088,
      3127139286,
      673620729,
      2805611233,
      1269405062,
      4015350505,
      3341807571,
      4149409754,
      1057255273,
      2012875353,
      2162469141,
      2276492801,
      2601117357,
      993977747,
      3918593370,
      2654263191,
      753973209,
      36408145,
      2530585658,
      25011837,
      3520020182,
      2088578344,
      530523599,
      2918365339,
      1524020338,
      1518925132,
      3760827505,
      3759777254,
      1202760957,
      3985898139,
      3906192525,
      674977740,
      4174734889,
      2031300136,
      2019492241,
      3983892565,
      4153806404,
      3822280332,
      352677332,
      2297720250,
      60907813,
      90501309,
      3286998549,
      1016092578,
      2535922412,
      2839152426,
      457141659,
      509813237,
      4120667899,
      652014361,
      1966332200,
      2975202805,
      55981186,
      2327461051,
      676427537,
      3255491064,
      2882294119,
      3433927263,
      1307055953,
      942726286,
      933058658,
      2468411793,
      3933900994,
      4215176142,
      1361170020,
      2001714738,
      2830558078,
      3274259782,
      1222529897,
      1679025792,
      2729314320,
      3714953764,
      1770335741,
      151462246,
      3013232138,
      1682292957,
      1483529935,
      471910574,
      1539241949,
      458788160,
      3436315007,
      1807016891,
      3718408830,
      978976581,
      1043663428,
      3165965781,
      1927990952,
      4200891579,
      2372276910,
      3208408903,
      3533431907,
      1412390302,
      2931980059,
      4132332400,
      1947078029,
      3881505623,
      4168226417,
      2941484381,
      1077988104,
      1320477388,
      886195818,
      18198404,
      3786409e3,
      2509781533,
      112762804,
      3463356488,
      1866414978,
      891333506,
      18488651,
      661792760,
      1628790961,
      3885187036,
      3141171499,
      876946877,
      2693282273,
      1372485963,
      791857591,
      2686433993,
      3759982718,
      3167212022,
      3472953795,
      2716379847,
      445679433,
      3561995674,
      3504004811,
      3574258232,
      54117162,
      3331405415,
      2381918588,
      3769707343,
      4154350007,
      1140177722,
      4074052095,
      668550556,
      3214352940,
      367459370,
      261225585,
      2610173221,
      4209349473,
      3468074219,
      3265815641,
      314222801,
      3066103646,
      3808782860,
      282218597,
      3406013506,
      3773591054,
      379116347,
      1285071038,
      846784868,
      2669647154,
      3771962079,
      3550491691,
      2305946142,
      453669953,
      1268987020,
      3317592352,
      3279303384,
      3744833421,
      2610507566,
      3859509063,
      266596637,
      3847019092,
      517658769,
      3462560207,
      3443424879,
      370717030,
      4247526661,
      2224018117,
      4143653529,
      4112773975,
      2788324899,
      2477274417,
      1456262402,
      2901442914,
      1517677493,
      1846949527,
      2295493580,
      3734397586,
      2176403920,
      1280348187,
      1908823572,
      3871786941,
      846861322,
      1172426758,
      3287448474,
      3383383037,
      1655181056,
      3139813346,
      901632758,
      1897031941,
      2986607138,
      3066810236,
      3447102507,
      1393639104,
      373351379,
      950779232,
      625454576,
      3124240540,
      4148612726,
      2007998917,
      544563296,
      2244738638,
      2330496472,
      2058025392,
      1291430526,
      424198748,
      50039436,
      29584100,
      3605783033,
      2429876329,
      2791104160,
      1057563949,
      3255363231,
      3075367218,
      3463963227,
      1469046755,
      985887462
    ])
  ];
  this.P = new Uint32Array([
    608135816,
    2242054355,
    320440878,
    57701188,
    2752067618,
    698298832,
    137296536,
    3964562569,
    1160258022,
    953160567,
    3193202383,
    887688300,
    3232508343,
    3380367581,
    1065670069,
    3041331479,
    2450970073,
    2306472731
  ]);
};
function F(S, x8, i) {
  return (S[0][x8[i + 3]] + S[1][x8[i + 2]] ^ S[2][x8[i + 1]]) + S[3][x8[i]];
}
Blowfish.prototype.encipher = function(x, x8) {
  if (x8 === void 0) {
    x8 = new Uint8Array(x.buffer);
    if (x.byteOffset !== 0)
      x8 = x8.subarray(x.byteOffset);
  }
  x[0] ^= this.P[0];
  for (var i = 1; i < 16; i += 2) {
    x[1] ^= F(this.S, x8, 0) ^ this.P[i];
    x[0] ^= F(this.S, x8, 4) ^ this.P[i + 1];
  }
  var t2 = x[0];
  x[0] = x[1] ^ this.P[17];
  x[1] = t2;
};
Blowfish.prototype.decipher = function(x) {
  var x8 = new Uint8Array(x.buffer);
  if (x.byteOffset !== 0)
    x8 = x8.subarray(x.byteOffset);
  x[0] ^= this.P[17];
  for (var i = 16; i > 0; i -= 2) {
    x[1] ^= F(this.S, x8, 0) ^ this.P[i];
    x[0] ^= F(this.S, x8, 4) ^ this.P[i - 1];
  }
  var t2 = x[0];
  x[0] = x[1] ^ this.P[0];
  x[1] = t2;
};
function stream2word(data, databytes) {
  var i, temp2 = 0;
  for (i = 0; i < 4; i++, BLF_J++) {
    if (BLF_J >= databytes) BLF_J = 0;
    temp2 = temp2 << 8 | data[BLF_J];
  }
  return temp2;
}
Blowfish.prototype.expand0state = function(key2, keybytes) {
  var d = new Uint32Array(2), i, k;
  var d8 = new Uint8Array(d.buffer);
  for (i = 0, BLF_J = 0; i < 18; i++) {
    this.P[i] ^= stream2word(key2, keybytes);
  }
  BLF_J = 0;
  for (i = 0; i < 18; i += 2) {
    this.encipher(d, d8);
    this.P[i] = d[0];
    this.P[i + 1] = d[1];
  }
  for (i = 0; i < 4; i++) {
    for (k = 0; k < 256; k += 2) {
      this.encipher(d, d8);
      this.S[i][k] = d[0];
      this.S[i][k + 1] = d[1];
    }
  }
};
Blowfish.prototype.expandstate = function(data, databytes, key2, keybytes) {
  var d = new Uint32Array(2), i, k;
  for (i = 0, BLF_J = 0; i < 18; i++) {
    this.P[i] ^= stream2word(key2, keybytes);
  }
  for (i = 0, BLF_J = 0; i < 18; i += 2) {
    d[0] ^= stream2word(data, databytes);
    d[1] ^= stream2word(data, databytes);
    this.encipher(d);
    this.P[i] = d[0];
    this.P[i + 1] = d[1];
  }
  for (i = 0; i < 4; i++) {
    for (k = 0; k < 256; k += 2) {
      d[0] ^= stream2word(data, databytes);
      d[1] ^= stream2word(data, databytes);
      this.encipher(d);
      this.S[i][k] = d[0];
      this.S[i][k + 1] = d[1];
    }
  }
  BLF_J = 0;
};
Blowfish.prototype.enc = function(data, blocks) {
  for (var i = 0; i < blocks; i++) {
    this.encipher(data.subarray(i * 2));
  }
};
Blowfish.prototype.dec = function(data, blocks) {
  for (var i = 0; i < blocks; i++) {
    this.decipher(data.subarray(i * 2));
  }
};
var BCRYPT_BLOCKS = 8, BCRYPT_HASHSIZE = 32;
function bcrypt_hash(sha2pass, sha2salt, out) {
  var state = new Blowfish(), cdata = new Uint32Array(BCRYPT_BLOCKS), i, ciphertext = new Uint8Array([
    79,
    120,
    121,
    99,
    104,
    114,
    111,
    109,
    97,
    116,
    105,
    99,
    66,
    108,
    111,
    119,
    102,
    105,
    115,
    104,
    83,
    119,
    97,
    116,
    68,
    121,
    110,
    97,
    109,
    105,
    116,
    101
  ]);
  state.expandstate(sha2salt, 64, sha2pass, 64);
  for (i = 0; i < 64; i++) {
    state.expand0state(sha2salt, 64);
    state.expand0state(sha2pass, 64);
  }
  for (i = 0; i < BCRYPT_BLOCKS; i++)
    cdata[i] = stream2word(ciphertext, ciphertext.byteLength);
  for (i = 0; i < 64; i++)
    state.enc(cdata, cdata.byteLength / 8);
  for (i = 0; i < BCRYPT_BLOCKS; i++) {
    out[4 * i + 3] = cdata[i] >>> 24;
    out[4 * i + 2] = cdata[i] >>> 16;
    out[4 * i + 1] = cdata[i] >>> 8;
    out[4 * i + 0] = cdata[i];
  }
}
function bcrypt_pbkdf$2(pass, passlen, salt, saltlen, key2, keylen, rounds) {
  var sha2pass = new Uint8Array(64), sha2salt = new Uint8Array(64), out = new Uint8Array(BCRYPT_HASHSIZE), tmpout = new Uint8Array(BCRYPT_HASHSIZE), countsalt = new Uint8Array(saltlen + 4), i, j, amt, stride, dest, count, origkeylen = keylen;
  if (rounds < 1)
    return -1;
  if (passlen === 0 || saltlen === 0 || keylen === 0 || keylen > out.byteLength * out.byteLength || saltlen > 1 << 20)
    return -1;
  stride = Math.floor((keylen + out.byteLength - 1) / out.byteLength);
  amt = Math.floor((keylen + stride - 1) / stride);
  for (i = 0; i < saltlen; i++)
    countsalt[i] = salt[i];
  crypto_hash_sha512(sha2pass, pass, passlen);
  for (count = 1; keylen > 0; count++) {
    countsalt[saltlen + 0] = count >>> 24;
    countsalt[saltlen + 1] = count >>> 16;
    countsalt[saltlen + 2] = count >>> 8;
    countsalt[saltlen + 3] = count;
    crypto_hash_sha512(sha2salt, countsalt, saltlen + 4);
    bcrypt_hash(sha2pass, sha2salt, tmpout);
    for (i = out.byteLength; i--; )
      out[i] = tmpout[i];
    for (i = 1; i < rounds; i++) {
      crypto_hash_sha512(sha2salt, tmpout, tmpout.byteLength);
      bcrypt_hash(sha2pass, sha2salt, tmpout);
      for (j = 0; j < out.byteLength; j++)
        out[j] ^= tmpout[j];
    }
    amt = Math.min(amt, keylen);
    for (i = 0; i < amt; i++) {
      dest = i * stride + (count - 1);
      if (dest >= origkeylen)
        break;
      key2[dest] = out[i];
    }
    keylen -= i;
  }
  return 0;
}
var bcryptPbkdf = {
  pbkdf: bcrypt_pbkdf$2
};
var constants$1 = { exports: {} };
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants$1.exports;
  hasRequiredConstants = 1;
  (function(module2) {
    const crypto2 = require$$0$3;
    let cpuInfo;
    try {
      cpuInfo = require("cpu-features")();
    } catch {
    }
    const { bindingAvailable: bindingAvailable2, CIPHER_INFO: CIPHER_INFO2, MAC_INFO } = requireCrypto();
    const eddsaSupported2 = (() => {
      if (typeof crypto2.sign === "function" && typeof crypto2.verify === "function") {
        const key2 = "-----BEGIN PRIVATE KEY-----\r\nMC4CAQAwBQYDK2VwBCIEIHKj+sVa9WcD/q2DJUJaf43Kptc8xYuUQA4bOFj9vC8T\r\n-----END PRIVATE KEY-----";
        const data = Buffer.from("a");
        let sig;
        let verified;
        try {
          sig = crypto2.sign(null, data, key2);
          verified = crypto2.verify(null, data, key2, sig);
        } catch {
        }
        return Buffer.isBuffer(sig) && sig.length === 64 && verified === true;
      }
      return false;
    })();
    const curve25519Supported = typeof crypto2.diffieHellman === "function" && typeof crypto2.generateKeyPairSync === "function" && typeof crypto2.createPublicKey === "function";
    const DEFAULT_KEX2 = [
      // https://tools.ietf.org/html/rfc5656#section-10.1
      "ecdh-sha2-nistp256",
      "ecdh-sha2-nistp384",
      "ecdh-sha2-nistp521",
      // https://tools.ietf.org/html/rfc4419#section-4
      "diffie-hellman-group-exchange-sha256",
      // https://tools.ietf.org/html/rfc8268
      "diffie-hellman-group14-sha256",
      "diffie-hellman-group15-sha512",
      "diffie-hellman-group16-sha512",
      "diffie-hellman-group17-sha512",
      "diffie-hellman-group18-sha512"
    ];
    if (curve25519Supported) {
      DEFAULT_KEX2.unshift("curve25519-sha256");
      DEFAULT_KEX2.unshift("curve25519-sha256@libssh.org");
    }
    const SUPPORTED_KEX2 = DEFAULT_KEX2.concat([
      // https://tools.ietf.org/html/rfc4419#section-4
      "diffie-hellman-group-exchange-sha1",
      "diffie-hellman-group14-sha1",
      // REQUIRED
      "diffie-hellman-group1-sha1"
      // REQUIRED
    ]);
    const DEFAULT_SERVER_HOST_KEY2 = [
      "ecdsa-sha2-nistp256",
      "ecdsa-sha2-nistp384",
      "ecdsa-sha2-nistp521",
      "rsa-sha2-512",
      // RFC 8332
      "rsa-sha2-256",
      // RFC 8332
      "ssh-rsa"
    ];
    if (eddsaSupported2)
      DEFAULT_SERVER_HOST_KEY2.unshift("ssh-ed25519");
    const SUPPORTED_SERVER_HOST_KEY2 = DEFAULT_SERVER_HOST_KEY2.concat([
      "ssh-dss"
    ]);
    const canUseCipher = (() => {
      const ciphers2 = crypto2.getCiphers();
      return (name) => ciphers2.includes(CIPHER_INFO2[name].sslName);
    })();
    let DEFAULT_CIPHER2 = [
      // http://tools.ietf.org/html/rfc5647
      "aes128-gcm@openssh.com",
      "aes256-gcm@openssh.com",
      // http://tools.ietf.org/html/rfc4344#section-4
      "aes128-ctr",
      "aes192-ctr",
      "aes256-ctr"
    ];
    if (cpuInfo && cpuInfo.flags && !cpuInfo.flags.aes) {
      if (bindingAvailable2)
        DEFAULT_CIPHER2.unshift("chacha20-poly1305@openssh.com");
      else
        DEFAULT_CIPHER2.push("chacha20-poly1305@openssh.com");
    } else if (bindingAvailable2 && cpuInfo && cpuInfo.arch === "x86") {
      DEFAULT_CIPHER2.splice(4, 0, "chacha20-poly1305@openssh.com");
    } else {
      DEFAULT_CIPHER2.push("chacha20-poly1305@openssh.com");
    }
    DEFAULT_CIPHER2 = DEFAULT_CIPHER2.filter(canUseCipher);
    const SUPPORTED_CIPHER2 = DEFAULT_CIPHER2.concat([
      "aes256-cbc",
      "aes192-cbc",
      "aes128-cbc",
      "blowfish-cbc",
      "3des-cbc",
      "aes128-gcm",
      "aes256-gcm",
      // http://tools.ietf.org/html/rfc4345#section-4:
      "arcfour256",
      "arcfour128",
      "cast128-cbc",
      "arcfour"
    ].filter(canUseCipher));
    const canUseMAC = (() => {
      const hashes = crypto2.getHashes();
      return (name) => hashes.includes(MAC_INFO[name].sslName);
    })();
    const DEFAULT_MAC2 = [
      "hmac-sha2-256-etm@openssh.com",
      "hmac-sha2-512-etm@openssh.com",
      "hmac-sha1-etm@openssh.com",
      "hmac-sha2-256",
      "hmac-sha2-512",
      "hmac-sha1"
    ].filter(canUseMAC);
    const SUPPORTED_MAC2 = DEFAULT_MAC2.concat([
      "hmac-md5",
      "hmac-sha2-256-96",
      // first 96 bits of HMAC-SHA256
      "hmac-sha2-512-96",
      // first 96 bits of HMAC-SHA512
      "hmac-ripemd160",
      "hmac-sha1-96",
      // first 96 bits of HMAC-SHA1
      "hmac-md5-96"
      // first 96 bits of HMAC-MD5
    ].filter(canUseMAC));
    const DEFAULT_COMPRESSION2 = [
      "none",
      "zlib@openssh.com",
      // ZLIB (LZ77) compression, except
      // compression/decompression does not start until after
      // successful user authentication
      "zlib"
      // ZLIB (LZ77) compression
    ];
    const SUPPORTED_COMPRESSION2 = DEFAULT_COMPRESSION2.concat([]);
    const COMPAT2 = {
      BAD_DHGEX: 1 << 0,
      OLD_EXIT: 1 << 1,
      DYN_RPORT_BUG: 1 << 2,
      BUG_DHGEX_LARGE: 1 << 3,
      IMPLY_RSA_SHA2_SIGALGS: 1 << 4
    };
    module2.exports = {
      MESSAGE: {
        // Transport layer protocol -- generic (1-19)
        DISCONNECT: 1,
        IGNORE: 2,
        UNIMPLEMENTED: 3,
        DEBUG: 4,
        SERVICE_REQUEST: 5,
        SERVICE_ACCEPT: 6,
        EXT_INFO: 7,
        // RFC 8308
        // Transport layer protocol -- algorithm negotiation (20-29)
        KEXINIT: 20,
        NEWKEYS: 21,
        // Transport layer protocol -- key exchange method-specific (30-49)
        KEXDH_INIT: 30,
        KEXDH_REPLY: 31,
        KEXDH_GEX_GROUP: 31,
        KEXDH_GEX_INIT: 32,
        KEXDH_GEX_REPLY: 33,
        KEXDH_GEX_REQUEST: 34,
        KEXECDH_INIT: 30,
        KEXECDH_REPLY: 31,
        // User auth protocol -- generic (50-59)
        USERAUTH_REQUEST: 50,
        USERAUTH_FAILURE: 51,
        USERAUTH_SUCCESS: 52,
        USERAUTH_BANNER: 53,
        // User auth protocol -- user auth method-specific (60-79)
        USERAUTH_PASSWD_CHANGEREQ: 60,
        USERAUTH_PK_OK: 60,
        USERAUTH_INFO_REQUEST: 60,
        USERAUTH_INFO_RESPONSE: 61,
        // Connection protocol -- generic (80-89)
        GLOBAL_REQUEST: 80,
        REQUEST_SUCCESS: 81,
        REQUEST_FAILURE: 82,
        // Connection protocol -- channel-related (90-127)
        CHANNEL_OPEN: 90,
        CHANNEL_OPEN_CONFIRMATION: 91,
        CHANNEL_OPEN_FAILURE: 92,
        CHANNEL_WINDOW_ADJUST: 93,
        CHANNEL_DATA: 94,
        CHANNEL_EXTENDED_DATA: 95,
        CHANNEL_EOF: 96,
        CHANNEL_CLOSE: 97,
        CHANNEL_REQUEST: 98,
        CHANNEL_SUCCESS: 99,
        CHANNEL_FAILURE: 100
        // Reserved for client protocols (128-191)
        // Local extensions (192-155)
      },
      DISCONNECT_REASON: {
        HOST_NOT_ALLOWED_TO_CONNECT: 1,
        PROTOCOL_ERROR: 2,
        KEY_EXCHANGE_FAILED: 3,
        RESERVED: 4,
        MAC_ERROR: 5,
        COMPRESSION_ERROR: 6,
        SERVICE_NOT_AVAILABLE: 7,
        PROTOCOL_VERSION_NOT_SUPPORTED: 8,
        HOST_KEY_NOT_VERIFIABLE: 9,
        CONNECTION_LOST: 10,
        BY_APPLICATION: 11,
        TOO_MANY_CONNECTIONS: 12,
        AUTH_CANCELED_BY_USER: 13,
        NO_MORE_AUTH_METHODS_AVAILABLE: 14,
        ILLEGAL_USER_NAME: 15
      },
      DISCONNECT_REASON_STR: void 0,
      CHANNEL_OPEN_FAILURE: {
        ADMINISTRATIVELY_PROHIBITED: 1,
        CONNECT_FAILED: 2,
        UNKNOWN_CHANNEL_TYPE: 3,
        RESOURCE_SHORTAGE: 4
      },
      TERMINAL_MODE: {
        TTY_OP_END: 0,
        // Indicates end of options.
        VINTR: 1,
        // Interrupt character; 255 if none. Similarly for the
        //  other characters.  Not all of these characters are
        //  supported on all systems.
        VQUIT: 2,
        // The quit character (sends SIGQUIT signal on POSIX
        //  systems).
        VERASE: 3,
        // Erase the character to left of the cursor.
        VKILL: 4,
        // Kill the current input line.
        VEOF: 5,
        // End-of-file character (sends EOF from the
        //  terminal).
        VEOL: 6,
        // End-of-line character in addition to carriage
        //  return and/or linefeed.
        VEOL2: 7,
        // Additional end-of-line character.
        VSTART: 8,
        // Continues paused output (normally control-Q).
        VSTOP: 9,
        // Pauses output (normally control-S).
        VSUSP: 10,
        // Suspends the current program.
        VDSUSP: 11,
        // Another suspend character.
        VREPRINT: 12,
        // Reprints the current input line.
        VWERASE: 13,
        // Erases a word left of cursor.
        VLNEXT: 14,
        // Enter the next character typed literally, even if
        //  it is a special character
        VFLUSH: 15,
        // Character to flush output.
        VSWTCH: 16,
        // Switch to a different shell layer.
        VSTATUS: 17,
        // Prints system status line (load, command, pid,
        //  etc).
        VDISCARD: 18,
        // Toggles the flushing of terminal output.
        IGNPAR: 30,
        // The ignore parity flag.  The parameter SHOULD be 0
        //  if this flag is FALSE, and 1 if it is TRUE.
        PARMRK: 31,
        // Mark parity and framing errors.
        INPCK: 32,
        // Enable checking of parity errors.
        ISTRIP: 33,
        // Strip 8th bit off characters.
        INLCR: 34,
        // Map NL into CR on input.
        IGNCR: 35,
        // Ignore CR on input.
        ICRNL: 36,
        // Map CR to NL on input.
        IUCLC: 37,
        // Translate uppercase characters to lowercase.
        IXON: 38,
        // Enable output flow control.
        IXANY: 39,
        // Any char will restart after stop.
        IXOFF: 40,
        // Enable input flow control.
        IMAXBEL: 41,
        // Ring bell on input queue full.
        ISIG: 50,
        // Enable signals INTR, QUIT, [D]SUSP.
        ICANON: 51,
        // Canonicalize input lines.
        XCASE: 52,
        // Enable input and output of uppercase characters by
        //  preceding their lowercase equivalents with "\".
        ECHO: 53,
        // Enable echoing.
        ECHOE: 54,
        // Visually erase chars.
        ECHOK: 55,
        // Kill character discards current line.
        ECHONL: 56,
        // Echo NL even if ECHO is off.
        NOFLSH: 57,
        // Don't flush after interrupt.
        TOSTOP: 58,
        // Stop background jobs from output.
        IEXTEN: 59,
        // Enable extensions.
        ECHOCTL: 60,
        // Echo control characters as ^(Char).
        ECHOKE: 61,
        // Visual erase for line kill.
        PENDIN: 62,
        // Retype pending input.
        OPOST: 70,
        // Enable output processing.
        OLCUC: 71,
        // Convert lowercase to uppercase.
        ONLCR: 72,
        // Map NL to CR-NL.
        OCRNL: 73,
        // Translate carriage return to newline (output).
        ONOCR: 74,
        // Translate newline to carriage return-newline
        //  (output).
        ONLRET: 75,
        // Newline performs a carriage return (output).
        CS7: 90,
        // 7 bit mode.
        CS8: 91,
        // 8 bit mode.
        PARENB: 92,
        // Parity enable.
        PARODD: 93,
        // Odd parity, else even.
        TTY_OP_ISPEED: 128,
        // Specifies the input baud rate in bits per second.
        TTY_OP_OSPEED: 129
        // Specifies the output baud rate in bits per second.
      },
      CHANNEL_EXTENDED_DATATYPE: {
        STDERR: 1
      },
      SIGNALS: [
        "ABRT",
        "ALRM",
        "FPE",
        "HUP",
        "ILL",
        "INT",
        "QUIT",
        "SEGV",
        "TERM",
        "USR1",
        "USR2",
        "KILL",
        "PIPE"
      ].reduce((cur, val) => ({ ...cur, [val]: 1 }), {}),
      COMPAT: COMPAT2,
      COMPAT_CHECKS: [
        ["Cisco-1.25", COMPAT2.BAD_DHGEX],
        [/^Cisco-1[.]/, COMPAT2.BUG_DHGEX_LARGE],
        [/^[0-9.]+$/, COMPAT2.OLD_EXIT],
        // old SSH.com implementations
        [/^OpenSSH_5[.][0-9]+/, COMPAT2.DYN_RPORT_BUG],
        [/^OpenSSH_7[.]4/, COMPAT2.IMPLY_RSA_SHA2_SIGALGS]
      ],
      // KEX proposal-related
      DEFAULT_KEX: DEFAULT_KEX2,
      SUPPORTED_KEX: SUPPORTED_KEX2,
      DEFAULT_SERVER_HOST_KEY: DEFAULT_SERVER_HOST_KEY2,
      SUPPORTED_SERVER_HOST_KEY: SUPPORTED_SERVER_HOST_KEY2,
      DEFAULT_CIPHER: DEFAULT_CIPHER2,
      SUPPORTED_CIPHER: SUPPORTED_CIPHER2,
      DEFAULT_MAC: DEFAULT_MAC2,
      SUPPORTED_MAC: SUPPORTED_MAC2,
      DEFAULT_COMPRESSION: DEFAULT_COMPRESSION2,
      SUPPORTED_COMPRESSION: SUPPORTED_COMPRESSION2,
      curve25519Supported,
      eddsaSupported: eddsaSupported2
    };
    module2.exports.DISCONNECT_REASON_BY_VALUE = Array.from(Object.entries(module2.exports.DISCONNECT_REASON)).reduce((obj, [key2, value]) => ({ ...obj, [value]: key2 }), {});
  })(constants$1);
  return constants$1.exports;
}
var utils$1;
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils$1;
  hasRequiredUtils = 1;
  const Ber2 = lib$1.Ber;
  let DISCONNECT_REASON2;
  const FastBuffer2 = Buffer[Symbol.species];
  const TypedArrayFill = Object.getPrototypeOf(Uint8Array.prototype).fill;
  function readUInt32BE2(buf, offset) {
    return buf[offset++] * 16777216 + buf[offset++] * 65536 + buf[offset++] * 256 + buf[offset];
  }
  function bufferCopy2(src, dest, srcStart, srcEnd, destStart) {
    if (!destStart)
      destStart = 0;
    if (srcEnd > src.length)
      srcEnd = src.length;
    let nb = srcEnd - srcStart;
    const destLeft = dest.length - destStart;
    if (nb > destLeft)
      nb = destLeft;
    dest.set(
      new Uint8Array(src.buffer, src.byteOffset + srcStart, nb),
      destStart
    );
    return nb;
  }
  function bufferSlice2(buf, start, end) {
    if (end === void 0)
      end = buf.length;
    return new FastBuffer2(buf.buffer, buf.byteOffset + start, end - start);
  }
  function makeBufferParser2() {
    let pos = 0;
    let buffer2;
    const self2 = {
      init: (buf, start) => {
        buffer2 = buf;
        pos = typeof start === "number" ? start : 0;
      },
      pos: () => pos,
      length: () => buffer2 ? buffer2.length : 0,
      avail: () => buffer2 && pos < buffer2.length ? buffer2.length - pos : 0,
      clear: () => {
        buffer2 = void 0;
      },
      readUInt32BE: () => {
        if (!buffer2 || pos + 3 >= buffer2.length)
          return;
        return buffer2[pos++] * 16777216 + buffer2[pos++] * 65536 + buffer2[pos++] * 256 + buffer2[pos++];
      },
      readUInt64BE: (behavior) => {
        if (!buffer2 || pos + 7 >= buffer2.length)
          return;
        switch (behavior) {
          case "always":
            return BigInt(`0x${buffer2.hexSlice(pos, pos += 8)}`);
          case "maybe":
            if (buffer2[pos] > 31)
              return BigInt(`0x${buffer2.hexSlice(pos, pos += 8)}`);
          default:
            return buffer2[pos++] * 72057594037927940 + buffer2[pos++] * 281474976710656 + buffer2[pos++] * 1099511627776 + buffer2[pos++] * 4294967296 + buffer2[pos++] * 16777216 + buffer2[pos++] * 65536 + buffer2[pos++] * 256 + buffer2[pos++];
        }
      },
      skip: (n) => {
        if (buffer2 && n > 0)
          pos += n;
      },
      skipString: () => {
        const len = self2.readUInt32BE();
        if (len === void 0)
          return;
        pos += len;
        return pos <= buffer2.length ? len : void 0;
      },
      readByte: () => {
        if (buffer2 && pos < buffer2.length)
          return buffer2[pos++];
      },
      readBool: () => {
        if (buffer2 && pos < buffer2.length)
          return !!buffer2[pos++];
      },
      readList: () => {
        const list = self2.readString(true);
        if (list === void 0)
          return;
        return list ? list.split(",") : [];
      },
      readString: (dest, maxLen) => {
        if (typeof dest === "number") {
          maxLen = dest;
          dest = void 0;
        }
        const len = self2.readUInt32BE();
        if (len === void 0)
          return;
        if (buffer2.length - pos < len || typeof maxLen === "number" && len > maxLen) {
          return;
        }
        if (dest) {
          if (Buffer.isBuffer(dest))
            return bufferCopy2(buffer2, dest, pos, pos += len);
          return buffer2.utf8Slice(pos, pos += len);
        }
        return bufferSlice2(buffer2, pos, pos += len);
      },
      readRaw: (len) => {
        if (!buffer2)
          return;
        if (typeof len !== "number")
          return bufferSlice2(buffer2, pos, pos += buffer2.length - pos);
        if (buffer2.length - pos >= len)
          return bufferSlice2(buffer2, pos, pos += len);
      }
    };
    return self2;
  }
  function makeError2(msg, level, fatal) {
    const err = new Error(msg);
    if (typeof level === "boolean") {
      fatal = level;
      err.level = "protocol";
    } else {
      err.level = level || "protocol";
    }
    err.fatal = !!fatal;
    return err;
  }
  function writeUInt32BE2(buf, value, offset) {
    buf[offset++] = value >>> 24;
    buf[offset++] = value >>> 16;
    buf[offset++] = value >>> 8;
    buf[offset++] = value;
    return offset;
  }
  const utilBufferParser = makeBufferParser2();
  utils$1 = {
    bufferCopy: bufferCopy2,
    bufferSlice: bufferSlice2,
    FastBuffer: FastBuffer2,
    bufferFill: (buf, value, start, end) => {
      return TypedArrayFill.call(buf, value, start, end);
    },
    makeError: makeError2,
    doFatalError: (protocol, msg, level, reason) => {
      let err;
      if (DISCONNECT_REASON2 === void 0)
        ({ DISCONNECT_REASON: DISCONNECT_REASON2 } = requireConstants());
      if (msg instanceof Error) {
        err = msg;
        if (typeof level !== "number")
          reason = DISCONNECT_REASON2.PROTOCOL_ERROR;
        else
          reason = level;
      } else {
        err = makeError2(msg, level, true);
      }
      if (typeof reason !== "number")
        reason = DISCONNECT_REASON2.PROTOCOL_ERROR;
      protocol.disconnect(reason);
      protocol._destruct();
      protocol._onError(err);
      return Infinity;
    },
    readUInt32BE: readUInt32BE2,
    writeUInt32BE: writeUInt32BE2,
    writeUInt32LE: (buf, value, offset) => {
      buf[offset++] = value;
      buf[offset++] = value >>> 8;
      buf[offset++] = value >>> 16;
      buf[offset++] = value >>> 24;
      return offset;
    },
    makeBufferParser: makeBufferParser2,
    bufferParser: makeBufferParser2(),
    readString: (buffer2, start, dest, maxLen) => {
      if (typeof dest === "number") {
        maxLen = dest;
        dest = void 0;
      }
      if (start === void 0)
        start = 0;
      const left = buffer2.length - start;
      if (start < 0 || start >= buffer2.length || left < 4)
        return;
      const len = readUInt32BE2(buffer2, start);
      if (left < 4 + len || typeof maxLen === "number" && len > maxLen)
        return;
      start += 4;
      const end = start + len;
      buffer2._pos = end;
      if (dest) {
        if (Buffer.isBuffer(dest))
          return bufferCopy2(buffer2, dest, start, end);
        return buffer2.utf8Slice(start, end);
      }
      return bufferSlice2(buffer2, start, end);
    },
    sigSSHToASN1: (sig, type2) => {
      switch (type2) {
        case "ssh-dss": {
          if (sig.length > 40)
            return sig;
          const asnWriter = new Ber2.Writer();
          asnWriter.startSequence();
          let r = sig.slice(0, 20);
          let s = sig.slice(20);
          if (r[0] & 128) {
            const rNew = Buffer.allocUnsafe(21);
            rNew[0] = 0;
            r.copy(rNew, 1);
            r = rNew;
          } else if (r[0] === 0 && !(r[1] & 128)) {
            r = r.slice(1);
          }
          if (s[0] & 128) {
            const sNew = Buffer.allocUnsafe(21);
            sNew[0] = 0;
            s.copy(sNew, 1);
            s = sNew;
          } else if (s[0] === 0 && !(s[1] & 128)) {
            s = s.slice(1);
          }
          asnWriter.writeBuffer(r, Ber2.Integer);
          asnWriter.writeBuffer(s, Ber2.Integer);
          asnWriter.endSequence();
          return asnWriter.buffer;
        }
        case "ecdsa-sha2-nistp256":
        case "ecdsa-sha2-nistp384":
        case "ecdsa-sha2-nistp521": {
          utilBufferParser.init(sig, 0);
          const r = utilBufferParser.readString();
          const s = utilBufferParser.readString();
          utilBufferParser.clear();
          if (r === void 0 || s === void 0)
            return;
          const asnWriter = new Ber2.Writer();
          asnWriter.startSequence();
          asnWriter.writeBuffer(r, Ber2.Integer);
          asnWriter.writeBuffer(s, Ber2.Integer);
          asnWriter.endSequence();
          return asnWriter.buffer;
        }
        default:
          return sig;
      }
    },
    convertSignature: (signature, keyType) => {
      switch (keyType) {
        case "ssh-dss": {
          if (signature.length <= 40)
            return signature;
          const asnReader = new Ber2.Reader(signature);
          asnReader.readSequence();
          let r = asnReader.readString(Ber2.Integer, true);
          let s = asnReader.readString(Ber2.Integer, true);
          let rOffset = 0;
          let sOffset = 0;
          if (r.length < 20) {
            const rNew = Buffer.allocUnsafe(20);
            rNew.set(r, 1);
            r = rNew;
            r[0] = 0;
          }
          if (s.length < 20) {
            const sNew = Buffer.allocUnsafe(20);
            sNew.set(s, 1);
            s = sNew;
            s[0] = 0;
          }
          if (r.length > 20 && r[0] === 0)
            rOffset = 1;
          if (s.length > 20 && s[0] === 0)
            sOffset = 1;
          const newSig = Buffer.allocUnsafe(r.length - rOffset + (s.length - sOffset));
          bufferCopy2(r, newSig, rOffset, r.length, 0);
          bufferCopy2(s, newSig, sOffset, s.length, r.length - rOffset);
          return newSig;
        }
        case "ecdsa-sha2-nistp256":
        case "ecdsa-sha2-nistp384":
        case "ecdsa-sha2-nistp521": {
          if (signature[0] === 0)
            return signature;
          const asnReader = new Ber2.Reader(signature);
          asnReader.readSequence();
          const r = asnReader.readString(Ber2.Integer, true);
          const s = asnReader.readString(Ber2.Integer, true);
          if (r === null || s === null)
            return;
          const newSig = Buffer.allocUnsafe(4 + r.length + 4 + s.length);
          writeUInt32BE2(newSig, r.length, 0);
          newSig.set(r, 4);
          writeUInt32BE2(newSig, s.length, 4 + r.length);
          newSig.set(s, 4 + 4 + r.length);
          return newSig;
        }
      }
      return signature;
    },
    sendPacket: (proto, packet, bypass) => {
      if (!bypass && proto._kexinit !== void 0) {
        if (proto._queue === void 0)
          proto._queue = [];
        proto._queue.push(packet);
        proto._debug && proto._debug("Outbound: ... packet queued");
        return false;
      }
      proto._cipher.encrypt(packet);
      return true;
    }
  };
  return utils$1;
}
var poly1305 = { exports: {} };
var hasRequiredPoly1305;
function requirePoly1305() {
  if (hasRequiredPoly1305) return poly1305.exports;
  hasRequiredPoly1305 = 1;
  (function(module2, exports$1) {
    var createPoly1305 = function() {
      var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
      if (typeof __filename !== "undefined") _scriptDir = _scriptDir || __filename;
      return function(createPoly13052) {
        createPoly13052 = createPoly13052 || {};
        var b;
        b || (b = typeof createPoly13052 !== "undefined" ? createPoly13052 : {});
        var q, r;
        b.ready = new Promise(function(a, c) {
          q = a;
          r = c;
        });
        var u = {}, w;
        for (w in b) b.hasOwnProperty(w) && (u[w] = b[w]);
        var x = "object" === typeof window, y = "function" === typeof importScripts, z = "object" === typeof process && "object" === typeof process.versions && "string" === typeof process.versions.node, B = "", C, D, E, F2, G;
        if (z) B = y ? require$$0.dirname(B) + "/" : __dirname + "/", C = function(a, c) {
          var d = H(a);
          if (d) return c ? d : d.toString();
          F2 || (F2 = require$$1);
          G || (G = require$$0);
          a = G.normalize(a);
          return F2.readFileSync(a, c ? null : "utf8");
        }, E = function(a) {
          a = C(a, true);
          a.buffer || (a = new Uint8Array(a));
          assert2(a.buffer);
          return a;
        }, D = function(a, c, d) {
          var e = H(a);
          e && c(e);
          F2 || (F2 = require$$1);
          G || (G = require$$0);
          a = G.normalize(a);
          F2.readFile(a, function(f, l) {
            f ? d(f) : c(l.buffer);
          });
        }, 1 < process.argv.length && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), b.inspect = function() {
          return "[Emscripten Module object]";
        };
        else if (x || y) y ? B = self.location.href : "undefined" !== typeof document && document.currentScript && (B = document.currentScript.src), _scriptDir && (B = _scriptDir), 0 !== B.indexOf("blob:") ? B = B.substr(0, B.lastIndexOf("/") + 1) : B = "", C = function(a) {
          try {
            var c = new XMLHttpRequest();
            c.open("GET", a, false);
            c.send(null);
            return c.responseText;
          } catch (f) {
            if (a = H(a)) {
              c = [];
              for (var d = 0; d < a.length; d++) {
                var e = a[d];
                255 < e && (e &= 255);
                c.push(String.fromCharCode(e));
              }
              return c.join("");
            }
            throw f;
          }
        }, y && (E = function(a) {
          try {
            var c = new XMLHttpRequest();
            c.open("GET", a, false);
            c.responseType = "arraybuffer";
            c.send(null);
            return new Uint8Array(c.response);
          } catch (d) {
            if (a = H(a)) return a;
            throw d;
          }
        }), D = function(a, c, d) {
          var e = new XMLHttpRequest();
          e.open("GET", a, true);
          e.responseType = "arraybuffer";
          e.onload = function() {
            if (200 == e.status || 0 == e.status && e.response) c(e.response);
            else {
              var f = H(a);
              f ? c(f.buffer) : d();
            }
          };
          e.onerror = d;
          e.send(null);
        };
        b.print || console.log.bind(console);
        var I = b.printErr || console.warn.bind(console);
        for (w in u) u.hasOwnProperty(w) && (b[w] = u[w]);
        u = null;
        var J;
        b.wasmBinary && (J = b.wasmBinary);
        b.noExitRuntime || true;
        "object" !== typeof WebAssembly && K("no native wasm support detected");
        var L, M = false;
        function assert2(a, c) {
          a || K("Assertion failed: " + c);
        }
        function N(a) {
          var c = b["_" + a];
          assert2(c, "Cannot call unknown function " + a + ", make sure it is exported");
          return c;
        }
        function ca(a, c, d, e) {
          var f = { string: function(g) {
            var p = 0;
            if (null !== g && void 0 !== g && 0 !== g) {
              var n = (g.length << 2) + 1;
              p = O(n);
              var k = p, h = P;
              if (0 < n) {
                n = k + n - 1;
                for (var v = 0; v < g.length; ++v) {
                  var m = g.charCodeAt(v);
                  if (55296 <= m && 57343 >= m) {
                    var oa = g.charCodeAt(++v);
                    m = 65536 + ((m & 1023) << 10) | oa & 1023;
                  }
                  if (127 >= m) {
                    if (k >= n) break;
                    h[k++] = m;
                  } else {
                    if (2047 >= m) {
                      if (k + 1 >= n) break;
                      h[k++] = 192 | m >> 6;
                    } else {
                      if (65535 >= m) {
                        if (k + 2 >= n) break;
                        h[k++] = 224 | m >> 12;
                      } else {
                        if (k + 3 >= n) break;
                        h[k++] = 240 | m >> 18;
                        h[k++] = 128 | m >> 12 & 63;
                      }
                      h[k++] = 128 | m >> 6 & 63;
                    }
                    h[k++] = 128 | m & 63;
                  }
                }
                h[k] = 0;
              }
            }
            return p;
          }, array: function(g) {
            var p = O(g.length);
            Q.set(g, p);
            return p;
          } }, l = N(a), A = [];
          a = 0;
          if (e) for (var t2 = 0; t2 < e.length; t2++) {
            var aa = f[d[t2]];
            aa ? (0 === a && (a = da()), A[t2] = aa(e[t2])) : A[t2] = e[t2];
          }
          d = l.apply(null, A);
          d = function(g) {
            if ("string" === c) if (g) {
              for (var p = P, n = g + NaN, k = g; p[k] && !(k >= n); ) ++k;
              if (16 < k - g && p.subarray && ea) g = ea.decode(p.subarray(g, k));
              else {
                for (n = ""; g < k; ) {
                  var h = p[g++];
                  if (h & 128) {
                    var v = p[g++] & 63;
                    if (192 == (h & 224)) n += String.fromCharCode((h & 31) << 6 | v);
                    else {
                      var m = p[g++] & 63;
                      h = 224 == (h & 240) ? (h & 15) << 12 | v << 6 | m : (h & 7) << 18 | v << 12 | m << 6 | p[g++] & 63;
                      65536 > h ? n += String.fromCharCode(h) : (h -= 65536, n += String.fromCharCode(55296 | h >> 10, 56320 | h & 1023));
                    }
                  } else n += String.fromCharCode(h);
                }
                g = n;
              }
            } else g = "";
            else g = "boolean" === c ? !!g : g;
            return g;
          }(d);
          0 !== a && fa(a);
          return d;
        }
        var ea = "undefined" !== typeof TextDecoder ? new TextDecoder("utf8") : void 0, ha, Q, P;
        function ia() {
          var a = L.buffer;
          ha = a;
          b.HEAP8 = Q = new Int8Array(a);
          b.HEAP16 = new Int16Array(a);
          b.HEAP32 = new Int32Array(a);
          b.HEAPU8 = P = new Uint8Array(a);
          b.HEAPU16 = new Uint16Array(a);
          b.HEAPU32 = new Uint32Array(a);
          b.HEAPF32 = new Float32Array(a);
          b.HEAPF64 = new Float64Array(a);
        }
        var R, ja = [], ka = [], la = [];
        function ma() {
          var a = b.preRun.shift();
          ja.unshift(a);
        }
        var S = 0, U = null;
        b.preloadedImages = {};
        b.preloadedAudios = {};
        function K(a) {
          if (b.onAbort) b.onAbort(a);
          I(a);
          M = true;
          a = new WebAssembly.RuntimeError("abort(" + a + "). Build with -s ASSERTIONS=1 for more info.");
          r(a);
          throw a;
        }
        var V = "data:application/octet-stream;base64,", W;
        W = "data:application/octet-stream;base64,AGFzbQEAAAABIAZgAX8Bf2ADf39/AGABfwBgAABgAAF/YAZ/f39/f38AAgcBAWEBYQAAAwsKAAEDAQAAAgQFAgQFAXABAQEFBwEBgAKAgAIGCQF/AUGAjMACCwclCQFiAgABYwADAWQACQFlAAgBZgAHAWcABgFoAAUBaQAKAWoBAAqGTQpPAQJ/QYAIKAIAIgEgAEEDakF8cSICaiEAAkAgAkEAIAAgAU0bDQAgAD8AQRB0SwRAIAAQAEUNAQtBgAggADYCACABDwtBhAhBMDYCAEF/C4wFAg5+Cn8gACgCJCEUIAAoAiAhFSAAKAIcIREgACgCGCESIAAoAhQhEyACQRBPBEAgAC0ATEVBGHQhFyAAKAIEIhZBBWytIQ8gACgCCCIYQQVsrSENIAAoAgwiGUEFbK0hCyAAKAIQIhpBBWytIQkgADUCACEIIBqtIRAgGa0hDiAYrSEMIBatIQoDQCASIAEtAAMiEiABLQAEQQh0ciABLQAFQRB0ciABLQAGIhZBGHRyQQJ2Qf///x9xaq0iAyAOfiABLwAAIAEtAAJBEHRyIBNqIBJBGHRBgICAGHFqrSIEIBB+fCARIAEtAAdBCHQgFnIgAS0ACEEQdHIgAS0ACSIRQRh0ckEEdkH///8fcWqtIgUgDH58IAEtAApBCHQgEXIgAS0AC0EQdHIgAS0ADEEYdHJBBnYgFWqtIgYgCn58IBQgF2ogAS8ADSABLQAPQRB0cmqtIgcgCH58IAMgDH4gBCAOfnwgBSAKfnwgBiAIfnwgByAJfnwgAyAKfiAEIAx+fCAFIAh+fCAGIAl+fCAHIAt+fCADIAh+IAQgCn58IAUgCX58IAYgC358IAcgDX58IAMgCX4gBCAIfnwgBSALfnwgBiANfnwgByAPfnwiA0IaiEL/////D4N8IgRCGohC/////w+DfCIFQhqIQv////8Pg3wiBkIaiEL/////D4N8IgdCGoinQQVsIAOnQf///x9xaiITQRp2IASnQf///x9xaiESIAWnQf///x9xIREgBqdB////H3EhFSAHp0H///8fcSEUIBNB////H3EhEyABQRBqIQEgAkEQayICQQ9LDQALCyAAIBQ2AiQgACAVNgIgIAAgETYCHCAAIBI2AhggACATNgIUCwMAAQu2BAEGfwJAIAAoAjgiBARAIABBPGohBQJAIAJBECAEayIDIAIgA0kbIgZFDQAgBkEDcSEHAkAgBkEBa0EDSQRAQQAhAwwBCyAGQXxxIQhBACEDA0AgBSADIARqaiABIANqLQAAOgAAIAUgA0EBciIEIAAoAjhqaiABIARqLQAAOgAAIAUgA0ECciIEIAAoAjhqaiABIARqLQAAOgAAIAUgA0EDciIEIAAoAjhqaiABIARqLQAAOgAAIANBBGohAyAAKAI4IQQgCEEEayIIDQALCyAHRQ0AA0AgBSADIARqaiABIANqLQAAOgAAIANBAWohAyAAKAI4IQQgB0EBayIHDQALCyAAIAQgBmoiAzYCOCADQRBJDQEgACAFQRAQAiAAQQA2AjggAiAGayECIAEgBmohAQsgAkEQTwRAIAAgASACQXBxIgMQAiACQQ9xIQIgASADaiEBCyACRQ0AIAJBA3EhBCAAQTxqIQVBACEDIAJBAWtBA08EQCACQXxxIQcDQCAFIAAoAjggA2pqIAEgA2otAAA6AAAgBSADQQFyIgYgACgCOGpqIAEgBmotAAA6AAAgBSADQQJyIgYgACgCOGpqIAEgBmotAAA6AAAgBSADQQNyIgYgACgCOGpqIAEgBmotAAA6AAAgA0EEaiEDIAdBBGsiBw0ACwsgBARAA0AgBSAAKAI4IANqaiABIANqLQAAOgAAIANBAWohAyAEQQFrIgQNAAsLIAAgACgCOCACajYCOAsLoS0BDH8jAEEQayIMJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEH0AU0EQEGICCgCACIFQRAgAEELakF4cSAAQQtJGyIIQQN2IgJ2IgFBA3EEQCABQX9zQQFxIAJqIgNBA3QiAUG4CGooAgAiBEEIaiEAAkAgBCgCCCICIAFBsAhqIgFGBEBBiAggBUF+IAN3cTYCAAwBCyACIAE2AgwgASACNgIICyAEIANBA3QiAUEDcjYCBCABIARqIgEgASgCBEEBcjYCBAwNCyAIQZAIKAIAIgpNDQEgAQRAAkBBAiACdCIAQQAgAGtyIAEgAnRxIgBBACAAa3FBAWsiACAAQQx2QRBxIgJ2IgFBBXZBCHEiACACciABIAB2IgFBAnZBBHEiAHIgASAAdiIBQQF2QQJxIgByIAEgAHYiAUEBdkEBcSIAciABIAB2aiIDQQN0IgBBuAhqKAIAIgQoAggiASAAQbAIaiIARgRAQYgIIAVBfiADd3EiBTYCAAwBCyABIAA2AgwgACABNgIICyAEQQhqIQAgBCAIQQNyNgIEIAQgCGoiAiADQQN0IgEgCGsiA0EBcjYCBCABIARqIAM2AgAgCgRAIApBA3YiAUEDdEGwCGohB0GcCCgCACEEAn8gBUEBIAF0IgFxRQRAQYgIIAEgBXI2AgAgBwwBCyAHKAIICyEBIAcgBDYCCCABIAQ2AgwgBCAHNgIMIAQgATYCCAtBnAggAjYCAEGQCCADNgIADA0LQYwIKAIAIgZFDQEgBkEAIAZrcUEBayIAIABBDHZBEHEiAnYiAUEFdkEIcSIAIAJyIAEgAHYiAUECdkEEcSIAciABIAB2IgFBAXZBAnEiAHIgASAAdiIBQQF2QQFxIgByIAEgAHZqQQJ0QbgKaigCACIBKAIEQXhxIAhrIQMgASECA0ACQCACKAIQIgBFBEAgAigCFCIARQ0BCyAAKAIEQXhxIAhrIgIgAyACIANJIgIbIQMgACABIAIbIQEgACECDAELCyABIAhqIgkgAU0NAiABKAIYIQsgASABKAIMIgRHBEAgASgCCCIAQZgIKAIASRogACAENgIMIAQgADYCCAwMCyABQRRqIgIoAgAiAEUEQCABKAIQIgBFDQQgAUEQaiECCwNAIAIhByAAIgRBFGoiAigCACIADQAgBEEQaiECIAQoAhAiAA0ACyAHQQA2AgAMCwtBfyEIIABBv39LDQAgAEELaiIAQXhxIQhBjAgoAgAiCUUNAEEAIAhrIQMCQAJAAkACf0EAIAhBgAJJDQAaQR8gCEH///8HSw0AGiAAQQh2IgAgAEGA/j9qQRB2QQhxIgJ0IgAgAEGA4B9qQRB2QQRxIgF0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAEgAnIgAHJrIgBBAXQgCCAAQRVqdkEBcXJBHGoLIgVBAnRBuApqKAIAIgJFBEBBACEADAELQQAhACAIQQBBGSAFQQF2ayAFQR9GG3QhAQNAAkAgAigCBEF4cSAIayIHIANPDQAgAiEEIAciAw0AQQAhAyACIQAMAwsgACACKAIUIgcgByACIAFBHXZBBHFqKAIQIgJGGyAAIAcbIQAgAUEBdCEBIAINAAsLIAAgBHJFBEBBACEEQQIgBXQiAEEAIABrciAJcSIARQ0DIABBACAAa3FBAWsiACAAQQx2QRBxIgJ2IgFBBXZBCHEiACACciABIAB2IgFBAnZBBHEiAHIgASAAdiIBQQF2QQJxIgByIAEgAHYiAUEBdkEBcSIAciABIAB2akECdEG4CmooAgAhAAsgAEUNAQsDQCAAKAIEQXhxIAhrIgEgA0khAiABIAMgAhshAyAAIAQgAhshBCAAKAIQIgEEfyABBSAAKAIUCyIADQALCyAERQ0AIANBkAgoAgAgCGtPDQAgBCAIaiIGIARNDQEgBCgCGCEFIAQgBCgCDCIBRwRAIAQoAggiAEGYCCgCAEkaIAAgATYCDCABIAA2AggMCgsgBEEUaiICKAIAIgBFBEAgBCgCECIARQ0EIARBEGohAgsDQCACIQcgACIBQRRqIgIoAgAiAA0AIAFBEGohAiABKAIQIgANAAsgB0EANgIADAkLIAhBkAgoAgAiAk0EQEGcCCgCACEDAkAgAiAIayIBQRBPBEBBkAggATYCAEGcCCADIAhqIgA2AgAgACABQQFyNgIEIAIgA2ogATYCACADIAhBA3I2AgQMAQtBnAhBADYCAEGQCEEANgIAIAMgAkEDcjYCBCACIANqIgAgACgCBEEBcjYCBAsgA0EIaiEADAsLIAhBlAgoAgAiBkkEQEGUCCAGIAhrIgE2AgBBoAhBoAgoAgAiAiAIaiIANgIAIAAgAUEBcjYCBCACIAhBA3I2AgQgAkEIaiEADAsLQQAhACAIQS9qIgkCf0HgCygCAARAQegLKAIADAELQewLQn83AgBB5AtCgKCAgICABDcCAEHgCyAMQQxqQXBxQdiq1aoFczYCAEH0C0EANgIAQcQLQQA2AgBBgCALIgFqIgVBACABayIHcSICIAhNDQpBwAsoAgAiBARAQbgLKAIAIgMgAmoiASADTQ0LIAEgBEsNCwtBxAstAABBBHENBQJAAkBBoAgoAgAiAwRAQcgLIQADQCADIAAoAgAiAU8EQCABIAAoAgRqIANLDQMLIAAoAggiAA0ACwtBABABIgFBf0YNBiACIQVB5AsoAgAiA0EBayIAIAFxBEAgAiABayAAIAFqQQAgA2txaiEFCyAFIAhNDQYgBUH+////B0sNBkHACygCACIEBEBBuAsoAgAiAyAFaiIAIANNDQcgACAESw0HCyAFEAEiACABRw0BDAgLIAUgBmsgB3EiBUH+////B0sNBSAFEAEiASAAKAIAIAAoAgRqRg0EIAEhAAsCQCAAQX9GDQAgCEEwaiAFTQ0AQegLKAIAIgEgCSAFa2pBACABa3EiAUH+////B0sEQCAAIQEMCAsgARABQX9HBEAgASAFaiEFIAAhAQwIC0EAIAVrEAEaDAULIAAiAUF/Rw0GDAQLAAtBACEEDAcLQQAhAQwFCyABQX9HDQILQcQLQcQLKAIAQQRyNgIACyACQf7///8HSw0BIAIQASEBQQAQASEAIAFBf0YNASAAQX9GDQEgACABTQ0BIAAgAWsiBSAIQShqTQ0BC0G4C0G4CygCACAFaiIANgIAQbwLKAIAIABJBEBBvAsgADYCAAsCQAJAAkBBoAgoAgAiBwRAQcgLIQADQCABIAAoAgAiAyAAKAIEIgJqRg0CIAAoAggiAA0ACwwCC0GYCCgCACIAQQAgACABTRtFBEBBmAggATYCAAtBACEAQcwLIAU2AgBByAsgATYCAEGoCEF/NgIAQawIQeALKAIANgIAQdQLQQA2AgADQCAAQQN0IgNBuAhqIANBsAhqIgI2AgAgA0G8CGogAjYCACAAQQFqIgBBIEcNAAtBlAggBUEoayIDQXggAWtBB3FBACABQQhqQQdxGyIAayICNgIAQaAIIAAgAWoiADYCACAAIAJBAXI2AgQgASADakEoNgIEQaQIQfALKAIANgIADAILIAAtAAxBCHENACADIAdLDQAgASAHTQ0AIAAgAiAFajYCBEGgCCAHQXggB2tBB3FBACAHQQhqQQdxGyIAaiICNgIAQZQIQZQIKAIAIAVqIgEgAGsiADYCACACIABBAXI2AgQgASAHakEoNgIEQaQIQfALKAIANgIADAELQZgIKAIAIAFLBEBBmAggATYCAAsgASAFaiECQcgLIQACQAJAAkACQAJAAkADQCACIAAoAgBHBEAgACgCCCIADQEMAgsLIAAtAAxBCHFFDQELQcgLIQADQCAHIAAoAgAiAk8EQCACIAAoAgRqIgQgB0sNAwsgACgCCCEADAALAAsgACABNgIAIAAgACgCBCAFajYCBCABQXggAWtBB3FBACABQQhqQQdxG2oiCSAIQQNyNgIEIAJBeCACa0EHcUEAIAJBCGpBB3EbaiIFIAggCWoiBmshAiAFIAdGBEBBoAggBjYCAEGUCEGUCCgCACACaiIANgIAIAYgAEEBcjYCBAwDCyAFQZwIKAIARgRAQZwIIAY2AgBBkAhBkAgoAgAgAmoiADYCACAGIABBAXI2AgQgACAGaiAANgIADAMLIAUoAgQiAEEDcUEBRgRAIABBeHEhBwJAIABB/wFNBEAgBSgCCCIDIABBA3YiAEEDdEGwCGpGGiADIAUoAgwiAUYEQEGICEGICCgCAEF+IAB3cTYCAAwCCyADIAE2AgwgASADNgIIDAELIAUoAhghCAJAIAUgBSgCDCIBRwRAIAUoAggiACABNgIMIAEgADYCCAwBCwJAIAVBFGoiACgCACIDDQAgBUEQaiIAKAIAIgMNAEEAIQEMAQsDQCAAIQQgAyIBQRRqIgAoAgAiAw0AIAFBEGohACABKAIQIgMNAAsgBEEANgIACyAIRQ0AAkAgBSAFKAIcIgNBAnRBuApqIgAoAgBGBEAgACABNgIAIAENAUGMCEGMCCgCAEF+IAN3cTYCAAwCCyAIQRBBFCAIKAIQIAVGG2ogATYCACABRQ0BCyABIAg2AhggBSgCECIABEAgASAANgIQIAAgATYCGAsgBSgCFCIARQ0AIAEgADYCFCAAIAE2AhgLIAUgB2ohBSACIAdqIQILIAUgBSgCBEF+cTYCBCAGIAJBAXI2AgQgAiAGaiACNgIAIAJB/wFNBEAgAkEDdiIAQQN0QbAIaiECAn9BiAgoAgAiAUEBIAB0IgBxRQRAQYgIIAAgAXI2AgAgAgwBCyACKAIICyEAIAIgBjYCCCAAIAY2AgwgBiACNgIMIAYgADYCCAwDC0EfIQAgAkH///8HTQRAIAJBCHYiACAAQYD+P2pBEHZBCHEiA3QiACAAQYDgH2pBEHZBBHEiAXQiACAAQYCAD2pBEHZBAnEiAHRBD3YgASADciAAcmsiAEEBdCACIABBFWp2QQFxckEcaiEACyAGIAA2AhwgBkIANwIQIABBAnRBuApqIQQCQEGMCCgCACIDQQEgAHQiAXFFBEBBjAggASADcjYCACAEIAY2AgAgBiAENgIYDAELIAJBAEEZIABBAXZrIABBH0YbdCEAIAQoAgAhAQNAIAEiAygCBEF4cSACRg0DIABBHXYhASAAQQF0IQAgAyABQQRxaiIEKAIQIgENAAsgBCAGNgIQIAYgAzYCGAsgBiAGNgIMIAYgBjYCCAwCC0GUCCAFQShrIgNBeCABa0EHcUEAIAFBCGpBB3EbIgBrIgI2AgBBoAggACABaiIANgIAIAAgAkEBcjYCBCABIANqQSg2AgRBpAhB8AsoAgA2AgAgByAEQScgBGtBB3FBACAEQSdrQQdxG2pBL2siACAAIAdBEGpJGyICQRs2AgQgAkHQCykCADcCECACQcgLKQIANwIIQdALIAJBCGo2AgBBzAsgBTYCAEHICyABNgIAQdQLQQA2AgAgAkEYaiEAA0AgAEEHNgIEIABBCGohASAAQQRqIQAgASAESQ0ACyACIAdGDQMgAiACKAIEQX5xNgIEIAcgAiAHayIEQQFyNgIEIAIgBDYCACAEQf8BTQRAIARBA3YiAEEDdEGwCGohAgJ/QYgIKAIAIgFBASAAdCIAcUUEQEGICCAAIAFyNgIAIAIMAQsgAigCCAshACACIAc2AgggACAHNgIMIAcgAjYCDCAHIAA2AggMBAtBHyEAIAdCADcCECAEQf///wdNBEAgBEEIdiIAIABBgP4/akEQdkEIcSICdCIAIABBgOAfakEQdkEEcSIBdCIAIABBgIAPakEQdkECcSIAdEEPdiABIAJyIAByayIAQQF0IAQgAEEVanZBAXFyQRxqIQALIAcgADYCHCAAQQJ0QbgKaiEDAkBBjAgoAgAiAkEBIAB0IgFxRQRAQYwIIAEgAnI2AgAgAyAHNgIAIAcgAzYCGAwBCyAEQQBBGSAAQQF2ayAAQR9GG3QhACADKAIAIQEDQCABIgIoAgRBeHEgBEYNBCAAQR12IQEgAEEBdCEAIAIgAUEEcWoiAygCECIBDQALIAMgBzYCECAHIAI2AhgLIAcgBzYCDCAHIAc2AggMAwsgAygCCCIAIAY2AgwgAyAGNgIIIAZBADYCGCAGIAM2AgwgBiAANgIICyAJQQhqIQAMBQsgAigCCCIAIAc2AgwgAiAHNgIIIAdBADYCGCAHIAI2AgwgByAANgIIC0GUCCgCACIAIAhNDQBBlAggACAIayIBNgIAQaAIQaAIKAIAIgIgCGoiADYCACAAIAFBAXI2AgQgAiAIQQNyNgIEIAJBCGohAAwDC0GECEEwNgIAQQAhAAwCCwJAIAVFDQACQCAEKAIcIgJBAnRBuApqIgAoAgAgBEYEQCAAIAE2AgAgAQ0BQYwIIAlBfiACd3EiCTYCAAwCCyAFQRBBFCAFKAIQIARGG2ogATYCACABRQ0BCyABIAU2AhggBCgCECIABEAgASAANgIQIAAgATYCGAsgBCgCFCIARQ0AIAEgADYCFCAAIAE2AhgLAkAgA0EPTQRAIAQgAyAIaiIAQQNyNgIEIAAgBGoiACAAKAIEQQFyNgIEDAELIAQgCEEDcjYCBCAGIANBAXI2AgQgAyAGaiADNgIAIANB/wFNBEAgA0EDdiIAQQN0QbAIaiECAn9BiAgoAgAiAUEBIAB0IgBxRQRAQYgIIAAgAXI2AgAgAgwBCyACKAIICyEAIAIgBjYCCCAAIAY2AgwgBiACNgIMIAYgADYCCAwBC0EfIQAgA0H///8HTQRAIANBCHYiACAAQYD+P2pBEHZBCHEiAnQiACAAQYDgH2pBEHZBBHEiAXQiACAAQYCAD2pBEHZBAnEiAHRBD3YgASACciAAcmsiAEEBdCADIABBFWp2QQFxckEcaiEACyAGIAA2AhwgBkIANwIQIABBAnRBuApqIQICQAJAIAlBASAAdCIBcUUEQEGMCCABIAlyNgIAIAIgBjYCACAGIAI2AhgMAQsgA0EAQRkgAEEBdmsgAEEfRht0IQAgAigCACEIA0AgCCIBKAIEQXhxIANGDQIgAEEddiECIABBAXQhACABIAJBBHFqIgIoAhAiCA0ACyACIAY2AhAgBiABNgIYCyAGIAY2AgwgBiAGNgIIDAELIAEoAggiACAGNgIMIAEgBjYCCCAGQQA2AhggBiABNgIMIAYgADYCCAsgBEEIaiEADAELAkAgC0UNAAJAIAEoAhwiAkECdEG4CmoiACgCACABRgRAIAAgBDYCACAEDQFBjAggBkF+IAJ3cTYCAAwCCyALQRBBFCALKAIQIAFGG2ogBDYCACAERQ0BCyAEIAs2AhggASgCECIABEAgBCAANgIQIAAgBDYCGAsgASgCFCIARQ0AIAQgADYCFCAAIAQ2AhgLAkAgA0EPTQRAIAEgAyAIaiIAQQNyNgIEIAAgAWoiACAAKAIEQQFyNgIEDAELIAEgCEEDcjYCBCAJIANBAXI2AgQgAyAJaiADNgIAIAoEQCAKQQN2IgBBA3RBsAhqIQRBnAgoAgAhAgJ/QQEgAHQiACAFcUUEQEGICCAAIAVyNgIAIAQMAQsgBCgCCAshACAEIAI2AgggACACNgIMIAIgBDYCDCACIAA2AggLQZwIIAk2AgBBkAggAzYCAAsgAUEIaiEACyAMQRBqJAAgAAsQACMAIABrQXBxIgAkACAACwYAIAAkAAsEACMAC4AJAgh/BH4jAEGQAWsiBiQAIAYgBS0AA0EYdEGAgIAYcSAFLwAAIAUtAAJBEHRycjYCACAGIAUoAANBAnZBg/7/H3E2AgQgBiAFKAAGQQR2Qf+B/x9xNgIIIAYgBSgACUEGdkH//8AfcTYCDCAFLwANIQggBS0ADyEJIAZCADcCFCAGQgA3AhwgBkEANgIkIAYgCCAJQRB0QYCAPHFyNgIQIAYgBSgAEDYCKCAGIAUoABQ2AiwgBiAFKAAYNgIwIAUoABwhBSAGQQA6AEwgBkEANgI4IAYgBTYCNCAGIAEgAhAEIAQEQCAGIAMgBBAECyAGKAI4IgEEQCAGQTxqIgIgAWpBAToAACABQQFqQQ9NBEAgASAGakE9aiEEAkBBDyABayIDRQ0AIAMgBGoiAUEBa0EAOgAAIARBADoAACADQQNJDQAgAUECa0EAOgAAIARBADoAASABQQNrQQA6AAAgBEEAOgACIANBB0kNACABQQRrQQA6AAAgBEEAOgADIANBCUkNACAEQQAgBGtBA3EiAWoiBEEANgIAIAQgAyABa0F8cSIBaiIDQQRrQQA2AgAgAUEJSQ0AIARBADYCCCAEQQA2AgQgA0EIa0EANgIAIANBDGtBADYCACABQRlJDQAgBEEANgIYIARBADYCFCAEQQA2AhAgBEEANgIMIANBEGtBADYCACADQRRrQQA2AgAgA0EYa0EANgIAIANBHGtBADYCACABIARBBHFBGHIiAWsiA0EgSQ0AIAEgBGohAQNAIAFCADcDGCABQgA3AxAgAUIANwMIIAFCADcDACABQSBqIQEgA0EgayIDQR9LDQALCwsgBkEBOgBMIAYgAkEQEAILIAY1AjQhECAGNQIwIREgBjUCLCEOIAAgBjUCKCAGKAIkIAYoAiAgBigCHCAGKAIYIgNBGnZqIgJBGnZqIgFBGnZqIgtBgICAYHIgAUH///8fcSINIAJB////H3EiCCAGKAIUIAtBGnZBBWxqIgFB////H3EiCUEFaiIFQRp2IANB////H3EgAUEadmoiA2oiAUEadmoiAkEadmoiBEEadmoiDEEfdSIHIANxIAEgDEEfdkEBayIDQf///x9xIgpxciIBQRp0IAUgCnEgByAJcXJyrXwiDzwAACAAIA9CGIg8AAMgACAPQhCIPAACIAAgD0IIiDwAASAAIA4gByAIcSACIApxciICQRR0IAFBBnZyrXwgD0IgiHwiDjwABCAAIA5CGIg8AAcgACAOQhCIPAAGIAAgDkIIiDwABSAAIBEgByANcSAEIApxciIBQQ50IAJBDHZyrXwgDkIgiHwiDjwACCAAIA5CGIg8AAsgACAOQhCIPAAKIAAgDkIIiDwACSAAIBAgAyAMcSAHIAtxckEIdCABQRJ2cq18IA5CIIh8Ig48AAwgACAOQhiIPAAPIAAgDkIQiDwADiAAIA5CCIg8AA0gBkIANwIwIAZCADcCKCAGQgA3AiAgBkIANwIYIAZCADcCECAGQgA3AgggBkIANwIAIAZBkAFqJAALpwwBB38CQCAARQ0AIABBCGsiAyAAQQRrKAIAIgFBeHEiAGohBQJAIAFBAXENACABQQNxRQ0BIAMgAygCACIBayIDQZgIKAIASQ0BIAAgAWohACADQZwIKAIARwRAIAFB/wFNBEAgAygCCCICIAFBA3YiBEEDdEGwCGpGGiACIAMoAgwiAUYEQEGICEGICCgCAEF+IAR3cTYCAAwDCyACIAE2AgwgASACNgIIDAILIAMoAhghBgJAIAMgAygCDCIBRwRAIAMoAggiAiABNgIMIAEgAjYCCAwBCwJAIANBFGoiAigCACIEDQAgA0EQaiICKAIAIgQNAEEAIQEMAQsDQCACIQcgBCIBQRRqIgIoAgAiBA0AIAFBEGohAiABKAIQIgQNAAsgB0EANgIACyAGRQ0BAkAgAyADKAIcIgJBAnRBuApqIgQoAgBGBEAgBCABNgIAIAENAUGMCEGMCCgCAEF+IAJ3cTYCAAwDCyAGQRBBFCAGKAIQIANGG2ogATYCACABRQ0CCyABIAY2AhggAygCECICBEAgASACNgIQIAIgATYCGAsgAygCFCICRQ0BIAEgAjYCFCACIAE2AhgMAQsgBSgCBCIBQQNxQQNHDQBBkAggADYCACAFIAFBfnE2AgQgAyAAQQFyNgIEIAAgA2ogADYCAA8LIAMgBU8NACAFKAIEIgFBAXFFDQACQCABQQJxRQRAIAVBoAgoAgBGBEBBoAggAzYCAEGUCEGUCCgCACAAaiIANgIAIAMgAEEBcjYCBCADQZwIKAIARw0DQZAIQQA2AgBBnAhBADYCAA8LIAVBnAgoAgBGBEBBnAggAzYCAEGQCEGQCCgCACAAaiIANgIAIAMgAEEBcjYCBCAAIANqIAA2AgAPCyABQXhxIABqIQACQCABQf8BTQRAIAUoAggiAiABQQN2IgRBA3RBsAhqRhogAiAFKAIMIgFGBEBBiAhBiAgoAgBBfiAEd3E2AgAMAgsgAiABNgIMIAEgAjYCCAwBCyAFKAIYIQYCQCAFIAUoAgwiAUcEQCAFKAIIIgJBmAgoAgBJGiACIAE2AgwgASACNgIIDAELAkAgBUEUaiICKAIAIgQNACAFQRBqIgIoAgAiBA0AQQAhAQwBCwNAIAIhByAEIgFBFGoiAigCACIEDQAgAUEQaiECIAEoAhAiBA0ACyAHQQA2AgALIAZFDQACQCAFIAUoAhwiAkECdEG4CmoiBCgCAEYEQCAEIAE2AgAgAQ0BQYwIQYwIKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgBUYbaiABNgIAIAFFDQELIAEgBjYCGCAFKAIQIgIEQCABIAI2AhAgAiABNgIYCyAFKAIUIgJFDQAgASACNgIUIAIgATYCGAsgAyAAQQFyNgIEIAAgA2ogADYCACADQZwIKAIARw0BQZAIIAA2AgAPCyAFIAFBfnE2AgQgAyAAQQFyNgIEIAAgA2ogADYCAAsgAEH/AU0EQCAAQQN2IgFBA3RBsAhqIQACf0GICCgCACICQQEgAXQiAXFFBEBBiAggASACcjYCACAADAELIAAoAggLIQIgACADNgIIIAIgAzYCDCADIAA2AgwgAyACNgIIDwtBHyECIANCADcCECAAQf///wdNBEAgAEEIdiIBIAFBgP4/akEQdkEIcSIBdCICIAJBgOAfakEQdkEEcSICdCIEIARBgIAPakEQdkECcSIEdEEPdiABIAJyIARyayIBQQF0IAAgAUEVanZBAXFyQRxqIQILIAMgAjYCHCACQQJ0QbgKaiEBAkACQAJAQYwIKAIAIgRBASACdCIHcUUEQEGMCCAEIAdyNgIAIAEgAzYCACADIAE2AhgMAQsgAEEAQRkgAkEBdmsgAkEfRht0IQIgASgCACEBA0AgASIEKAIEQXhxIABGDQIgAkEddiEBIAJBAXQhAiAEIAFBBHFqIgdBEGooAgAiAQ0ACyAHIAM2AhAgAyAENgIYCyADIAM2AgwgAyADNgIIDAELIAQoAggiACADNgIMIAQgAzYCCCADQQA2AhggAyAENgIMIAMgADYCCAtBqAhBqAgoAgBBAWsiAEF/IAAbNgIACwsLCQEAQYEICwIGUA==";
        if (!W.startsWith(V)) {
          var na = W;
          W = b.locateFile ? b.locateFile(na, B) : B + na;
        }
        function pa() {
          var a = W;
          try {
            if (a == W && J) return new Uint8Array(J);
            var c = H(a);
            if (c) return c;
            if (E) return E(a);
            throw "both async and sync fetching of the wasm failed";
          } catch (d) {
            K(d);
          }
        }
        function qa() {
          if (!J && (x || y)) {
            if ("function" === typeof fetch && !W.startsWith("file://")) return fetch(W, { credentials: "same-origin" }).then(function(a) {
              if (!a.ok) throw "failed to load wasm binary file at '" + W + "'";
              return a.arrayBuffer();
            }).catch(function() {
              return pa();
            });
            if (D) return new Promise(function(a, c) {
              D(W, function(d) {
                a(new Uint8Array(d));
              }, c);
            });
          }
          return Promise.resolve().then(function() {
            return pa();
          });
        }
        function X(a) {
          for (; 0 < a.length; ) {
            var c = a.shift();
            if ("function" == typeof c) c(b);
            else {
              var d = c.m;
              "number" === typeof d ? void 0 === c.l ? R.get(d)() : R.get(d)(c.l) : d(void 0 === c.l ? null : c.l);
            }
          }
        }
        var ra = "function" === typeof atob ? atob : function(a) {
          var c = "", d = 0;
          a = a.replace(/[^A-Za-z0-9\+\/=]/g, "");
          do {
            var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++));
            var f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++));
            var l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++));
            var A = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++));
            e = e << 2 | f >> 4;
            f = (f & 15) << 4 | l >> 2;
            var t2 = (l & 3) << 6 | A;
            c += String.fromCharCode(e);
            64 !== l && (c += String.fromCharCode(f));
            64 !== A && (c += String.fromCharCode(t2));
          } while (d < a.length);
          return c;
        };
        function H(a) {
          if (a.startsWith(V)) {
            a = a.slice(V.length);
            if ("boolean" === typeof z && z) {
              var c = Buffer.from(a, "base64");
              c = new Uint8Array(c.buffer, c.byteOffset, c.byteLength);
            } else try {
              var d = ra(a), e = new Uint8Array(d.length);
              for (a = 0; a < d.length; ++a) e[a] = d.charCodeAt(a);
              c = e;
            } catch (f) {
              throw Error("Converting base64 string to bytes failed.");
            }
            return c;
          }
        }
        var sa = { a: function(a) {
          var c = P.length;
          a >>>= 0;
          if (2147483648 < a) return false;
          for (var d = 1; 4 >= d; d *= 2) {
            var e = c * (1 + 0.2 / d);
            e = Math.min(e, a + 100663296);
            e = Math.max(a, e);
            0 < e % 65536 && (e += 65536 - e % 65536);
            a: {
              try {
                L.grow(Math.min(2147483648, e) - ha.byteLength + 65535 >>> 16);
                ia();
                var f = 1;
                break a;
              } catch (l) {
              }
              f = void 0;
            }
            if (f) return true;
          }
          return false;
        } };
        (function() {
          function a(f) {
            b.asm = f.exports;
            L = b.asm.b;
            ia();
            R = b.asm.j;
            ka.unshift(b.asm.c);
            S--;
            b.monitorRunDependencies && b.monitorRunDependencies(S);
            0 == S && (U && (f = U, U = null, f()));
          }
          function c(f) {
            a(f.instance);
          }
          function d(f) {
            return qa().then(function(l) {
              return WebAssembly.instantiate(l, e);
            }).then(f, function(l) {
              I("failed to asynchronously prepare wasm: " + l);
              K(l);
            });
          }
          var e = { a: sa };
          S++;
          b.monitorRunDependencies && b.monitorRunDependencies(S);
          if (b.instantiateWasm) try {
            return b.instantiateWasm(
              e,
              a
            );
          } catch (f) {
            return I("Module.instantiateWasm callback failed with error: " + f), false;
          }
          (function() {
            return J || "function" !== typeof WebAssembly.instantiateStreaming || W.startsWith(V) || W.startsWith("file://") || "function" !== typeof fetch ? d(c) : fetch(W, { credentials: "same-origin" }).then(function(f) {
              return WebAssembly.instantiateStreaming(f, e).then(c, function(l) {
                I("wasm streaming compile failed: " + l);
                I("falling back to ArrayBuffer instantiation");
                return d(c);
              });
            });
          })().catch(r);
          return {};
        })();
        b.___wasm_call_ctors = function() {
          return (b.___wasm_call_ctors = b.asm.c).apply(null, arguments);
        };
        b._poly1305_auth = function() {
          return (b._poly1305_auth = b.asm.d).apply(null, arguments);
        };
        var da = b.stackSave = function() {
          return (da = b.stackSave = b.asm.e).apply(null, arguments);
        }, fa = b.stackRestore = function() {
          return (fa = b.stackRestore = b.asm.f).apply(null, arguments);
        }, O = b.stackAlloc = function() {
          return (O = b.stackAlloc = b.asm.g).apply(null, arguments);
        };
        b._malloc = function() {
          return (b._malloc = b.asm.h).apply(null, arguments);
        };
        b._free = function() {
          return (b._free = b.asm.i).apply(null, arguments);
        };
        b.cwrap = function(a, c, d, e) {
          d = d || [];
          var f = d.every(function(l) {
            return "number" === l;
          });
          return "string" !== c && f && !e ? N(a) : function() {
            return ca(a, c, d, arguments);
          };
        };
        var Y;
        U = function ta() {
          Y || Z();
          Y || (U = ta);
        };
        function Z() {
          function a() {
            if (!Y && (Y = true, b.calledRun = true, !M)) {
              X(ka);
              q(b);
              if (b.onRuntimeInitialized) b.onRuntimeInitialized();
              if (b.postRun) for ("function" == typeof b.postRun && (b.postRun = [b.postRun]); b.postRun.length; ) {
                var c = b.postRun.shift();
                la.unshift(c);
              }
              X(la);
            }
          }
          if (!(0 < S)) {
            if (b.preRun) for ("function" == typeof b.preRun && (b.preRun = [b.preRun]); b.preRun.length; ) ma();
            X(ja);
            0 < S || (b.setStatus ? (b.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                b.setStatus("");
              }, 1);
              a();
            }, 1)) : a());
          }
        }
        b.run = Z;
        if (b.preInit) for ("function" == typeof b.preInit && (b.preInit = [b.preInit]); 0 < b.preInit.length; ) b.preInit.pop()();
        Z();
        return createPoly13052.ready;
      };
    }();
    module2.exports = createPoly1305;
  })(poly1305);
  return poly1305.exports;
}
var crypto;
var hasRequiredCrypto;
function requireCrypto() {
  if (hasRequiredCrypto) return crypto;
  hasRequiredCrypto = 1;
  const {
    createCipheriv: createCipheriv2,
    createDecipheriv: createDecipheriv2,
    createHmac: createHmac2,
    randomFillSync: randomFillSync2,
    timingSafeEqual
  } = require$$0$3;
  const { readUInt32BE: readUInt32BE2, writeUInt32BE: writeUInt32BE2 } = requireUtils();
  const FastBuffer2 = Buffer[Symbol.species];
  const MAX_SEQNO = 2 ** 32 - 1;
  const EMPTY_BUFFER = Buffer.alloc(0);
  const BUF_INT = Buffer.alloc(4);
  const DISCARD_CACHE = /* @__PURE__ */ new Map();
  const MAX_PACKET_SIZE = 35e3;
  let binding;
  let AESGCMCipher;
  let ChaChaPolyCipher;
  let GenericCipher;
  let AESGCMDecipher;
  let ChaChaPolyDecipher;
  let GenericDecipher;
  try {
    binding = require("./crypto/build/Release/sshcrypto.node");
    ({
      AESGCMCipher,
      ChaChaPolyCipher,
      GenericCipher,
      AESGCMDecipher,
      ChaChaPolyDecipher,
      GenericDecipher
    } = binding);
  } catch {
  }
  const CIPHER_STREAM = 1 << 0;
  const CIPHER_INFO2 = (() => {
    function info(sslName, blockLen, keyLen, ivLen, authLen, discardLen, flags) {
      return {
        sslName,
        blockLen,
        keyLen,
        ivLen: ivLen !== 0 || flags & CIPHER_STREAM ? ivLen : blockLen,
        authLen,
        discardLen,
        stream: !!(flags & CIPHER_STREAM)
      };
    }
    return {
      "chacha20-poly1305@openssh.com": info("chacha20", 8, 64, 0, 16, 0, CIPHER_STREAM),
      "aes128-gcm": info("aes-128-gcm", 16, 16, 12, 16, 0, CIPHER_STREAM),
      "aes256-gcm": info("aes-256-gcm", 16, 32, 12, 16, 0, CIPHER_STREAM),
      "aes128-gcm@openssh.com": info("aes-128-gcm", 16, 16, 12, 16, 0, CIPHER_STREAM),
      "aes256-gcm@openssh.com": info("aes-256-gcm", 16, 32, 12, 16, 0, CIPHER_STREAM),
      "aes128-cbc": info("aes-128-cbc", 16, 16, 0, 0, 0, 0),
      "aes192-cbc": info("aes-192-cbc", 16, 24, 0, 0, 0, 0),
      "aes256-cbc": info("aes-256-cbc", 16, 32, 0, 0, 0, 0),
      "rijndael-cbc@lysator.liu.se": info("aes-256-cbc", 16, 32, 0, 0, 0, 0),
      "3des-cbc": info("des-ede3-cbc", 8, 24, 0, 0, 0, 0),
      "blowfish-cbc": info("bf-cbc", 8, 16, 0, 0, 0, 0),
      "idea-cbc": info("idea-cbc", 8, 16, 0, 0, 0, 0),
      "cast128-cbc": info("cast-cbc", 8, 16, 0, 0, 0, 0),
      "aes128-ctr": info("aes-128-ctr", 16, 16, 16, 0, 0, CIPHER_STREAM),
      "aes192-ctr": info("aes-192-ctr", 16, 24, 16, 0, 0, CIPHER_STREAM),
      "aes256-ctr": info("aes-256-ctr", 16, 32, 16, 0, 0, CIPHER_STREAM),
      "3des-ctr": info("des-ede3", 8, 24, 8, 0, 0, CIPHER_STREAM),
      "blowfish-ctr": info("bf-ecb", 8, 16, 8, 0, 0, CIPHER_STREAM),
      "cast128-ctr": info("cast5-ecb", 8, 16, 8, 0, 0, CIPHER_STREAM),
      /* The "arcfour128" algorithm is the RC4 cipher, as described in
      	       [SCHNEIER], using a 128-bit key.  The first 1536 bytes of keystream
      	       generated by the cipher MUST be discarded, and the first byte of the
      	       first encrypted packet MUST be encrypted using the 1537th byte of
      	       keystream.
      
      	       -- http://tools.ietf.org/html/rfc4345#section-4 */
      "arcfour": info("rc4", 8, 16, 0, 0, 1536, CIPHER_STREAM),
      "arcfour128": info("rc4", 8, 16, 0, 0, 1536, CIPHER_STREAM),
      "arcfour256": info("rc4", 8, 32, 0, 0, 1536, CIPHER_STREAM),
      "arcfour512": info("rc4", 8, 64, 0, 0, 1536, CIPHER_STREAM)
    };
  })();
  const MAC_INFO = (() => {
    function info(sslName, len, actualLen, isETM) {
      return {
        sslName,
        len,
        actualLen,
        isETM
      };
    }
    return {
      "hmac-md5": info("md5", 16, 16, false),
      "hmac-md5-96": info("md5", 16, 12, false),
      "hmac-ripemd160": info("ripemd160", 20, 20, false),
      "hmac-sha1": info("sha1", 20, 20, false),
      "hmac-sha1-etm@openssh.com": info("sha1", 20, 20, true),
      "hmac-sha1-96": info("sha1", 20, 12, false),
      "hmac-sha2-256": info("sha256", 32, 32, false),
      "hmac-sha2-256-etm@openssh.com": info("sha256", 32, 32, true),
      "hmac-sha2-256-96": info("sha256", 32, 12, false),
      "hmac-sha2-512": info("sha512", 64, 64, false),
      "hmac-sha2-512-etm@openssh.com": info("sha512", 64, 64, true),
      "hmac-sha2-512-96": info("sha512", 64, 12, false)
    };
  })();
  class NullCipher2 {
    constructor(seqno, onWrite) {
      this.outSeqno = seqno;
      this._onWrite = onWrite;
      this._dead = false;
    }
    free() {
      this._dead = true;
    }
    allocPacket(payloadLen) {
      let pktLen = 4 + 1 + payloadLen;
      let padLen = 8 - (pktLen & 8 - 1);
      if (padLen < 4)
        padLen += 8;
      pktLen += padLen;
      const packet = Buffer.allocUnsafe(pktLen);
      writeUInt32BE2(packet, pktLen - 4, 0);
      packet[4] = padLen;
      randomFillSync2(packet, 5 + payloadLen, padLen);
      return packet;
    }
    encrypt(packet) {
      if (this._dead)
        return;
      this._onWrite(packet);
      this.outSeqno = this.outSeqno + 1 >>> 0;
    }
  }
  const POLY1305_ZEROS = Buffer.alloc(32);
  const POLY1305_OUT_COMPUTE = Buffer.alloc(16);
  let POLY1305_WASM_MODULE;
  let POLY1305_RESULT_MALLOC;
  let poly1305_auth;
  class ChaChaPolyCipherNative {
    constructor(config) {
      const enc = config.outbound;
      this.outSeqno = enc.seqno;
      this._onWrite = enc.onWrite;
      this._encKeyMain = enc.cipherKey.slice(0, 32);
      this._encKeyPktLen = enc.cipherKey.slice(32);
      this._dead = false;
    }
    free() {
      this._dead = true;
    }
    allocPacket(payloadLen) {
      let pktLen = 4 + 1 + payloadLen;
      let padLen = 8 - (pktLen - 4 & 8 - 1);
      if (padLen < 4)
        padLen += 8;
      pktLen += padLen;
      const packet = Buffer.allocUnsafe(pktLen);
      writeUInt32BE2(packet, pktLen - 4, 0);
      packet[4] = padLen;
      randomFillSync2(packet, 5 + payloadLen, padLen);
      return packet;
    }
    encrypt(packet) {
      if (this._dead)
        return;
      POLY1305_OUT_COMPUTE[0] = 0;
      writeUInt32BE2(POLY1305_OUT_COMPUTE, this.outSeqno, 12);
      const polyKey = createCipheriv2("chacha20", this._encKeyMain, POLY1305_OUT_COMPUTE).update(POLY1305_ZEROS);
      const pktLenEnc = createCipheriv2("chacha20", this._encKeyPktLen, POLY1305_OUT_COMPUTE).update(packet.slice(0, 4));
      this._onWrite(pktLenEnc);
      POLY1305_OUT_COMPUTE[0] = 1;
      const payloadEnc = createCipheriv2("chacha20", this._encKeyMain, POLY1305_OUT_COMPUTE).update(packet.slice(4));
      this._onWrite(payloadEnc);
      poly1305_auth(
        POLY1305_RESULT_MALLOC,
        pktLenEnc,
        pktLenEnc.length,
        payloadEnc,
        payloadEnc.length,
        polyKey
      );
      const mac = Buffer.allocUnsafe(16);
      mac.set(
        new Uint8Array(
          POLY1305_WASM_MODULE.HEAPU8.buffer,
          POLY1305_RESULT_MALLOC,
          16
        ),
        0
      );
      this._onWrite(mac);
      this.outSeqno = this.outSeqno + 1 >>> 0;
    }
  }
  class ChaChaPolyCipherBinding {
    constructor(config) {
      const enc = config.outbound;
      this.outSeqno = enc.seqno;
      this._onWrite = enc.onWrite;
      this._instance = new ChaChaPolyCipher(enc.cipherKey);
      this._dead = false;
    }
    free() {
      this._dead = true;
      this._instance.free();
    }
    allocPacket(payloadLen) {
      let pktLen = 4 + 1 + payloadLen;
      let padLen = 8 - (pktLen - 4 & 8 - 1);
      if (padLen < 4)
        padLen += 8;
      pktLen += padLen;
      const packet = Buffer.allocUnsafe(
        pktLen + 16
        /* MAC */
      );
      writeUInt32BE2(packet, pktLen - 4, 0);
      packet[4] = padLen;
      randomFillSync2(packet, 5 + payloadLen, padLen);
      return packet;
    }
    encrypt(packet) {
      if (this._dead)
        return;
      this._instance.encrypt(packet, this.outSeqno);
      this._onWrite(packet);
      this.outSeqno = this.outSeqno + 1 >>> 0;
    }
  }
  class AESGCMCipherNative {
    constructor(config) {
      const enc = config.outbound;
      this.outSeqno = enc.seqno;
      this._onWrite = enc.onWrite;
      this._encSSLName = enc.cipherInfo.sslName;
      this._encKey = enc.cipherKey;
      this._encIV = enc.cipherIV;
      this._dead = false;
    }
    free() {
      this._dead = true;
    }
    allocPacket(payloadLen) {
      let pktLen = 4 + 1 + payloadLen;
      let padLen = 16 - (pktLen - 4 & 16 - 1);
      if (padLen < 4)
        padLen += 16;
      pktLen += padLen;
      const packet = Buffer.allocUnsafe(pktLen);
      writeUInt32BE2(packet, pktLen - 4, 0);
      packet[4] = padLen;
      randomFillSync2(packet, 5 + payloadLen, padLen);
      return packet;
    }
    encrypt(packet) {
      if (this._dead)
        return;
      const cipher = createCipheriv2(this._encSSLName, this._encKey, this._encIV);
      cipher.setAutoPadding(false);
      const lenData = packet.slice(0, 4);
      cipher.setAAD(lenData);
      this._onWrite(lenData);
      const encrypted = cipher.update(packet.slice(4));
      this._onWrite(encrypted);
      const final = cipher.final();
      if (final.length)
        this._onWrite(final);
      const tag = cipher.getAuthTag();
      this._onWrite(tag);
      ivIncrement(this._encIV);
      this.outSeqno = this.outSeqno + 1 >>> 0;
    }
  }
  class AESGCMCipherBinding {
    constructor(config) {
      const enc = config.outbound;
      this.outSeqno = enc.seqno;
      this._onWrite = enc.onWrite;
      this._instance = new AESGCMCipher(
        enc.cipherInfo.sslName,
        enc.cipherKey,
        enc.cipherIV
      );
      this._dead = false;
    }
    free() {
      this._dead = true;
      this._instance.free();
    }
    allocPacket(payloadLen) {
      let pktLen = 4 + 1 + payloadLen;
      let padLen = 16 - (pktLen - 4 & 16 - 1);
      if (padLen < 4)
        padLen += 16;
      pktLen += padLen;
      const packet = Buffer.allocUnsafe(
        pktLen + 16
        /* authTag */
      );
      writeUInt32BE2(packet, pktLen - 4, 0);
      packet[4] = padLen;
      randomFillSync2(packet, 5 + payloadLen, padLen);
      return packet;
    }
    encrypt(packet) {
      if (this._dead)
        return;
      this._instance.encrypt(packet);
      this._onWrite(packet);
      this.outSeqno = this.outSeqno + 1 >>> 0;
    }
  }
  class GenericCipherNative {
    constructor(config) {
      const enc = config.outbound;
      this.outSeqno = enc.seqno;
      this._onWrite = enc.onWrite;
      this._encBlockLen = enc.cipherInfo.blockLen;
      this._cipherInstance = createCipheriv2(
        enc.cipherInfo.sslName,
        enc.cipherKey,
        enc.cipherIV
      );
      this._macSSLName = enc.macInfo.sslName;
      this._macKey = enc.macKey;
      this._macActualLen = enc.macInfo.actualLen;
      this._macETM = enc.macInfo.isETM;
      this._aadLen = this._macETM ? 4 : 0;
      this._dead = false;
      const discardLen = enc.cipherInfo.discardLen;
      if (discardLen) {
        let discard = DISCARD_CACHE.get(discardLen);
        if (discard === void 0) {
          discard = Buffer.alloc(discardLen);
          DISCARD_CACHE.set(discardLen, discard);
        }
        this._cipherInstance.update(discard);
      }
    }
    free() {
      this._dead = true;
    }
    allocPacket(payloadLen) {
      const blockLen = this._encBlockLen;
      let pktLen = 4 + 1 + payloadLen;
      let padLen = blockLen - (pktLen - this._aadLen & blockLen - 1);
      if (padLen < 4)
        padLen += blockLen;
      pktLen += padLen;
      const packet = Buffer.allocUnsafe(pktLen);
      writeUInt32BE2(packet, pktLen - 4, 0);
      packet[4] = padLen;
      randomFillSync2(packet, 5 + payloadLen, padLen);
      return packet;
    }
    encrypt(packet) {
      if (this._dead)
        return;
      let mac;
      if (this._macETM) {
        const lenBytes = new Uint8Array(packet.buffer, packet.byteOffset, 4);
        const encrypted = this._cipherInstance.update(
          new Uint8Array(
            packet.buffer,
            packet.byteOffset + 4,
            packet.length - 4
          )
        );
        this._onWrite(lenBytes);
        this._onWrite(encrypted);
        mac = createHmac2(this._macSSLName, this._macKey);
        writeUInt32BE2(BUF_INT, this.outSeqno, 0);
        mac.update(BUF_INT);
        mac.update(lenBytes);
        mac.update(encrypted);
      } else {
        const encrypted = this._cipherInstance.update(packet);
        this._onWrite(encrypted);
        mac = createHmac2(this._macSSLName, this._macKey);
        writeUInt32BE2(BUF_INT, this.outSeqno, 0);
        mac.update(BUF_INT);
        mac.update(packet);
      }
      let digest = mac.digest();
      if (digest.length > this._macActualLen)
        digest = digest.slice(0, this._macActualLen);
      this._onWrite(digest);
      this.outSeqno = this.outSeqno + 1 >>> 0;
    }
  }
  class GenericCipherBinding {
    constructor(config) {
      const enc = config.outbound;
      this.outSeqno = enc.seqno;
      this._onWrite = enc.onWrite;
      this._encBlockLen = enc.cipherInfo.blockLen;
      this._macLen = enc.macInfo.len;
      this._macActualLen = enc.macInfo.actualLen;
      this._aadLen = enc.macInfo.isETM ? 4 : 0;
      this._instance = new GenericCipher(
        enc.cipherInfo.sslName,
        enc.cipherKey,
        enc.cipherIV,
        enc.macInfo.sslName,
        enc.macKey,
        enc.macInfo.isETM
      );
      this._dead = false;
    }
    free() {
      this._dead = true;
      this._instance.free();
    }
    allocPacket(payloadLen) {
      const blockLen = this._encBlockLen;
      let pktLen = 4 + 1 + payloadLen;
      let padLen = blockLen - (pktLen - this._aadLen & blockLen - 1);
      if (padLen < 4)
        padLen += blockLen;
      pktLen += padLen;
      const packet = Buffer.allocUnsafe(pktLen + this._macLen);
      writeUInt32BE2(packet, pktLen - 4, 0);
      packet[4] = padLen;
      randomFillSync2(packet, 5 + payloadLen, padLen);
      return packet;
    }
    encrypt(packet) {
      if (this._dead)
        return;
      this._instance.encrypt(packet, this.outSeqno);
      if (this._macActualLen < this._macLen) {
        packet = new FastBuffer2(
          packet.buffer,
          packet.byteOffset,
          packet.length - (this._macLen - this._macActualLen)
        );
      }
      this._onWrite(packet);
      this.outSeqno = this.outSeqno + 1 >>> 0;
    }
  }
  class NullDecipher2 {
    constructor(seqno, onPayload2) {
      this.inSeqno = seqno;
      this._onPayload = onPayload2;
      this._len = 0;
      this._lenBytes = 0;
      this._packet = null;
      this._packetPos = 0;
    }
    free() {
    }
    decrypt(data, p, dataLen) {
      while (p < dataLen) {
        if (this._lenBytes < 4) {
          let nb = Math.min(4 - this._lenBytes, dataLen - p);
          this._lenBytes += nb;
          while (nb--)
            this._len = (this._len << 8) + data[p++];
          if (this._lenBytes < 4)
            return;
          if (this._len > MAX_PACKET_SIZE || this._len < 8 || (4 + this._len & 7) !== 0) {
            throw new Error("Bad packet length");
          }
          if (p >= dataLen)
            return;
        }
        if (this._packetPos < this._len) {
          const nb = Math.min(this._len - this._packetPos, dataLen - p);
          let chunk;
          if (p !== 0 || nb !== dataLen)
            chunk = new Uint8Array(data.buffer, data.byteOffset + p, nb);
          else
            chunk = data;
          if (nb === this._len) {
            this._packet = chunk;
          } else {
            if (!this._packet)
              this._packet = Buffer.allocUnsafe(this._len);
            this._packet.set(chunk, this._packetPos);
          }
          p += nb;
          this._packetPos += nb;
          if (this._packetPos < this._len)
            return;
        }
        const payload = !this._packet ? EMPTY_BUFFER : new FastBuffer2(
          this._packet.buffer,
          this._packet.byteOffset + 1,
          this._packet.length - this._packet[0] - 1
        );
        this.inSeqno = this.inSeqno + 1 >>> 0;
        this._len = 0;
        this._lenBytes = 0;
        this._packet = null;
        this._packetPos = 0;
        {
          const ret = this._onPayload(payload);
          if (ret !== void 0)
            return ret === false ? p : ret;
        }
      }
    }
  }
  class ChaChaPolyDecipherNative {
    constructor(config) {
      const dec = config.inbound;
      this.inSeqno = dec.seqno;
      this._onPayload = dec.onPayload;
      this._decKeyMain = dec.decipherKey.slice(0, 32);
      this._decKeyPktLen = dec.decipherKey.slice(32);
      this._len = 0;
      this._lenBuf = Buffer.alloc(4);
      this._lenPos = 0;
      this._packet = null;
      this._pktLen = 0;
      this._mac = Buffer.allocUnsafe(16);
      this._calcMac = Buffer.allocUnsafe(16);
      this._macPos = 0;
    }
    free() {
    }
    decrypt(data, p, dataLen) {
      while (p < dataLen) {
        if (this._lenPos < 4) {
          let nb = Math.min(4 - this._lenPos, dataLen - p);
          while (nb--)
            this._lenBuf[this._lenPos++] = data[p++];
          if (this._lenPos < 4)
            return;
          POLY1305_OUT_COMPUTE[0] = 0;
          writeUInt32BE2(POLY1305_OUT_COMPUTE, this.inSeqno, 12);
          const decLenBytes = createDecipheriv2("chacha20", this._decKeyPktLen, POLY1305_OUT_COMPUTE).update(this._lenBuf);
          this._len = readUInt32BE2(decLenBytes, 0);
          if (this._len > MAX_PACKET_SIZE || this._len < 8 || (this._len & 7) !== 0) {
            throw new Error("Bad packet length");
          }
        }
        if (this._pktLen < this._len) {
          if (p >= dataLen)
            return;
          const nb = Math.min(this._len - this._pktLen, dataLen - p);
          let encrypted;
          if (p !== 0 || nb !== dataLen)
            encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);
          else
            encrypted = data;
          if (nb === this._len) {
            this._packet = encrypted;
          } else {
            if (!this._packet)
              this._packet = Buffer.allocUnsafe(this._len);
            this._packet.set(encrypted, this._pktLen);
          }
          p += nb;
          this._pktLen += nb;
          if (this._pktLen < this._len || p >= dataLen)
            return;
        }
        {
          const nb = Math.min(16 - this._macPos, dataLen - p);
          if (p !== 0 || nb !== dataLen) {
            this._mac.set(
              new Uint8Array(data.buffer, data.byteOffset + p, nb),
              this._macPos
            );
          } else {
            this._mac.set(data, this._macPos);
          }
          p += nb;
          this._macPos += nb;
          if (this._macPos < 16)
            return;
        }
        POLY1305_OUT_COMPUTE[0] = 0;
        writeUInt32BE2(POLY1305_OUT_COMPUTE, this.inSeqno, 12);
        const polyKey = createCipheriv2("chacha20", this._decKeyMain, POLY1305_OUT_COMPUTE).update(POLY1305_ZEROS);
        poly1305_auth(
          POLY1305_RESULT_MALLOC,
          this._lenBuf,
          4,
          this._packet,
          this._packet.length,
          polyKey
        );
        this._calcMac.set(
          new Uint8Array(
            POLY1305_WASM_MODULE.HEAPU8.buffer,
            POLY1305_RESULT_MALLOC,
            16
          ),
          0
        );
        if (!timingSafeEqual(this._calcMac, this._mac))
          throw new Error("Invalid MAC");
        POLY1305_OUT_COMPUTE[0] = 1;
        const packet = createDecipheriv2("chacha20", this._decKeyMain, POLY1305_OUT_COMPUTE).update(this._packet);
        const payload = new FastBuffer2(
          packet.buffer,
          packet.byteOffset + 1,
          packet.length - packet[0] - 1
        );
        this.inSeqno = this.inSeqno + 1 >>> 0;
        this._len = 0;
        this._lenPos = 0;
        this._packet = null;
        this._pktLen = 0;
        this._macPos = 0;
        {
          const ret = this._onPayload(payload);
          if (ret !== void 0)
            return ret === false ? p : ret;
        }
      }
    }
  }
  class ChaChaPolyDecipherBinding {
    constructor(config) {
      const dec = config.inbound;
      this.inSeqno = dec.seqno;
      this._onPayload = dec.onPayload;
      this._instance = new ChaChaPolyDecipher(dec.decipherKey);
      this._len = 0;
      this._lenBuf = Buffer.alloc(4);
      this._lenPos = 0;
      this._packet = null;
      this._pktLen = 0;
      this._mac = Buffer.allocUnsafe(16);
      this._macPos = 0;
    }
    free() {
      this._instance.free();
    }
    decrypt(data, p, dataLen) {
      while (p < dataLen) {
        if (this._lenPos < 4) {
          let nb = Math.min(4 - this._lenPos, dataLen - p);
          while (nb--)
            this._lenBuf[this._lenPos++] = data[p++];
          if (this._lenPos < 4)
            return;
          this._len = this._instance.decryptLen(this._lenBuf, this.inSeqno);
          if (this._len > MAX_PACKET_SIZE || this._len < 8 || (this._len & 7) !== 0) {
            throw new Error("Bad packet length");
          }
          if (p >= dataLen)
            return;
        }
        if (this._pktLen < this._len) {
          const nb = Math.min(this._len - this._pktLen, dataLen - p);
          let encrypted;
          if (p !== 0 || nb !== dataLen)
            encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);
          else
            encrypted = data;
          if (nb === this._len) {
            this._packet = encrypted;
          } else {
            if (!this._packet)
              this._packet = Buffer.allocUnsafe(this._len);
            this._packet.set(encrypted, this._pktLen);
          }
          p += nb;
          this._pktLen += nb;
          if (this._pktLen < this._len || p >= dataLen)
            return;
        }
        {
          const nb = Math.min(16 - this._macPos, dataLen - p);
          if (p !== 0 || nb !== dataLen) {
            this._mac.set(
              new Uint8Array(data.buffer, data.byteOffset + p, nb),
              this._macPos
            );
          } else {
            this._mac.set(data, this._macPos);
          }
          p += nb;
          this._macPos += nb;
          if (this._macPos < 16)
            return;
        }
        this._instance.decrypt(this._packet, this._mac, this.inSeqno);
        const payload = new FastBuffer2(
          this._packet.buffer,
          this._packet.byteOffset + 1,
          this._packet.length - this._packet[0] - 1
        );
        this.inSeqno = this.inSeqno + 1 >>> 0;
        this._len = 0;
        this._lenPos = 0;
        this._packet = null;
        this._pktLen = 0;
        this._macPos = 0;
        {
          const ret = this._onPayload(payload);
          if (ret !== void 0)
            return ret === false ? p : ret;
        }
      }
    }
  }
  class AESGCMDecipherNative {
    constructor(config) {
      const dec = config.inbound;
      this.inSeqno = dec.seqno;
      this._onPayload = dec.onPayload;
      this._decipherInstance = null;
      this._decipherSSLName = dec.decipherInfo.sslName;
      this._decipherKey = dec.decipherKey;
      this._decipherIV = dec.decipherIV;
      this._len = 0;
      this._lenBytes = 0;
      this._packet = null;
      this._packetPos = 0;
      this._pktLen = 0;
      this._tag = Buffer.allocUnsafe(16);
      this._tagPos = 0;
    }
    free() {
    }
    decrypt(data, p, dataLen) {
      while (p < dataLen) {
        if (this._lenBytes < 4) {
          let nb = Math.min(4 - this._lenBytes, dataLen - p);
          this._lenBytes += nb;
          while (nb--)
            this._len = (this._len << 8) + data[p++];
          if (this._lenBytes < 4)
            return;
          if (this._len + 20 > MAX_PACKET_SIZE || this._len < 16 || (this._len & 15) !== 0) {
            throw new Error("Bad packet length");
          }
          this._decipherInstance = createDecipheriv2(
            this._decipherSSLName,
            this._decipherKey,
            this._decipherIV
          );
          this._decipherInstance.setAutoPadding(false);
          this._decipherInstance.setAAD(intToBytes(this._len));
        }
        if (this._pktLen < this._len) {
          if (p >= dataLen)
            return;
          const nb = Math.min(this._len - this._pktLen, dataLen - p);
          let decrypted;
          if (p !== 0 || nb !== dataLen) {
            decrypted = this._decipherInstance.update(
              new Uint8Array(data.buffer, data.byteOffset + p, nb)
            );
          } else {
            decrypted = this._decipherInstance.update(data);
          }
          if (decrypted.length) {
            if (nb === this._len) {
              this._packet = decrypted;
            } else {
              if (!this._packet)
                this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(decrypted, this._packetPos);
            }
            this._packetPos += decrypted.length;
          }
          p += nb;
          this._pktLen += nb;
          if (this._pktLen < this._len || p >= dataLen)
            return;
        }
        {
          const nb = Math.min(16 - this._tagPos, dataLen - p);
          if (p !== 0 || nb !== dataLen) {
            this._tag.set(
              new Uint8Array(data.buffer, data.byteOffset + p, nb),
              this._tagPos
            );
          } else {
            this._tag.set(data, this._tagPos);
          }
          p += nb;
          this._tagPos += nb;
          if (this._tagPos < 16)
            return;
        }
        {
          this._decipherInstance.setAuthTag(this._tag);
          const decrypted = this._decipherInstance.final();
          if (decrypted.length) {
            if (this._packet)
              this._packet.set(decrypted, this._packetPos);
            else
              this._packet = decrypted;
          }
        }
        const payload = !this._packet ? EMPTY_BUFFER : new FastBuffer2(
          this._packet.buffer,
          this._packet.byteOffset + 1,
          this._packet.length - this._packet[0] - 1
        );
        this.inSeqno = this.inSeqno + 1 >>> 0;
        ivIncrement(this._decipherIV);
        this._len = 0;
        this._lenBytes = 0;
        this._packet = null;
        this._packetPos = 0;
        this._pktLen = 0;
        this._tagPos = 0;
        {
          const ret = this._onPayload(payload);
          if (ret !== void 0)
            return ret === false ? p : ret;
        }
      }
    }
  }
  class AESGCMDecipherBinding {
    constructor(config) {
      const dec = config.inbound;
      this.inSeqno = dec.seqno;
      this._onPayload = dec.onPayload;
      this._instance = new AESGCMDecipher(
        dec.decipherInfo.sslName,
        dec.decipherKey,
        dec.decipherIV
      );
      this._len = 0;
      this._lenBytes = 0;
      this._packet = null;
      this._pktLen = 0;
      this._tag = Buffer.allocUnsafe(16);
      this._tagPos = 0;
    }
    free() {
    }
    decrypt(data, p, dataLen) {
      while (p < dataLen) {
        if (this._lenBytes < 4) {
          let nb = Math.min(4 - this._lenBytes, dataLen - p);
          this._lenBytes += nb;
          while (nb--)
            this._len = (this._len << 8) + data[p++];
          if (this._lenBytes < 4)
            return;
          if (this._len + 20 > MAX_PACKET_SIZE || this._len < 16 || (this._len & 15) !== 0) {
            throw new Error(`Bad packet length: ${this._len}`);
          }
        }
        if (this._pktLen < this._len) {
          if (p >= dataLen)
            return;
          const nb = Math.min(this._len - this._pktLen, dataLen - p);
          let encrypted;
          if (p !== 0 || nb !== dataLen)
            encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);
          else
            encrypted = data;
          if (nb === this._len) {
            this._packet = encrypted;
          } else {
            if (!this._packet)
              this._packet = Buffer.allocUnsafe(this._len);
            this._packet.set(encrypted, this._pktLen);
          }
          p += nb;
          this._pktLen += nb;
          if (this._pktLen < this._len || p >= dataLen)
            return;
        }
        {
          const nb = Math.min(16 - this._tagPos, dataLen - p);
          if (p !== 0 || nb !== dataLen) {
            this._tag.set(
              new Uint8Array(data.buffer, data.byteOffset + p, nb),
              this._tagPos
            );
          } else {
            this._tag.set(data, this._tagPos);
          }
          p += nb;
          this._tagPos += nb;
          if (this._tagPos < 16)
            return;
        }
        this._instance.decrypt(this._packet, this._len, this._tag);
        const payload = new FastBuffer2(
          this._packet.buffer,
          this._packet.byteOffset + 1,
          this._packet.length - this._packet[0] - 1
        );
        this.inSeqno = this.inSeqno + 1 >>> 0;
        this._len = 0;
        this._lenBytes = 0;
        this._packet = null;
        this._pktLen = 0;
        this._tagPos = 0;
        {
          const ret = this._onPayload(payload);
          if (ret !== void 0)
            return ret === false ? p : ret;
        }
      }
    }
  }
  class GenericDecipherNative {
    constructor(config) {
      const dec = config.inbound;
      this.inSeqno = dec.seqno;
      this._onPayload = dec.onPayload;
      this._decipherInstance = createDecipheriv2(
        dec.decipherInfo.sslName,
        dec.decipherKey,
        dec.decipherIV
      );
      this._decipherInstance.setAutoPadding(false);
      this._block = Buffer.allocUnsafe(
        dec.macInfo.isETM ? 4 : dec.decipherInfo.blockLen
      );
      this._blockSize = dec.decipherInfo.blockLen;
      this._blockPos = 0;
      this._len = 0;
      this._packet = null;
      this._packetPos = 0;
      this._pktLen = 0;
      this._mac = Buffer.allocUnsafe(dec.macInfo.actualLen);
      this._macPos = 0;
      this._macSSLName = dec.macInfo.sslName;
      this._macKey = dec.macKey;
      this._macActualLen = dec.macInfo.actualLen;
      this._macETM = dec.macInfo.isETM;
      this._macInstance = null;
      const discardLen = dec.decipherInfo.discardLen;
      if (discardLen) {
        let discard = DISCARD_CACHE.get(discardLen);
        if (discard === void 0) {
          discard = Buffer.alloc(discardLen);
          DISCARD_CACHE.set(discardLen, discard);
        }
        this._decipherInstance.update(discard);
      }
    }
    free() {
    }
    decrypt(data, p, dataLen) {
      while (p < dataLen) {
        if (this._blockPos < this._block.length) {
          const nb = Math.min(this._block.length - this._blockPos, dataLen - p);
          if (p !== 0 || nb !== dataLen || nb < data.length) {
            this._block.set(
              new Uint8Array(data.buffer, data.byteOffset + p, nb),
              this._blockPos
            );
          } else {
            this._block.set(data, this._blockPos);
          }
          p += nb;
          this._blockPos += nb;
          if (this._blockPos < this._block.length)
            return;
          let decrypted;
          let need;
          if (this._macETM) {
            this._len = need = readUInt32BE2(this._block, 0);
          } else {
            decrypted = this._decipherInstance.update(this._block);
            this._len = readUInt32BE2(decrypted, 0);
            need = 4 + this._len - this._blockSize;
          }
          if (this._len > MAX_PACKET_SIZE || this._len < 5 || (need & this._blockSize - 1) !== 0) {
            throw new Error("Bad packet length");
          }
          this._macInstance = createHmac2(this._macSSLName, this._macKey);
          writeUInt32BE2(BUF_INT, this.inSeqno, 0);
          this._macInstance.update(BUF_INT);
          if (this._macETM) {
            this._macInstance.update(this._block);
          } else {
            this._macInstance.update(new Uint8Array(
              decrypted.buffer,
              decrypted.byteOffset,
              4
            ));
            this._pktLen = decrypted.length - 4;
            this._packetPos = this._pktLen;
            this._packet = Buffer.allocUnsafe(this._len);
            this._packet.set(
              new Uint8Array(
                decrypted.buffer,
                decrypted.byteOffset + 4,
                this._packetPos
              ),
              0
            );
          }
          if (p >= dataLen)
            return;
        }
        if (this._pktLen < this._len) {
          const nb = Math.min(this._len - this._pktLen, dataLen - p);
          let encrypted;
          if (p !== 0 || nb !== dataLen)
            encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);
          else
            encrypted = data;
          if (this._macETM)
            this._macInstance.update(encrypted);
          const decrypted = this._decipherInstance.update(encrypted);
          if (decrypted.length) {
            if (nb === this._len) {
              this._packet = decrypted;
            } else {
              if (!this._packet)
                this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(decrypted, this._packetPos);
            }
            this._packetPos += decrypted.length;
          }
          p += nb;
          this._pktLen += nb;
          if (this._pktLen < this._len || p >= dataLen)
            return;
        }
        {
          const nb = Math.min(this._macActualLen - this._macPos, dataLen - p);
          if (p !== 0 || nb !== dataLen) {
            this._mac.set(
              new Uint8Array(data.buffer, data.byteOffset + p, nb),
              this._macPos
            );
          } else {
            this._mac.set(data, this._macPos);
          }
          p += nb;
          this._macPos += nb;
          if (this._macPos < this._macActualLen)
            return;
        }
        if (!this._macETM)
          this._macInstance.update(this._packet);
        let calculated = this._macInstance.digest();
        if (this._macActualLen < calculated.length) {
          calculated = new Uint8Array(
            calculated.buffer,
            calculated.byteOffset,
            this._macActualLen
          );
        }
        if (!timingSafeEquals(calculated, this._mac))
          throw new Error("Invalid MAC");
        const payload = new FastBuffer2(
          this._packet.buffer,
          this._packet.byteOffset + 1,
          this._packet.length - this._packet[0] - 1
        );
        this.inSeqno = this.inSeqno + 1 >>> 0;
        this._blockPos = 0;
        this._len = 0;
        this._packet = null;
        this._packetPos = 0;
        this._pktLen = 0;
        this._macPos = 0;
        this._macInstance = null;
        {
          const ret = this._onPayload(payload);
          if (ret !== void 0)
            return ret === false ? p : ret;
        }
      }
    }
  }
  class GenericDecipherBinding {
    constructor(config) {
      const dec = config.inbound;
      this.inSeqno = dec.seqno;
      this._onPayload = dec.onPayload;
      this._instance = new GenericDecipher(
        dec.decipherInfo.sslName,
        dec.decipherKey,
        dec.decipherIV,
        dec.macInfo.sslName,
        dec.macKey,
        dec.macInfo.isETM,
        dec.macInfo.actualLen
      );
      this._block = Buffer.allocUnsafe(
        dec.macInfo.isETM || dec.decipherInfo.stream ? 4 : dec.decipherInfo.blockLen
      );
      this._blockPos = 0;
      this._len = 0;
      this._packet = null;
      this._pktLen = 0;
      this._mac = Buffer.allocUnsafe(dec.macInfo.actualLen);
      this._macPos = 0;
      this._macActualLen = dec.macInfo.actualLen;
      this._macETM = dec.macInfo.isETM;
    }
    free() {
      this._instance.free();
    }
    decrypt(data, p, dataLen) {
      while (p < dataLen) {
        if (this._blockPos < this._block.length) {
          const nb = Math.min(this._block.length - this._blockPos, dataLen - p);
          if (p !== 0 || nb !== dataLen || nb < data.length) {
            this._block.set(
              new Uint8Array(data.buffer, data.byteOffset + p, nb),
              this._blockPos
            );
          } else {
            this._block.set(data, this._blockPos);
          }
          p += nb;
          this._blockPos += nb;
          if (this._blockPos < this._block.length)
            return;
          let need;
          if (this._macETM) {
            this._len = need = readUInt32BE2(this._block, 0);
          } else {
            this._instance.decryptBlock(this._block);
            this._len = readUInt32BE2(this._block, 0);
            need = 4 + this._len - this._block.length;
          }
          if (this._len > MAX_PACKET_SIZE || this._len < 5 || (need & this._block.length - 1) !== 0) {
            throw new Error("Bad packet length");
          }
          if (!this._macETM) {
            this._pktLen = this._block.length - 4;
            if (this._pktLen) {
              this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(
                new Uint8Array(
                  this._block.buffer,
                  this._block.byteOffset + 4,
                  this._pktLen
                ),
                0
              );
            }
          }
          if (p >= dataLen)
            return;
        }
        if (this._pktLen < this._len) {
          const nb = Math.min(this._len - this._pktLen, dataLen - p);
          let encrypted;
          if (p !== 0 || nb !== dataLen)
            encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);
          else
            encrypted = data;
          if (nb === this._len) {
            this._packet = encrypted;
          } else {
            if (!this._packet)
              this._packet = Buffer.allocUnsafe(this._len);
            this._packet.set(encrypted, this._pktLen);
          }
          p += nb;
          this._pktLen += nb;
          if (this._pktLen < this._len || p >= dataLen)
            return;
        }
        {
          const nb = Math.min(this._macActualLen - this._macPos, dataLen - p);
          if (p !== 0 || nb !== dataLen) {
            this._mac.set(
              new Uint8Array(data.buffer, data.byteOffset + p, nb),
              this._macPos
            );
          } else {
            this._mac.set(data, this._macPos);
          }
          p += nb;
          this._macPos += nb;
          if (this._macPos < this._macActualLen)
            return;
        }
        this._instance.decrypt(
          this._packet,
          this.inSeqno,
          this._block,
          this._mac
        );
        const payload = new FastBuffer2(
          this._packet.buffer,
          this._packet.byteOffset + 1,
          this._packet.length - this._packet[0] - 1
        );
        this.inSeqno = this.inSeqno + 1 >>> 0;
        this._blockPos = 0;
        this._len = 0;
        this._packet = null;
        this._pktLen = 0;
        this._macPos = 0;
        this._macInstance = null;
        {
          const ret = this._onPayload(payload);
          if (ret !== void 0)
            return ret === false ? p : ret;
        }
      }
    }
  }
  function ivIncrement(iv) {
    ++iv[11] >>> 8 && ++iv[10] >>> 8 && ++iv[9] >>> 8 && ++iv[8] >>> 8 && ++iv[7] >>> 8 && ++iv[6] >>> 8 && ++iv[5] >>> 8 && ++iv[4] >>> 8;
  }
  const intToBytes = (() => {
    const ret = Buffer.alloc(4);
    return (n) => {
      ret[0] = n >>> 24;
      ret[1] = n >>> 16;
      ret[2] = n >>> 8;
      ret[3] = n;
      return ret;
    };
  })();
  function timingSafeEquals(a, b) {
    if (a.length !== b.length) {
      timingSafeEqual(a, a);
      return false;
    }
    return timingSafeEqual(a, b);
  }
  function createCipher(config) {
    if (typeof config !== "object" || config === null)
      throw new Error("Invalid config");
    if (typeof config.outbound !== "object" || config.outbound === null)
      throw new Error("Invalid outbound");
    const outbound = config.outbound;
    if (typeof outbound.onWrite !== "function")
      throw new Error("Invalid outbound.onWrite");
    if (typeof outbound.cipherInfo !== "object" || outbound.cipherInfo === null)
      throw new Error("Invalid outbound.cipherInfo");
    if (!Buffer.isBuffer(outbound.cipherKey) || outbound.cipherKey.length !== outbound.cipherInfo.keyLen) {
      throw new Error("Invalid outbound.cipherKey");
    }
    if (outbound.cipherInfo.ivLen && (!Buffer.isBuffer(outbound.cipherIV) || outbound.cipherIV.length !== outbound.cipherInfo.ivLen)) {
      throw new Error("Invalid outbound.cipherIV");
    }
    if (typeof outbound.seqno !== "number" || outbound.seqno < 0 || outbound.seqno > MAX_SEQNO) {
      throw new Error("Invalid outbound.seqno");
    }
    const forceNative = !!outbound.forceNative;
    switch (outbound.cipherInfo.sslName) {
      case "aes-128-gcm":
      case "aes-256-gcm":
        return AESGCMCipher && !forceNative ? new AESGCMCipherBinding(config) : new AESGCMCipherNative(config);
      case "chacha20":
        return ChaChaPolyCipher && !forceNative ? new ChaChaPolyCipherBinding(config) : new ChaChaPolyCipherNative(config);
      default: {
        if (typeof outbound.macInfo !== "object" || outbound.macInfo === null)
          throw new Error("Invalid outbound.macInfo");
        if (!Buffer.isBuffer(outbound.macKey) || outbound.macKey.length !== outbound.macInfo.len) {
          throw new Error("Invalid outbound.macKey");
        }
        return GenericCipher && !forceNative ? new GenericCipherBinding(config) : new GenericCipherNative(config);
      }
    }
  }
  function createDecipher(config) {
    if (typeof config !== "object" || config === null)
      throw new Error("Invalid config");
    if (typeof config.inbound !== "object" || config.inbound === null)
      throw new Error("Invalid inbound");
    const inbound = config.inbound;
    if (typeof inbound.onPayload !== "function")
      throw new Error("Invalid inbound.onPayload");
    if (typeof inbound.decipherInfo !== "object" || inbound.decipherInfo === null) {
      throw new Error("Invalid inbound.decipherInfo");
    }
    if (!Buffer.isBuffer(inbound.decipherKey) || inbound.decipherKey.length !== inbound.decipherInfo.keyLen) {
      throw new Error("Invalid inbound.decipherKey");
    }
    if (inbound.decipherInfo.ivLen && (!Buffer.isBuffer(inbound.decipherIV) || inbound.decipherIV.length !== inbound.decipherInfo.ivLen)) {
      throw new Error("Invalid inbound.decipherIV");
    }
    if (typeof inbound.seqno !== "number" || inbound.seqno < 0 || inbound.seqno > MAX_SEQNO) {
      throw new Error("Invalid inbound.seqno");
    }
    const forceNative = !!inbound.forceNative;
    switch (inbound.decipherInfo.sslName) {
      case "aes-128-gcm":
      case "aes-256-gcm":
        return AESGCMDecipher && !forceNative ? new AESGCMDecipherBinding(config) : new AESGCMDecipherNative(config);
      case "chacha20":
        return ChaChaPolyDecipher && !forceNative ? new ChaChaPolyDecipherBinding(config) : new ChaChaPolyDecipherNative(config);
      default: {
        if (typeof inbound.macInfo !== "object" || inbound.macInfo === null)
          throw new Error("Invalid inbound.macInfo");
        if (!Buffer.isBuffer(inbound.macKey) || inbound.macKey.length !== inbound.macInfo.len) {
          throw new Error("Invalid inbound.macKey");
        }
        return GenericDecipher && !forceNative ? new GenericDecipherBinding(config) : new GenericDecipherNative(config);
      }
    }
  }
  crypto = {
    CIPHER_INFO: CIPHER_INFO2,
    MAC_INFO,
    bindingAvailable: !!binding,
    init: (() => {
      return new Promise(async (resolve2, reject) => {
        try {
          POLY1305_WASM_MODULE = await requirePoly1305()();
          POLY1305_RESULT_MALLOC = POLY1305_WASM_MODULE._malloc(16);
          poly1305_auth = POLY1305_WASM_MODULE.cwrap(
            "poly1305_auth",
            null,
            ["number", "array", "number", "array", "number", "array"]
          );
        } catch (ex) {
          return reject(ex);
        }
        resolve2();
      });
    })(),
    NullCipher: NullCipher2,
    createCipher,
    NullDecipher: NullDecipher2,
    createDecipher
  };
  return crypto;
}
const {
  createDecipheriv,
  createECDH,
  createHash: createHash$1,
  createHmac,
  createSign,
  createVerify,
  getCiphers,
  sign: sign_,
  verify: verify_
} = require$$0$3;
const supportedOpenSSLCiphers = getCiphers();
const { Ber: Ber$1 } = lib$1;
const bcrypt_pbkdf$1 = bcryptPbkdf.pbkdf;
const { CIPHER_INFO: CIPHER_INFO$1 } = requireCrypto();
const { eddsaSupported: eddsaSupported$1, SUPPORTED_CIPHER: SUPPORTED_CIPHER$2 } = requireConstants();
const {
  bufferSlice: bufferSlice$4,
  makeBufferParser: makeBufferParser$3,
  readString,
  readUInt32BE: readUInt32BE$2,
  writeUInt32BE: writeUInt32BE$6
} = requireUtils();
const SYM_HASH_ALGO = Symbol("Hash Algorithm");
const SYM_PRIV_PEM = Symbol("Private key PEM");
const SYM_PUB_PEM = Symbol("Public key PEM");
const SYM_PUB_SSH = Symbol("Public key SSH");
const SYM_DECRYPTED = Symbol("Decrypted Key");
const CIPHER_INFO_OPENSSL = /* @__PURE__ */ Object.create(null);
{
  const keys = Object.keys(CIPHER_INFO$1);
  for (let i = 0; i < keys.length; ++i) {
    const cipherName = CIPHER_INFO$1[keys[i]].sslName;
    if (!cipherName || CIPHER_INFO_OPENSSL[cipherName])
      continue;
    CIPHER_INFO_OPENSSL[cipherName] = CIPHER_INFO$1[keys[i]];
  }
}
const binaryKeyParser = makeBufferParser$3();
function makePEM(type2, data) {
  data = data.base64Slice(0, data.length);
  let formatted = data.replace(/.{64}/g, "$&\n");
  if (data.length & 63)
    formatted += "\n";
  return `-----BEGIN ${type2} KEY-----
${formatted}-----END ${type2} KEY-----`;
}
function combineBuffers(buf1, buf2) {
  const result = Buffer.allocUnsafe(buf1.length + buf2.length);
  result.set(buf1, 0);
  result.set(buf2, buf1.length);
  return result;
}
function skipFields(buf, nfields) {
  const bufLen = buf.length;
  let pos = buf._pos || 0;
  for (let i = 0; i < nfields; ++i) {
    const left = bufLen - pos;
    if (pos >= bufLen || left < 4)
      return false;
    const len = readUInt32BE$2(buf, pos);
    if (left < 4 + len)
      return false;
    pos += 4 + len;
  }
  buf._pos = pos;
  return true;
}
function genOpenSSLRSAPub(n, e) {
  const asnWriter = new Ber$1.Writer();
  asnWriter.startSequence();
  asnWriter.startSequence();
  asnWriter.writeOID("1.2.840.113549.1.1.1");
  asnWriter.writeNull();
  asnWriter.endSequence();
  asnWriter.startSequence(Ber$1.BitString);
  asnWriter.writeByte(0);
  asnWriter.startSequence();
  asnWriter.writeBuffer(n, Ber$1.Integer);
  asnWriter.writeBuffer(e, Ber$1.Integer);
  asnWriter.endSequence();
  asnWriter.endSequence();
  asnWriter.endSequence();
  return makePEM("PUBLIC", asnWriter.buffer);
}
function genOpenSSHRSAPub(n, e) {
  const publicKey = Buffer.allocUnsafe(4 + 7 + 4 + e.length + 4 + n.length);
  writeUInt32BE$6(publicKey, 7, 0);
  publicKey.utf8Write("ssh-rsa", 4, 7);
  let i = 4 + 7;
  writeUInt32BE$6(publicKey, e.length, i);
  publicKey.set(e, i += 4);
  writeUInt32BE$6(publicKey, n.length, i += e.length);
  publicKey.set(n, i + 4);
  return publicKey;
}
const genOpenSSLRSAPriv = /* @__PURE__ */ (() => {
  function genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp) {
    const asnWriter = new Ber$1.Writer();
    asnWriter.startSequence();
    asnWriter.writeInt(0, Ber$1.Integer);
    asnWriter.writeBuffer(n, Ber$1.Integer);
    asnWriter.writeBuffer(e, Ber$1.Integer);
    asnWriter.writeBuffer(d, Ber$1.Integer);
    asnWriter.writeBuffer(p, Ber$1.Integer);
    asnWriter.writeBuffer(q, Ber$1.Integer);
    asnWriter.writeBuffer(dmp1, Ber$1.Integer);
    asnWriter.writeBuffer(dmq1, Ber$1.Integer);
    asnWriter.writeBuffer(iqmp, Ber$1.Integer);
    asnWriter.endSequence();
    return asnWriter.buffer;
  }
  function bigIntFromBuffer(buf) {
    return BigInt(`0x${buf.hexSlice(0, buf.length)}`);
  }
  function bigIntToBuffer(bn) {
    let hex = bn.toString(16);
    if ((hex.length & 1) !== 0) {
      hex = `0${hex}`;
    } else {
      const sigbit = hex.charCodeAt(0);
      if (sigbit === 56 || sigbit === 57 || sigbit >= 97 && sigbit <= 102) {
        hex = `00${hex}`;
      }
    }
    return Buffer.from(hex, "hex");
  }
  return function genOpenSSLRSAPriv2(n, e, d, iqmp, p, q) {
    const bn_d = bigIntFromBuffer(d);
    const dmp1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(p) - 1n));
    const dmq1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(q) - 1n));
    return makePEM(
      "RSA PRIVATE",
      genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp)
    );
  };
})();
function genOpenSSLDSAPub(p, q, g, y) {
  const asnWriter = new Ber$1.Writer();
  asnWriter.startSequence();
  asnWriter.startSequence();
  asnWriter.writeOID("1.2.840.10040.4.1");
  asnWriter.startSequence();
  asnWriter.writeBuffer(p, Ber$1.Integer);
  asnWriter.writeBuffer(q, Ber$1.Integer);
  asnWriter.writeBuffer(g, Ber$1.Integer);
  asnWriter.endSequence();
  asnWriter.endSequence();
  asnWriter.startSequence(Ber$1.BitString);
  asnWriter.writeByte(0);
  asnWriter.writeBuffer(y, Ber$1.Integer);
  asnWriter.endSequence();
  asnWriter.endSequence();
  return makePEM("PUBLIC", asnWriter.buffer);
}
function genOpenSSHDSAPub(p, q, g, y) {
  const publicKey = Buffer.allocUnsafe(
    4 + 7 + 4 + p.length + 4 + q.length + 4 + g.length + 4 + y.length
  );
  writeUInt32BE$6(publicKey, 7, 0);
  publicKey.utf8Write("ssh-dss", 4, 7);
  let i = 4 + 7;
  writeUInt32BE$6(publicKey, p.length, i);
  publicKey.set(p, i += 4);
  writeUInt32BE$6(publicKey, q.length, i += p.length);
  publicKey.set(q, i += 4);
  writeUInt32BE$6(publicKey, g.length, i += q.length);
  publicKey.set(g, i += 4);
  writeUInt32BE$6(publicKey, y.length, i += g.length);
  publicKey.set(y, i + 4);
  return publicKey;
}
function genOpenSSLDSAPriv(p, q, g, y, x) {
  const asnWriter = new Ber$1.Writer();
  asnWriter.startSequence();
  asnWriter.writeInt(0, Ber$1.Integer);
  asnWriter.writeBuffer(p, Ber$1.Integer);
  asnWriter.writeBuffer(q, Ber$1.Integer);
  asnWriter.writeBuffer(g, Ber$1.Integer);
  asnWriter.writeBuffer(y, Ber$1.Integer);
  asnWriter.writeBuffer(x, Ber$1.Integer);
  asnWriter.endSequence();
  return makePEM("DSA PRIVATE", asnWriter.buffer);
}
function genOpenSSLEdPub(pub) {
  const asnWriter = new Ber$1.Writer();
  asnWriter.startSequence();
  asnWriter.startSequence();
  asnWriter.writeOID("1.3.101.112");
  asnWriter.endSequence();
  asnWriter.startSequence(Ber$1.BitString);
  asnWriter.writeByte(0);
  asnWriter._ensure(pub.length);
  asnWriter._buf.set(pub, asnWriter._offset);
  asnWriter._offset += pub.length;
  asnWriter.endSequence();
  asnWriter.endSequence();
  return makePEM("PUBLIC", asnWriter.buffer);
}
function genOpenSSHEdPub(pub) {
  const publicKey = Buffer.allocUnsafe(4 + 11 + 4 + pub.length);
  writeUInt32BE$6(publicKey, 11, 0);
  publicKey.utf8Write("ssh-ed25519", 4, 11);
  writeUInt32BE$6(publicKey, pub.length, 15);
  publicKey.set(pub, 19);
  return publicKey;
}
function genOpenSSLEdPriv(priv) {
  const asnWriter = new Ber$1.Writer();
  asnWriter.startSequence();
  asnWriter.writeInt(0, Ber$1.Integer);
  asnWriter.startSequence();
  asnWriter.writeOID("1.3.101.112");
  asnWriter.endSequence();
  asnWriter.startSequence(Ber$1.OctetString);
  asnWriter.writeBuffer(priv, Ber$1.OctetString);
  asnWriter.endSequence();
  asnWriter.endSequence();
  return makePEM("PRIVATE", asnWriter.buffer);
}
function genOpenSSLECDSAPub(oid, Q) {
  const asnWriter = new Ber$1.Writer();
  asnWriter.startSequence();
  asnWriter.startSequence();
  asnWriter.writeOID("1.2.840.10045.2.1");
  asnWriter.writeOID(oid);
  asnWriter.endSequence();
  asnWriter.startSequence(Ber$1.BitString);
  asnWriter.writeByte(0);
  asnWriter._ensure(Q.length);
  asnWriter._buf.set(Q, asnWriter._offset);
  asnWriter._offset += Q.length;
  asnWriter.endSequence();
  asnWriter.endSequence();
  return makePEM("PUBLIC", asnWriter.buffer);
}
function genOpenSSHECDSAPub(oid, Q) {
  let curveName;
  switch (oid) {
    case "1.2.840.10045.3.1.7":
      curveName = "nistp256";
      break;
    case "1.3.132.0.34":
      curveName = "nistp384";
      break;
    case "1.3.132.0.35":
      curveName = "nistp521";
      break;
    default:
      return;
  }
  const publicKey = Buffer.allocUnsafe(4 + 19 + 4 + 8 + 4 + Q.length);
  writeUInt32BE$6(publicKey, 19, 0);
  publicKey.utf8Write(`ecdsa-sha2-${curveName}`, 4, 19);
  writeUInt32BE$6(publicKey, 8, 23);
  publicKey.utf8Write(curveName, 27, 8);
  writeUInt32BE$6(publicKey, Q.length, 35);
  publicKey.set(Q, 39);
  return publicKey;
}
function genOpenSSLECDSAPriv(oid, pub, priv) {
  const asnWriter = new Ber$1.Writer();
  asnWriter.startSequence();
  asnWriter.writeInt(1, Ber$1.Integer);
  asnWriter.writeBuffer(priv, Ber$1.OctetString);
  asnWriter.startSequence(160);
  asnWriter.writeOID(oid);
  asnWriter.endSequence();
  asnWriter.startSequence(161);
  asnWriter.startSequence(Ber$1.BitString);
  asnWriter.writeByte(0);
  asnWriter._ensure(pub.length);
  asnWriter._buf.set(pub, asnWriter._offset);
  asnWriter._offset += pub.length;
  asnWriter.endSequence();
  asnWriter.endSequence();
  asnWriter.endSequence();
  return makePEM("EC PRIVATE", asnWriter.buffer);
}
function genOpenSSLECDSAPubFromPriv(curveName, priv) {
  const tempECDH = createECDH(curveName);
  tempECDH.setPrivateKey(priv);
  return tempECDH.getPublicKey();
}
const BaseKey = {
  sign: (() => {
    if (typeof sign_ === "function") {
      return function sign(data, algo) {
        const pem = this[SYM_PRIV_PEM];
        if (pem === null)
          return new Error("No private key available");
        if (!algo || typeof algo !== "string")
          algo = this[SYM_HASH_ALGO];
        try {
          return sign_(algo, data, pem);
        } catch (ex) {
          return ex;
        }
      };
    }
    return function sign(data, algo) {
      const pem = this[SYM_PRIV_PEM];
      if (pem === null)
        return new Error("No private key available");
      if (!algo || typeof algo !== "string")
        algo = this[SYM_HASH_ALGO];
      const signature = createSign(algo);
      signature.update(data);
      try {
        return signature.sign(pem);
      } catch (ex) {
        return ex;
      }
    };
  })(),
  verify: (() => {
    if (typeof verify_ === "function") {
      return function verify(data, signature, algo) {
        const pem = this[SYM_PUB_PEM];
        if (pem === null)
          return new Error("No public key available");
        if (!algo || typeof algo !== "string")
          algo = this[SYM_HASH_ALGO];
        try {
          return verify_(algo, data, pem, signature);
        } catch (ex) {
          return ex;
        }
      };
    }
    return function verify(data, signature, algo) {
      const pem = this[SYM_PUB_PEM];
      if (pem === null)
        return new Error("No public key available");
      if (!algo || typeof algo !== "string")
        algo = this[SYM_HASH_ALGO];
      const verifier = createVerify(algo);
      verifier.update(data);
      try {
        return verifier.verify(pem, signature);
      } catch (ex) {
        return ex;
      }
    };
  })(),
  isPrivateKey: function isPrivateKey() {
    return this[SYM_PRIV_PEM] !== null;
  },
  getPrivatePEM: function getPrivatePEM() {
    return this[SYM_PRIV_PEM];
  },
  getPublicPEM: function getPublicPEM() {
    return this[SYM_PUB_PEM];
  },
  getPublicSSH: function getPublicSSH() {
    return this[SYM_PUB_SSH];
  },
  equals: function equals(key2) {
    const parsed = parseKey$6(key2);
    if (parsed instanceof Error)
      return false;
    return this.type === parsed.type && this[SYM_PRIV_PEM] === parsed[SYM_PRIV_PEM] && this[SYM_PUB_PEM] === parsed[SYM_PUB_PEM] && this[SYM_PUB_SSH].equals(parsed[SYM_PUB_SSH]);
  }
};
function OpenSSH_Private(type2, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {
  this.type = type2;
  this.comment = comment;
  this[SYM_PRIV_PEM] = privPEM;
  this[SYM_PUB_PEM] = pubPEM;
  this[SYM_PUB_SSH] = pubSSH;
  this[SYM_HASH_ALGO] = algo;
  this[SYM_DECRYPTED] = decrypted;
}
OpenSSH_Private.prototype = BaseKey;
{
  let parseOpenSSHPrivKeys = function(data, nkeys, decrypted) {
    const keys = [];
    if (data.length < 8)
      return new Error("Malformed OpenSSH private key");
    const check1 = readUInt32BE$2(data, 0);
    const check2 = readUInt32BE$2(data, 4);
    if (check1 !== check2) {
      if (decrypted) {
        return new Error(
          "OpenSSH key integrity check failed -- bad passphrase?"
        );
      }
      return new Error("OpenSSH key integrity check failed");
    }
    data._pos = 8;
    let i;
    let oid;
    for (i = 0; i < nkeys; ++i) {
      let algo;
      let privPEM;
      let pubPEM;
      let pubSSH;
      const type2 = readString(data, data._pos, true);
      if (type2 === void 0)
        return new Error("Malformed OpenSSH private key");
      switch (type2) {
        case "ssh-rsa": {
          const n = readString(data, data._pos);
          if (n === void 0)
            return new Error("Malformed OpenSSH private key");
          const e = readString(data, data._pos);
          if (e === void 0)
            return new Error("Malformed OpenSSH private key");
          const d = readString(data, data._pos);
          if (d === void 0)
            return new Error("Malformed OpenSSH private key");
          const iqmp = readString(data, data._pos);
          if (iqmp === void 0)
            return new Error("Malformed OpenSSH private key");
          const p = readString(data, data._pos);
          if (p === void 0)
            return new Error("Malformed OpenSSH private key");
          const q = readString(data, data._pos);
          if (q === void 0)
            return new Error("Malformed OpenSSH private key");
          pubPEM = genOpenSSLRSAPub(n, e);
          pubSSH = genOpenSSHRSAPub(n, e);
          privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p, q);
          algo = "sha1";
          break;
        }
        case "ssh-dss": {
          const p = readString(data, data._pos);
          if (p === void 0)
            return new Error("Malformed OpenSSH private key");
          const q = readString(data, data._pos);
          if (q === void 0)
            return new Error("Malformed OpenSSH private key");
          const g = readString(data, data._pos);
          if (g === void 0)
            return new Error("Malformed OpenSSH private key");
          const y = readString(data, data._pos);
          if (y === void 0)
            return new Error("Malformed OpenSSH private key");
          const x = readString(data, data._pos);
          if (x === void 0)
            return new Error("Malformed OpenSSH private key");
          pubPEM = genOpenSSLDSAPub(p, q, g, y);
          pubSSH = genOpenSSHDSAPub(p, q, g, y);
          privPEM = genOpenSSLDSAPriv(p, q, g, y, x);
          algo = "sha1";
          break;
        }
        case "ssh-ed25519": {
          if (!eddsaSupported$1)
            return new Error(`Unsupported OpenSSH private key type: ${type2}`);
          const edpub = readString(data, data._pos);
          if (edpub === void 0 || edpub.length !== 32)
            return new Error("Malformed OpenSSH private key");
          const edpriv = readString(data, data._pos);
          if (edpriv === void 0 || edpriv.length !== 64)
            return new Error("Malformed OpenSSH private key");
          pubPEM = genOpenSSLEdPub(edpub);
          pubSSH = genOpenSSHEdPub(edpub);
          privPEM = genOpenSSLEdPriv(bufferSlice$4(edpriv, 0, 32));
          algo = null;
          break;
        }
        case "ecdsa-sha2-nistp256":
          algo = "sha256";
          oid = "1.2.840.10045.3.1.7";
        case "ecdsa-sha2-nistp384":
          if (algo === void 0) {
            algo = "sha384";
            oid = "1.3.132.0.34";
          }
        case "ecdsa-sha2-nistp521": {
          if (algo === void 0) {
            algo = "sha512";
            oid = "1.3.132.0.35";
          }
          if (!skipFields(data, 1))
            return new Error("Malformed OpenSSH private key");
          const ecpub = readString(data, data._pos);
          if (ecpub === void 0)
            return new Error("Malformed OpenSSH private key");
          const ecpriv = readString(data, data._pos);
          if (ecpriv === void 0)
            return new Error("Malformed OpenSSH private key");
          pubPEM = genOpenSSLECDSAPub(oid, ecpub);
          pubSSH = genOpenSSHECDSAPub(oid, ecpub);
          privPEM = genOpenSSLECDSAPriv(oid, ecpub, ecpriv);
          break;
        }
        default:
          return new Error(`Unsupported OpenSSH private key type: ${type2}`);
      }
      const privComment = readString(data, data._pos, true);
      if (privComment === void 0)
        return new Error("Malformed OpenSSH private key");
      keys.push(
        new OpenSSH_Private(
          type2,
          privComment,
          privPEM,
          pubPEM,
          pubSSH,
          algo,
          decrypted
        )
      );
    }
    let cnt = 0;
    for (i = data._pos; i < data.length; ++i) {
      if (data[i] !== ++cnt % 255)
        return new Error("Malformed OpenSSH private key");
    }
    return keys;
  };
  const regexp = /^-----BEGIN OPENSSH PRIVATE KEY-----(?:\r\n|\n)([\s\S]+)(?:\r\n|\n)-----END OPENSSH PRIVATE KEY-----$/;
  OpenSSH_Private.parse = (str, passphrase) => {
    const m = regexp.exec(str);
    if (m === null)
      return null;
    let ret;
    const data = Buffer.from(m[1], "base64");
    if (data.length < 31)
      return new Error("Malformed OpenSSH private key");
    const magic = data.utf8Slice(0, 15);
    if (magic !== "openssh-key-v1\0")
      return new Error(`Unsupported OpenSSH key magic: ${magic}`);
    const cipherName = readString(data, 15, true);
    if (cipherName === void 0)
      return new Error("Malformed OpenSSH private key");
    if (cipherName !== "none" && SUPPORTED_CIPHER$2.indexOf(cipherName) === -1)
      return new Error(`Unsupported cipher for OpenSSH key: ${cipherName}`);
    const kdfName = readString(data, data._pos, true);
    if (kdfName === void 0)
      return new Error("Malformed OpenSSH private key");
    if (kdfName !== "none") {
      if (cipherName === "none")
        return new Error("Malformed OpenSSH private key");
      if (kdfName !== "bcrypt")
        return new Error(`Unsupported kdf name for OpenSSH key: ${kdfName}`);
      if (!passphrase) {
        return new Error(
          "Encrypted private OpenSSH key detected, but no passphrase given"
        );
      }
    } else if (cipherName !== "none") {
      return new Error("Malformed OpenSSH private key");
    }
    let encInfo;
    let cipherKey;
    let cipherIV;
    if (cipherName !== "none")
      encInfo = CIPHER_INFO$1[cipherName];
    const kdfOptions = readString(data, data._pos);
    if (kdfOptions === void 0)
      return new Error("Malformed OpenSSH private key");
    if (kdfOptions.length) {
      switch (kdfName) {
        case "none":
          return new Error("Malformed OpenSSH private key");
        case "bcrypt": {
          const salt = readString(kdfOptions, 0);
          if (salt === void 0 || kdfOptions._pos + 4 > kdfOptions.length)
            return new Error("Malformed OpenSSH private key");
          const rounds = readUInt32BE$2(kdfOptions, kdfOptions._pos);
          const gen = Buffer.allocUnsafe(encInfo.keyLen + encInfo.ivLen);
          const r = bcrypt_pbkdf$1(
            passphrase,
            passphrase.length,
            salt,
            salt.length,
            gen,
            gen.length,
            rounds
          );
          if (r !== 0)
            return new Error("Failed to generate information to decrypt key");
          cipherKey = bufferSlice$4(gen, 0, encInfo.keyLen);
          cipherIV = bufferSlice$4(gen, encInfo.keyLen, gen.length);
          break;
        }
      }
    } else if (kdfName !== "none") {
      return new Error("Malformed OpenSSH private key");
    }
    if (data._pos + 3 >= data.length)
      return new Error("Malformed OpenSSH private key");
    const keyCount = readUInt32BE$2(data, data._pos);
    data._pos += 4;
    if (keyCount > 0) {
      for (let i = 0; i < keyCount; ++i) {
        const pubData = readString(data, data._pos);
        if (pubData === void 0)
          return new Error("Malformed OpenSSH private key");
        const type2 = readString(pubData, 0, true);
        if (type2 === void 0)
          return new Error("Malformed OpenSSH private key");
      }
      let privBlob = readString(data, data._pos);
      if (privBlob === void 0)
        return new Error("Malformed OpenSSH private key");
      if (cipherKey !== void 0) {
        if (privBlob.length < encInfo.blockLen || privBlob.length % encInfo.blockLen !== 0) {
          return new Error("Malformed OpenSSH private key");
        }
        try {
          const options = { authTagLength: encInfo.authLen };
          const decipher = createDecipheriv(
            encInfo.sslName,
            cipherKey,
            cipherIV,
            options
          );
          decipher.setAutoPadding(false);
          if (encInfo.authLen > 0) {
            if (data.length - data._pos < encInfo.authLen)
              return new Error("Malformed OpenSSH private key");
            decipher.setAuthTag(
              bufferSlice$4(data, data._pos, data._pos += encInfo.authLen)
            );
          }
          privBlob = combineBuffers(
            decipher.update(privBlob),
            decipher.final()
          );
        } catch (ex) {
          return ex;
        }
      }
      if (data._pos !== data.length)
        return new Error("Malformed OpenSSH private key");
      ret = parseOpenSSHPrivKeys(privBlob, keyCount, cipherKey !== void 0);
    } else {
      ret = [];
    }
    if (ret instanceof Error)
      return ret;
    return ret[0];
  };
}
function OpenSSH_Old_Private(type2, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {
  this.type = type2;
  this.comment = comment;
  this[SYM_PRIV_PEM] = privPEM;
  this[SYM_PUB_PEM] = pubPEM;
  this[SYM_PUB_SSH] = pubSSH;
  this[SYM_HASH_ALGO] = algo;
  this[SYM_DECRYPTED] = decrypted;
}
OpenSSH_Old_Private.prototype = BaseKey;
{
  const regexp = /^-----BEGIN (RSA|DSA|EC) PRIVATE KEY-----(?:\r\n|\n)((?:[^:]+:\s*[\S].*(?:\r\n|\n))*)([\s\S]+)(?:\r\n|\n)-----END (RSA|DSA|EC) PRIVATE KEY-----$/;
  OpenSSH_Old_Private.parse = (str, passphrase) => {
    const m = regexp.exec(str);
    if (m === null)
      return null;
    let privBlob = Buffer.from(m[3], "base64");
    let headers = m[2];
    let decrypted = false;
    if (headers !== void 0) {
      headers = headers.split(/\r\n|\n/g);
      for (let i = 0; i < headers.length; ++i) {
        const header = headers[i];
        let sepIdx = header.indexOf(":");
        if (header.slice(0, sepIdx) === "DEK-Info") {
          const val = header.slice(sepIdx + 2);
          sepIdx = val.indexOf(",");
          if (sepIdx === -1)
            continue;
          const cipherName = val.slice(0, sepIdx).toLowerCase();
          if (supportedOpenSSLCiphers.indexOf(cipherName) === -1) {
            return new Error(
              `Cipher (${cipherName}) not supported for encrypted OpenSSH private key`
            );
          }
          const encInfo = CIPHER_INFO_OPENSSL[cipherName];
          if (!encInfo) {
            return new Error(
              `Cipher (${cipherName}) not supported for encrypted OpenSSH private key`
            );
          }
          const cipherIV = Buffer.from(val.slice(sepIdx + 1), "hex");
          if (cipherIV.length !== encInfo.ivLen)
            return new Error("Malformed encrypted OpenSSH private key");
          if (!passphrase) {
            return new Error(
              "Encrypted OpenSSH private key detected, but no passphrase given"
            );
          }
          const ivSlice = bufferSlice$4(cipherIV, 0, 8);
          let cipherKey = createHash$1("md5").update(passphrase).update(ivSlice).digest();
          while (cipherKey.length < encInfo.keyLen) {
            cipherKey = combineBuffers(
              cipherKey,
              createHash$1("md5").update(cipherKey).update(passphrase).update(ivSlice).digest()
            );
          }
          if (cipherKey.length > encInfo.keyLen)
            cipherKey = bufferSlice$4(cipherKey, 0, encInfo.keyLen);
          try {
            const decipher = createDecipheriv(cipherName, cipherKey, cipherIV);
            decipher.setAutoPadding(false);
            privBlob = combineBuffers(
              decipher.update(privBlob),
              decipher.final()
            );
            decrypted = true;
          } catch (ex) {
            return ex;
          }
        }
      }
    }
    let type2;
    let privPEM;
    let pubPEM;
    let pubSSH;
    let algo;
    let reader2;
    let errMsg = "Malformed OpenSSH private key";
    if (decrypted)
      errMsg += ". Bad passphrase?";
    switch (m[1]) {
      case "RSA":
        type2 = "ssh-rsa";
        privPEM = makePEM("RSA PRIVATE", privBlob);
        try {
          reader2 = new Ber$1.Reader(privBlob);
          reader2.readSequence();
          reader2.readInt();
          const n = reader2.readString(Ber$1.Integer, true);
          if (n === null)
            return new Error(errMsg);
          const e = reader2.readString(Ber$1.Integer, true);
          if (e === null)
            return new Error(errMsg);
          pubPEM = genOpenSSLRSAPub(n, e);
          pubSSH = genOpenSSHRSAPub(n, e);
        } catch {
          return new Error(errMsg);
        }
        algo = "sha1";
        break;
      case "DSA":
        type2 = "ssh-dss";
        privPEM = makePEM("DSA PRIVATE", privBlob);
        try {
          reader2 = new Ber$1.Reader(privBlob);
          reader2.readSequence();
          reader2.readInt();
          const p = reader2.readString(Ber$1.Integer, true);
          if (p === null)
            return new Error(errMsg);
          const q = reader2.readString(Ber$1.Integer, true);
          if (q === null)
            return new Error(errMsg);
          const g = reader2.readString(Ber$1.Integer, true);
          if (g === null)
            return new Error(errMsg);
          const y = reader2.readString(Ber$1.Integer, true);
          if (y === null)
            return new Error(errMsg);
          pubPEM = genOpenSSLDSAPub(p, q, g, y);
          pubSSH = genOpenSSHDSAPub(p, q, g, y);
        } catch {
          return new Error(errMsg);
        }
        algo = "sha1";
        break;
      case "EC": {
        let ecSSLName;
        let ecPriv;
        let ecOID;
        try {
          reader2 = new Ber$1.Reader(privBlob);
          reader2.readSequence();
          reader2.readInt();
          ecPriv = reader2.readString(Ber$1.OctetString, true);
          reader2.readByte();
          const offset = reader2.readLength();
          if (offset !== null) {
            reader2._offset = offset;
            ecOID = reader2.readOID();
            if (ecOID === null)
              return new Error(errMsg);
            switch (ecOID) {
              case "1.2.840.10045.3.1.7":
                ecSSLName = "prime256v1";
                type2 = "ecdsa-sha2-nistp256";
                algo = "sha256";
                break;
              case "1.3.132.0.34":
                ecSSLName = "secp384r1";
                type2 = "ecdsa-sha2-nistp384";
                algo = "sha384";
                break;
              case "1.3.132.0.35":
                ecSSLName = "secp521r1";
                type2 = "ecdsa-sha2-nistp521";
                algo = "sha512";
                break;
              default:
                return new Error(`Unsupported private key EC OID: ${ecOID}`);
            }
          } else {
            return new Error(errMsg);
          }
        } catch {
          return new Error(errMsg);
        }
        privPEM = makePEM("EC PRIVATE", privBlob);
        const pubBlob = genOpenSSLECDSAPubFromPriv(ecSSLName, ecPriv);
        pubPEM = genOpenSSLECDSAPub(ecOID, pubBlob);
        pubSSH = genOpenSSHECDSAPub(ecOID, pubBlob);
        break;
      }
    }
    return new OpenSSH_Old_Private(
      type2,
      "",
      privPEM,
      pubPEM,
      pubSSH,
      algo,
      decrypted
    );
  };
}
function PPK_Private(type2, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {
  this.type = type2;
  this.comment = comment;
  this[SYM_PRIV_PEM] = privPEM;
  this[SYM_PUB_PEM] = pubPEM;
  this[SYM_PUB_SSH] = pubSSH;
  this[SYM_HASH_ALGO] = algo;
  this[SYM_DECRYPTED] = decrypted;
}
PPK_Private.prototype = BaseKey;
{
  const EMPTY_PASSPHRASE = Buffer.alloc(0);
  const PPK_IV = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
  const PPK_PP1 = Buffer.from([0, 0, 0, 0]);
  const PPK_PP2 = Buffer.from([0, 0, 0, 1]);
  const regexp = /^PuTTY-User-Key-File-2: (ssh-(?:rsa|dss))\r?\nEncryption: (aes256-cbc|none)\r?\nComment: ([^\r\n]*)\r?\nPublic-Lines: \d+\r?\n([\s\S]+?)\r?\nPrivate-Lines: \d+\r?\n([\s\S]+?)\r?\nPrivate-MAC: ([^\r\n]+)/;
  PPK_Private.parse = (str, passphrase) => {
    const m = regexp.exec(str);
    if (m === null)
      return null;
    const cipherName = m[2];
    const encrypted = cipherName !== "none";
    if (encrypted && !passphrase) {
      return new Error(
        "Encrypted PPK private key detected, but no passphrase given"
      );
    }
    let privBlob = Buffer.from(m[5], "base64");
    if (encrypted) {
      const encInfo = CIPHER_INFO$1[cipherName];
      let cipherKey = combineBuffers(
        createHash$1("sha1").update(PPK_PP1).update(passphrase).digest(),
        createHash$1("sha1").update(PPK_PP2).update(passphrase).digest()
      );
      if (cipherKey.length > encInfo.keyLen)
        cipherKey = bufferSlice$4(cipherKey, 0, encInfo.keyLen);
      try {
        const decipher = createDecipheriv(encInfo.sslName, cipherKey, PPK_IV);
        decipher.setAutoPadding(false);
        privBlob = combineBuffers(
          decipher.update(privBlob),
          decipher.final()
        );
      } catch (ex) {
        return ex;
      }
    }
    const type2 = m[1];
    const comment = m[3];
    const pubBlob = Buffer.from(m[4], "base64");
    const mac = m[6];
    const typeLen = type2.length;
    const cipherNameLen = cipherName.length;
    const commentLen = Buffer.byteLength(comment);
    const pubLen = pubBlob.length;
    const privLen = privBlob.length;
    const macData = Buffer.allocUnsafe(4 + typeLen + 4 + cipherNameLen + 4 + commentLen + 4 + pubLen + 4 + privLen);
    let p = 0;
    writeUInt32BE$6(macData, typeLen, p);
    macData.utf8Write(type2, p += 4, typeLen);
    writeUInt32BE$6(macData, cipherNameLen, p += typeLen);
    macData.utf8Write(cipherName, p += 4, cipherNameLen);
    writeUInt32BE$6(macData, commentLen, p += cipherNameLen);
    macData.utf8Write(comment, p += 4, commentLen);
    writeUInt32BE$6(macData, pubLen, p += commentLen);
    macData.set(pubBlob, p += 4);
    writeUInt32BE$6(macData, privLen, p += pubLen);
    macData.set(privBlob, p + 4);
    if (!passphrase)
      passphrase = EMPTY_PASSPHRASE;
    const calcMAC = createHmac(
      "sha1",
      createHash$1("sha1").update("putty-private-key-file-mac-key").update(passphrase).digest()
    ).update(macData).digest("hex");
    if (calcMAC !== mac) {
      if (encrypted) {
        return new Error(
          "PPK private key integrity check failed -- bad passphrase?"
        );
      }
      return new Error("PPK private key integrity check failed");
    }
    let pubPEM;
    let pubSSH;
    let privPEM;
    pubBlob._pos = 0;
    skipFields(pubBlob, 1);
    switch (type2) {
      case "ssh-rsa": {
        const e = readString(pubBlob, pubBlob._pos);
        if (e === void 0)
          return new Error("Malformed PPK public key");
        const n = readString(pubBlob, pubBlob._pos);
        if (n === void 0)
          return new Error("Malformed PPK public key");
        const d = readString(privBlob, 0);
        if (d === void 0)
          return new Error("Malformed PPK private key");
        const p2 = readString(privBlob, privBlob._pos);
        if (p2 === void 0)
          return new Error("Malformed PPK private key");
        const q = readString(privBlob, privBlob._pos);
        if (q === void 0)
          return new Error("Malformed PPK private key");
        const iqmp = readString(privBlob, privBlob._pos);
        if (iqmp === void 0)
          return new Error("Malformed PPK private key");
        pubPEM = genOpenSSLRSAPub(n, e);
        pubSSH = genOpenSSHRSAPub(n, e);
        privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p2, q);
        break;
      }
      case "ssh-dss": {
        const p2 = readString(pubBlob, pubBlob._pos);
        if (p2 === void 0)
          return new Error("Malformed PPK public key");
        const q = readString(pubBlob, pubBlob._pos);
        if (q === void 0)
          return new Error("Malformed PPK public key");
        const g = readString(pubBlob, pubBlob._pos);
        if (g === void 0)
          return new Error("Malformed PPK public key");
        const y = readString(pubBlob, pubBlob._pos);
        if (y === void 0)
          return new Error("Malformed PPK public key");
        const x = readString(privBlob, 0);
        if (x === void 0)
          return new Error("Malformed PPK private key");
        pubPEM = genOpenSSLDSAPub(p2, q, g, y);
        pubSSH = genOpenSSHDSAPub(p2, q, g, y);
        privPEM = genOpenSSLDSAPriv(p2, q, g, y, x);
        break;
      }
    }
    return new PPK_Private(
      type2,
      comment,
      privPEM,
      pubPEM,
      pubSSH,
      "sha1",
      encrypted
    );
  };
}
function OpenSSH_Public(type2, comment, pubPEM, pubSSH, algo) {
  this.type = type2;
  this.comment = comment;
  this[SYM_PRIV_PEM] = null;
  this[SYM_PUB_PEM] = pubPEM;
  this[SYM_PUB_SSH] = pubSSH;
  this[SYM_HASH_ALGO] = algo;
  this[SYM_DECRYPTED] = false;
}
OpenSSH_Public.prototype = BaseKey;
{
  let regexp;
  if (eddsaSupported$1)
    regexp = /^(((?:ssh-(?:rsa|dss|ed25519))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\s+([\S].*)?)$/;
  else
    regexp = /^(((?:ssh-(?:rsa|dss))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\s+([\S].*)?)$/;
  OpenSSH_Public.parse = (str) => {
    const m = regexp.exec(str);
    if (m === null)
      return null;
    const fullType = m[1];
    const baseType = m[2];
    const data = Buffer.from(m[3], "base64");
    const comment = m[4] || "";
    const type2 = readString(data, data._pos, true);
    if (type2 === void 0 || type2.indexOf(baseType) !== 0)
      return new Error("Malformed OpenSSH public key");
    return parseDER(data, baseType, comment, fullType);
  };
}
function RFC4716_Public(type2, comment, pubPEM, pubSSH, algo) {
  this.type = type2;
  this.comment = comment;
  this[SYM_PRIV_PEM] = null;
  this[SYM_PUB_PEM] = pubPEM;
  this[SYM_PUB_SSH] = pubSSH;
  this[SYM_HASH_ALGO] = algo;
  this[SYM_DECRYPTED] = false;
}
RFC4716_Public.prototype = BaseKey;
{
  const regexp = /^---- BEGIN SSH2 PUBLIC KEY ----(?:\r?\n)((?:.{0,72}\r?\n)+)---- END SSH2 PUBLIC KEY ----$/;
  const RE_DATA = /^[A-Z0-9a-z/+=\r\n]+$/;
  const RE_HEADER = /^([\x21-\x39\x3B-\x7E]{1,64}): ((?:[^\\]*\\\r?\n)*[^\r\n]+)\r?\n/gm;
  const RE_HEADER_ENDS = /\\\r?\n/g;
  RFC4716_Public.parse = (str) => {
    let m = regexp.exec(str);
    if (m === null)
      return null;
    const body = m[1];
    let dataStart = 0;
    let comment = "";
    while (m = RE_HEADER.exec(body)) {
      const headerName = m[1];
      const headerValue = m[2].replace(RE_HEADER_ENDS, "");
      if (headerValue.length > 1024) {
        RE_HEADER.lastIndex = 0;
        return new Error("Malformed RFC4716 public key");
      }
      dataStart = RE_HEADER.lastIndex;
      if (headerName.toLowerCase() === "comment") {
        comment = headerValue;
        if (comment.length > 1 && comment.charCodeAt(0) === 34 && comment.charCodeAt(comment.length - 1) === 34) {
          comment = comment.slice(1, -1);
        }
      }
    }
    let data = body.slice(dataStart);
    if (!RE_DATA.test(data))
      return new Error("Malformed RFC4716 public key");
    data = Buffer.from(data, "base64");
    const type2 = readString(data, 0, true);
    if (type2 === void 0)
      return new Error("Malformed RFC4716 public key");
    let pubPEM = null;
    let pubSSH = null;
    switch (type2) {
      case "ssh-rsa": {
        const e = readString(data, data._pos);
        if (e === void 0)
          return new Error("Malformed RFC4716 public key");
        const n = readString(data, data._pos);
        if (n === void 0)
          return new Error("Malformed RFC4716 public key");
        pubPEM = genOpenSSLRSAPub(n, e);
        pubSSH = genOpenSSHRSAPub(n, e);
        break;
      }
      case "ssh-dss": {
        const p = readString(data, data._pos);
        if (p === void 0)
          return new Error("Malformed RFC4716 public key");
        const q = readString(data, data._pos);
        if (q === void 0)
          return new Error("Malformed RFC4716 public key");
        const g = readString(data, data._pos);
        if (g === void 0)
          return new Error("Malformed RFC4716 public key");
        const y = readString(data, data._pos);
        if (y === void 0)
          return new Error("Malformed RFC4716 public key");
        pubPEM = genOpenSSLDSAPub(p, q, g, y);
        pubSSH = genOpenSSHDSAPub(p, q, g, y);
        break;
      }
      default:
        return new Error("Malformed RFC4716 public key");
    }
    return new RFC4716_Public(type2, comment, pubPEM, pubSSH, "sha1");
  };
}
function parseDER(data, baseType, comment, fullType) {
  if (!isSupportedKeyType(baseType))
    return new Error(`Unsupported OpenSSH public key type: ${baseType}`);
  let algo;
  let oid;
  let pubPEM = null;
  let pubSSH = null;
  switch (baseType) {
    case "ssh-rsa": {
      const e = readString(data, data._pos || 0);
      if (e === void 0)
        return new Error("Malformed OpenSSH public key");
      const n = readString(data, data._pos);
      if (n === void 0)
        return new Error("Malformed OpenSSH public key");
      pubPEM = genOpenSSLRSAPub(n, e);
      pubSSH = genOpenSSHRSAPub(n, e);
      algo = "sha1";
      break;
    }
    case "ssh-dss": {
      const p = readString(data, data._pos || 0);
      if (p === void 0)
        return new Error("Malformed OpenSSH public key");
      const q = readString(data, data._pos);
      if (q === void 0)
        return new Error("Malformed OpenSSH public key");
      const g = readString(data, data._pos);
      if (g === void 0)
        return new Error("Malformed OpenSSH public key");
      const y = readString(data, data._pos);
      if (y === void 0)
        return new Error("Malformed OpenSSH public key");
      pubPEM = genOpenSSLDSAPub(p, q, g, y);
      pubSSH = genOpenSSHDSAPub(p, q, g, y);
      algo = "sha1";
      break;
    }
    case "ssh-ed25519": {
      const edpub = readString(data, data._pos || 0);
      if (edpub === void 0 || edpub.length !== 32)
        return new Error("Malformed OpenSSH public key");
      pubPEM = genOpenSSLEdPub(edpub);
      pubSSH = genOpenSSHEdPub(edpub);
      algo = null;
      break;
    }
    case "ecdsa-sha2-nistp256":
      algo = "sha256";
      oid = "1.2.840.10045.3.1.7";
    case "ecdsa-sha2-nistp384":
      if (algo === void 0) {
        algo = "sha384";
        oid = "1.3.132.0.34";
      }
    case "ecdsa-sha2-nistp521": {
      if (algo === void 0) {
        algo = "sha512";
        oid = "1.3.132.0.35";
      }
      if (!skipFields(data, 1))
        return new Error("Malformed OpenSSH public key");
      const ecpub = readString(data, data._pos || 0);
      if (ecpub === void 0)
        return new Error("Malformed OpenSSH public key");
      pubPEM = genOpenSSLECDSAPub(oid, ecpub);
      pubSSH = genOpenSSHECDSAPub(oid, ecpub);
      break;
    }
    default:
      return new Error(`Unsupported OpenSSH public key type: ${baseType}`);
  }
  return new OpenSSH_Public(fullType, comment, pubPEM, pubSSH, algo);
}
function isSupportedKeyType(type2) {
  switch (type2) {
    case "ssh-rsa":
    case "ssh-dss":
    case "ecdsa-sha2-nistp256":
    case "ecdsa-sha2-nistp384":
    case "ecdsa-sha2-nistp521":
      return true;
    case "ssh-ed25519":
      if (eddsaSupported$1)
        return true;
    default:
      return false;
  }
}
function isParsedKey$1(val) {
  if (!val)
    return false;
  return typeof val[SYM_DECRYPTED] === "boolean";
}
function parseKey$6(data, passphrase) {
  if (isParsedKey$1(data))
    return data;
  let origBuffer;
  if (Buffer.isBuffer(data)) {
    origBuffer = data;
    data = data.utf8Slice(0, data.length).trim();
  } else if (typeof data === "string") {
    data = data.trim();
  } else {
    return new Error("Key data must be a Buffer or string");
  }
  if (passphrase != void 0) {
    if (typeof passphrase === "string")
      passphrase = Buffer.from(passphrase);
    else if (!Buffer.isBuffer(passphrase))
      return new Error("Passphrase must be a string or Buffer when supplied");
  }
  let ret;
  if ((ret = OpenSSH_Private.parse(data, passphrase)) !== null)
    return ret;
  if ((ret = OpenSSH_Old_Private.parse(data, passphrase)) !== null)
    return ret;
  if ((ret = PPK_Private.parse(data, passphrase)) !== null)
    return ret;
  if ((ret = OpenSSH_Public.parse(data)) !== null)
    return ret;
  if ((ret = RFC4716_Public.parse(data)) !== null)
    return ret;
  if (origBuffer) {
    binaryKeyParser.init(origBuffer, 0);
    const type2 = binaryKeyParser.readString(true);
    if (type2 !== void 0) {
      data = binaryKeyParser.readRaw();
      if (data !== void 0) {
        ret = parseDER(data, type2, "", type2);
        if (ret instanceof Error)
          ret = null;
      }
    }
    binaryKeyParser.clear();
  }
  if (ret)
    return ret;
  return new Error("Unsupported key format");
}
var keyParser = {
  isParsedKey: isParsedKey$1,
  parseDERKey: (data, type2) => parseDER(data, type2, "", type2),
  parseKey: parseKey$6
};
const { Socket: Socket$1 } = require$$0$5;
const { Duplex } = require$$1$3;
const { resolve } = require$$0;
const { readFile } = require$$1;
const { execFile, spawn } = require$$4;
const { isParsedKey, parseKey: parseKey$5 } = keyParser;
const {
  makeBufferParser: makeBufferParser$2,
  readUInt32BE: readUInt32BE$1,
  writeUInt32BE: writeUInt32BE$5,
  writeUInt32LE
} = requireUtils();
function once(cb) {
  let called = false;
  return (...args) => {
    if (called)
      return;
    called = true;
    cb(...args);
  };
}
function concat(buf1, buf2) {
  const combined = Buffer.allocUnsafe(buf1.length + buf2.length);
  buf1.copy(combined, 0);
  buf2.copy(combined, buf1.length);
  return combined;
}
function noop$4() {
}
const EMPTY_BUF = Buffer.alloc(0);
const binaryParser = makeBufferParser$2();
let BaseAgent$1 = class BaseAgent {
  getIdentities(cb) {
    cb(new Error("Missing getIdentities() implementation"));
  }
  sign(pubKey, data, options, cb) {
    if (typeof options === "function")
      cb = options;
    cb(new Error("Missing sign() implementation"));
  }
};
let OpenSSHAgent$1 = class OpenSSHAgent extends BaseAgent$1 {
  constructor(socketPath) {
    super();
    this.socketPath = socketPath;
  }
  getStream(cb) {
    cb = once(cb);
    const sock = new Socket$1();
    sock.on("connect", () => {
      cb(null, sock);
    });
    sock.on("close", onFail).on("end", onFail).on("error", onFail);
    sock.connect(this.socketPath);
    function onFail() {
      try {
        sock.destroy();
      } catch {
      }
      cb(new Error("Failed to connect to agent"));
    }
  }
  getIdentities(cb) {
    cb = once(cb);
    this.getStream((err, stream) => {
      function onFail(err2) {
        if (stream) {
          try {
            stream.destroy();
          } catch {
          }
        }
        if (!err2)
          err2 = new Error("Failed to retrieve identities from agent");
        cb(err2);
      }
      if (err)
        return onFail(err);
      const protocol = new AgentProtocol$1(true);
      protocol.on("error", onFail);
      protocol.pipe(stream).pipe(protocol);
      stream.on("close", onFail).on("end", onFail).on("error", onFail);
      protocol.getIdentities((err2, keys) => {
        if (err2)
          return onFail(err2);
        try {
          stream.destroy();
        } catch {
        }
        cb(null, keys);
      });
    });
  }
  sign(pubKey, data, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = void 0;
    } else if (typeof options !== "object" || options === null) {
      options = void 0;
    }
    cb = once(cb);
    this.getStream((err, stream) => {
      function onFail(err2) {
        if (stream) {
          try {
            stream.destroy();
          } catch {
          }
        }
        if (!err2)
          err2 = new Error("Failed to sign data with agent");
        cb(err2);
      }
      if (err)
        return onFail(err);
      const protocol = new AgentProtocol$1(true);
      protocol.on("error", onFail);
      protocol.pipe(stream).pipe(protocol);
      stream.on("close", onFail).on("end", onFail).on("error", onFail);
      protocol.sign(pubKey, data, options, (err2, sig) => {
        if (err2)
          return onFail(err2);
        try {
          stream.destroy();
        } catch {
        }
        cb(null, sig);
      });
    });
  }
};
const PageantAgent$1 = (() => {
  const RET_ERR_BADARGS = 10;
  const RET_ERR_UNAVAILABLE = 11;
  const RET_ERR_NOMAP = 12;
  const RET_ERR_BINSTDIN = 13;
  const RET_ERR_BINSTDOUT = 14;
  const RET_ERR_BADLEN = 15;
  const EXEPATH = resolve(__dirname, "..", "util/pagent.exe");
  const ERROR = {
    [RET_ERR_BADARGS]: new Error("Invalid pagent.exe arguments"),
    [RET_ERR_UNAVAILABLE]: new Error("Pageant is not running"),
    [RET_ERR_NOMAP]: new Error("pagent.exe could not create an mmap"),
    [RET_ERR_BINSTDIN]: new Error("pagent.exe could not set mode for stdin"),
    [RET_ERR_BINSTDOUT]: new Error("pagent.exe could not set mode for stdout"),
    [RET_ERR_BADLEN]: new Error("pagent.exe did not get expected input payload")
  };
  function destroy(stream) {
    stream.buffer = null;
    if (stream.proc) {
      stream.proc.kill();
      stream.proc = void 0;
    }
  }
  class PageantSocket extends Duplex {
    constructor() {
      super();
      this.proc = void 0;
      this.buffer = null;
    }
    _read(n) {
    }
    _write(data, encoding, cb) {
      if (this.buffer === null) {
        this.buffer = data;
      } else {
        const newBuffer = Buffer.allocUnsafe(this.buffer.length + data.length);
        this.buffer.copy(newBuffer, 0);
        data.copy(newBuffer, this.buffer.length);
        this.buffer = newBuffer;
      }
      if (this.buffer.length < 4)
        return cb();
      const len = readUInt32BE$1(this.buffer, 0);
      if (this.buffer.length - 4 < len)
        return cb();
      data = this.buffer.slice(0, 4 + len);
      if (this.buffer.length > 4 + len)
        return cb(new Error("Unexpected multiple agent requests"));
      this.buffer = null;
      let error2;
      const proc = this.proc = spawn(EXEPATH, [data.length]);
      proc.stdout.on("data", (data2) => {
        this.push(data2);
      });
      proc.on("error", (err) => {
        error2 = err;
        cb(error2);
      });
      proc.on("close", (code2) => {
        this.proc = void 0;
        if (!error2) {
          if (error2 = ERROR[code2])
            return cb(error2);
          cb();
        }
      });
      proc.stdin.end(data);
    }
    _final(cb) {
      destroy(this);
      cb();
    }
    _destroy(err, cb) {
      destroy(this);
      cb();
    }
  }
  return class PageantAgent extends OpenSSHAgent$1 {
    getStream(cb) {
      cb(null, new PageantSocket());
    }
  };
})();
const CygwinAgent$1 = /* @__PURE__ */ (() => {
  const RE_CYGWIN_SOCK = /^!<socket >(\d+) s ([A-Z0-9]{8}-[A-Z0-9]{8}-[A-Z0-9]{8}-[A-Z0-9]{8})/;
  return class CygwinAgent extends OpenSSHAgent$1 {
    getStream(cb) {
      cb = once(cb);
      let socketPath = this.socketPath;
      let triedCygpath = false;
      readFile(socketPath, function readCygsocket(err, data) {
        if (err) {
          if (triedCygpath)
            return cb(new Error("Invalid cygwin unix socket path"));
          execFile("cygpath", ["-w", socketPath], (err2, stdout, stderr) => {
            if (err2 || stdout.length === 0)
              return cb(new Error("Invalid cygwin unix socket path"));
            triedCygpath = true;
            socketPath = stdout.toString().replace(/[\r\n]/g, "");
            readFile(socketPath, readCygsocket);
          });
          return;
        }
        const m = RE_CYGWIN_SOCK.exec(data.toString("ascii"));
        if (!m)
          return cb(new Error("Malformed cygwin unix socket file"));
        let state;
        let bc = 0;
        let isRetrying = false;
        const inBuf = [];
        let sock;
        let credsBuf = Buffer.alloc(12);
        const port = parseInt(m[1], 10);
        const secret = m[2].replace(/-/g, "");
        const secretBuf = Buffer.allocUnsafe(16);
        for (let i = 0, j = 0; j < 32; ++i, j += 2)
          secretBuf[i] = parseInt(secret.substring(j, j + 2), 16);
        for (let i = 0; i < 16; i += 4)
          writeUInt32LE(secretBuf, readUInt32BE$1(secretBuf, i), i);
        tryConnect();
        function _onconnect() {
          bc = 0;
          state = "secret";
          sock.write(secretBuf);
        }
        function _ondata(data2) {
          bc += data2.length;
          if (state === "secret") {
            if (bc === 16) {
              bc = 0;
              state = "creds";
              sock.write(credsBuf);
            }
            return;
          }
          if (state === "creds") {
            if (!isRetrying)
              inBuf.push(data2);
            if (bc === 12) {
              sock.removeListener("connect", _onconnect);
              sock.removeListener("data", _ondata);
              sock.removeListener("error", onFail);
              sock.removeListener("end", onFail);
              sock.removeListener("close", onFail);
              if (isRetrying)
                return cb(null, sock);
              isRetrying = true;
              credsBuf = Buffer.concat(inBuf);
              writeUInt32LE(credsBuf, process.pid, 0);
              sock.on("error", () => {
              });
              sock.destroy();
              tryConnect();
            }
          }
        }
        function onFail() {
          cb(new Error("Problem negotiating cygwin unix socket security"));
        }
        function tryConnect() {
          sock = new Socket$1();
          sock.on("connect", _onconnect);
          sock.on("data", _ondata);
          sock.on("error", onFail);
          sock.on("end", onFail);
          sock.on("close", onFail);
          sock.connect(port);
        }
      });
    }
  };
})();
const WINDOWS_PIPE_REGEX = /^[/\\][/\\]\.[/\\]pipe[/\\].+/;
function createAgent$2(path2) {
  if (process.platform === "win32" && !WINDOWS_PIPE_REGEX.test(path2)) {
    return path2 === "pageant" ? new PageantAgent$1() : new CygwinAgent$1(path2);
  }
  return new OpenSSHAgent$1(path2);
}
const AgentProtocol$1 = (() => {
  const SSH_AGENTC_REQUEST_IDENTITIES = 11;
  const SSH_AGENTC_SIGN_REQUEST = 13;
  const SSH_AGENT_FAILURE = 5;
  const SSH_AGENT_IDENTITIES_ANSWER = 12;
  const SSH_AGENT_SIGN_RESPONSE = 14;
  const SSH_AGENT_RSA_SHA2_256 = 1 << 1;
  const SSH_AGENT_RSA_SHA2_512 = 1 << 2;
  const ROLE_CLIENT = 0;
  const ROLE_SERVER = 1;
  function processResponses(protocol) {
    let ret;
    while (protocol[SYM_REQS].length) {
      const nextResponse = protocol[SYM_REQS][0][SYM_RESP];
      if (nextResponse === void 0)
        break;
      protocol[SYM_REQS].shift();
      ret = protocol.push(nextResponse);
    }
    return ret;
  }
  const SYM_TYPE = Symbol("Inbound Request Type");
  const SYM_RESP = Symbol("Inbound Request Response");
  const SYM_CTX = Symbol("Inbound Request Context");
  class AgentInboundRequest {
    constructor(type2, ctx) {
      this[SYM_TYPE] = type2;
      this[SYM_RESP] = void 0;
      this[SYM_CTX] = ctx;
    }
    hasResponded() {
      return this[SYM_RESP] !== void 0;
    }
    getType() {
      return this[SYM_TYPE];
    }
    getContext() {
      return this[SYM_CTX];
    }
  }
  function respond(protocol, req, data) {
    req[SYM_RESP] = data;
    return processResponses(protocol);
  }
  function cleanup(protocol) {
    protocol[SYM_BUFFER] = null;
    if (protocol[SYM_MODE] === ROLE_CLIENT) {
      const reqs = protocol[SYM_REQS];
      if (reqs && reqs.length) {
        protocol[SYM_REQS] = [];
        for (const req of reqs)
          req.cb(new Error("No reply from server"));
      }
    }
    try {
      protocol.end();
    } catch {
    }
    setImmediate(() => {
      if (!protocol[SYM_ENDED])
        protocol.emit("end");
      if (!protocol[SYM_CLOSED])
        protocol.emit("close");
    });
  }
  function onClose() {
    this[SYM_CLOSED] = true;
  }
  function onEnd2() {
    this[SYM_ENDED] = true;
  }
  const SYM_REQS = Symbol("Requests");
  const SYM_MODE = Symbol("Agent Protocol Role");
  const SYM_BUFFER = Symbol("Agent Protocol Buffer");
  const SYM_MSGLEN = Symbol("Agent Protocol Current Message Length");
  const SYM_CLOSED = Symbol("Agent Protocol Closed");
  const SYM_ENDED = Symbol("Agent Protocol Ended");
  return class AgentProtocol extends Duplex {
    /*
        Notes:
          - `constraint` type consists of:
               byte                    constraint_type
               byte[]                  constraint_data
            where `constraint_type` is one of:
              * SSH_AGENT_CONSTRAIN_LIFETIME
                - `constraint_data` consists of:
                     uint32                  seconds
              * SSH_AGENT_CONSTRAIN_CONFIRM
                - `constraint_data` N/A
              * SSH_AGENT_CONSTRAIN_EXTENSION
                - `constraint_data` consists of:
                     string                  extension name
                     byte[]                  extension-specific details
    */
    constructor(isClient) {
      super({ autoDestroy: true, emitClose: false });
      this[SYM_MODE] = isClient ? ROLE_CLIENT : ROLE_SERVER;
      this[SYM_REQS] = [];
      this[SYM_BUFFER] = null;
      this[SYM_MSGLEN] = -1;
      this.once("end", onEnd2);
      this.once("close", onClose);
    }
    _read(n) {
    }
    _write(data, encoding, cb) {
      if (this[SYM_BUFFER] === null)
        this[SYM_BUFFER] = data;
      else
        this[SYM_BUFFER] = concat(this[SYM_BUFFER], data);
      let buffer2 = this[SYM_BUFFER];
      let bufferLen = buffer2.length;
      let p = 0;
      while (p < bufferLen) {
        if (bufferLen < 5)
          break;
        if (this[SYM_MSGLEN] === -1)
          this[SYM_MSGLEN] = readUInt32BE$1(buffer2, p);
        if (bufferLen < 4 + this[SYM_MSGLEN])
          break;
        const msgType = buffer2[p += 4];
        ++p;
        if (this[SYM_MODE] === ROLE_CLIENT) {
          if (this[SYM_REQS].length === 0)
            return cb(new Error("Received unexpected message from server"));
          const req = this[SYM_REQS].shift();
          switch (msgType) {
            case SSH_AGENT_FAILURE:
              req.cb(new Error("Agent responded with failure"));
              break;
            case SSH_AGENT_IDENTITIES_ANSWER: {
              if (req.type !== SSH_AGENTC_REQUEST_IDENTITIES)
                return cb(new Error("Agent responded with wrong message type"));
              binaryParser.init(buffer2, p);
              const numKeys = binaryParser.readUInt32BE();
              if (numKeys === void 0) {
                binaryParser.clear();
                return cb(new Error("Malformed agent response"));
              }
              const keys = [];
              for (let i = 0; i < numKeys; ++i) {
                let pubKey = binaryParser.readString();
                if (pubKey === void 0) {
                  binaryParser.clear();
                  return cb(new Error("Malformed agent response"));
                }
                const comment = binaryParser.readString(true);
                if (comment === void 0) {
                  binaryParser.clear();
                  return cb(new Error("Malformed agent response"));
                }
                pubKey = parseKey$5(pubKey);
                if (pubKey instanceof Error)
                  continue;
                pubKey.comment = pubKey.comment || comment;
                keys.push(pubKey);
              }
              p = binaryParser.pos();
              binaryParser.clear();
              req.cb(null, keys);
              break;
            }
            case SSH_AGENT_SIGN_RESPONSE: {
              if (req.type !== SSH_AGENTC_SIGN_REQUEST)
                return cb(new Error("Agent responded with wrong message type"));
              binaryParser.init(buffer2, p);
              let signature = binaryParser.readString();
              p = binaryParser.pos();
              binaryParser.clear();
              if (signature === void 0)
                return cb(new Error("Malformed agent response"));
              binaryParser.init(signature, 0);
              binaryParser.readString(true);
              signature = binaryParser.readString();
              binaryParser.clear();
              if (signature === void 0)
                return cb(new Error("Malformed OpenSSH signature format"));
              req.cb(null, signature);
              break;
            }
            default:
              return cb(
                new Error("Agent responded with unsupported message type")
              );
          }
        } else {
          switch (msgType) {
            case SSH_AGENTC_REQUEST_IDENTITIES: {
              const req = new AgentInboundRequest(msgType);
              this[SYM_REQS].push(req);
              this.emit("identities", req);
              break;
            }
            case SSH_AGENTC_SIGN_REQUEST: {
              binaryParser.init(buffer2, p);
              let pubKey = binaryParser.readString();
              const data2 = binaryParser.readString();
              const flagsVal = binaryParser.readUInt32BE();
              p = binaryParser.pos();
              binaryParser.clear();
              if (flagsVal === void 0) {
                const req2 = new AgentInboundRequest(msgType);
                this[SYM_REQS].push(req2);
                return this.failureReply(req2);
              }
              pubKey = parseKey$5(pubKey);
              if (pubKey instanceof Error) {
                const req2 = new AgentInboundRequest(msgType);
                this[SYM_REQS].push(req2);
                return this.failureReply(req2);
              }
              const flags = {
                hash: void 0
              };
              let ctx;
              if (pubKey.type === "ssh-rsa") {
                if (flagsVal & SSH_AGENT_RSA_SHA2_256) {
                  ctx = "rsa-sha2-256";
                  flags.hash = "sha256";
                } else if (flagsVal & SSH_AGENT_RSA_SHA2_512) {
                  ctx = "rsa-sha2-512";
                  flags.hash = "sha512";
                }
              }
              if (ctx === void 0)
                ctx = pubKey.type;
              const req = new AgentInboundRequest(msgType, ctx);
              this[SYM_REQS].push(req);
              this.emit("sign", req, pubKey, data2, flags);
              break;
            }
            default: {
              const req = new AgentInboundRequest(msgType);
              this[SYM_REQS].push(req);
              this.failureReply(req);
            }
          }
        }
        this[SYM_MSGLEN] = -1;
        if (p === bufferLen) {
          this[SYM_BUFFER] = null;
          break;
        } else {
          this[SYM_BUFFER] = buffer2 = buffer2.slice(p);
          bufferLen = buffer2.length;
          p = 0;
        }
      }
      cb();
    }
    _destroy(err, cb) {
      cleanup(this);
      cb();
    }
    _final(cb) {
      cleanup(this);
      cb();
    }
    // Client->Server messages =================================================
    sign(pubKey, data, options, cb) {
      if (this[SYM_MODE] !== ROLE_CLIENT)
        throw new Error("Client-only method called with server role");
      if (typeof options === "function") {
        cb = options;
        options = void 0;
      } else if (typeof options !== "object" || options === null) {
        options = void 0;
      }
      let flags = 0;
      pubKey = parseKey$5(pubKey);
      if (pubKey instanceof Error)
        throw new Error("Invalid public key argument");
      if (pubKey.type === "ssh-rsa" && options) {
        switch (options.hash) {
          case "sha256":
            flags = SSH_AGENT_RSA_SHA2_256;
            break;
          case "sha512":
            flags = SSH_AGENT_RSA_SHA2_512;
            break;
        }
      }
      pubKey = pubKey.getPublicSSH();
      const type2 = SSH_AGENTC_SIGN_REQUEST;
      const keyLen = pubKey.length;
      const dataLen = data.length;
      let p = 0;
      const buf = Buffer.allocUnsafe(4 + 1 + 4 + keyLen + 4 + dataLen + 4);
      writeUInt32BE$5(buf, buf.length - 4, p);
      buf[p += 4] = type2;
      writeUInt32BE$5(buf, keyLen, ++p);
      pubKey.copy(buf, p += 4);
      writeUInt32BE$5(buf, dataLen, p += keyLen);
      data.copy(buf, p += 4);
      writeUInt32BE$5(buf, flags, p += dataLen);
      if (typeof cb !== "function")
        cb = noop$4;
      this[SYM_REQS].push({ type: type2, cb });
      return this.push(buf);
    }
    getIdentities(cb) {
      if (this[SYM_MODE] !== ROLE_CLIENT)
        throw new Error("Client-only method called with server role");
      const type2 = SSH_AGENTC_REQUEST_IDENTITIES;
      let p = 0;
      const buf = Buffer.allocUnsafe(4 + 1);
      writeUInt32BE$5(buf, buf.length - 4, p);
      buf[p += 4] = type2;
      if (typeof cb !== "function")
        cb = noop$4;
      this[SYM_REQS].push({ type: type2, cb });
      return this.push(buf);
    }
    // Server->Client messages =================================================
    failureReply(req) {
      if (this[SYM_MODE] !== ROLE_SERVER)
        throw new Error("Server-only method called with client role");
      if (!(req instanceof AgentInboundRequest))
        throw new Error("Wrong request argument");
      if (req.hasResponded())
        return true;
      let p = 0;
      const buf = Buffer.allocUnsafe(4 + 1);
      writeUInt32BE$5(buf, buf.length - 4, p);
      buf[p += 4] = SSH_AGENT_FAILURE;
      return respond(this, req, buf);
    }
    getIdentitiesReply(req, keys) {
      if (this[SYM_MODE] !== ROLE_SERVER)
        throw new Error("Server-only method called with client role");
      if (!(req instanceof AgentInboundRequest))
        throw new Error("Wrong request argument");
      if (req.hasResponded())
        return true;
      if (req.getType() !== SSH_AGENTC_REQUEST_IDENTITIES)
        throw new Error("Invalid response to request");
      if (!Array.isArray(keys))
        throw new Error("Keys argument must be an array");
      let totalKeysLen = 4;
      const newKeys = [];
      for (let i = 0; i < keys.length; ++i) {
        const entry = keys[i];
        if (typeof entry !== "object" || entry === null)
          throw new Error(`Invalid key entry: ${entry}`);
        let pubKey;
        let comment;
        if (isParsedKey(entry)) {
          pubKey = entry;
        } else if (isParsedKey(entry.pubKey)) {
          pubKey = entry.pubKey;
        } else {
          if (typeof entry.pubKey !== "object" || entry.pubKey === null)
            continue;
          ({ pubKey, comment } = entry.pubKey);
          pubKey = parseKey$5(pubKey);
          if (pubKey instanceof Error)
            continue;
        }
        comment = pubKey.comment || comment;
        pubKey = pubKey.getPublicSSH();
        totalKeysLen += 4 + pubKey.length;
        if (comment && typeof comment === "string")
          comment = Buffer.from(comment);
        else if (!Buffer.isBuffer(comment))
          comment = EMPTY_BUF;
        totalKeysLen += 4 + comment.length;
        newKeys.push({ pubKey, comment });
      }
      let p = 0;
      const buf = Buffer.allocUnsafe(4 + 1 + totalKeysLen);
      writeUInt32BE$5(buf, buf.length - 4, p);
      buf[p += 4] = SSH_AGENT_IDENTITIES_ANSWER;
      writeUInt32BE$5(buf, newKeys.length, ++p);
      p += 4;
      for (let i = 0; i < newKeys.length; ++i) {
        const { pubKey, comment } = newKeys[i];
        writeUInt32BE$5(buf, pubKey.length, p);
        pubKey.copy(buf, p += 4);
        writeUInt32BE$5(buf, comment.length, p += pubKey.length);
        p += 4;
        if (comment.length) {
          comment.copy(buf, p);
          p += comment.length;
        }
      }
      return respond(this, req, buf);
    }
    signReply(req, signature) {
      if (this[SYM_MODE] !== ROLE_SERVER)
        throw new Error("Server-only method called with client role");
      if (!(req instanceof AgentInboundRequest))
        throw new Error("Wrong request argument");
      if (req.hasResponded())
        return true;
      if (req.getType() !== SSH_AGENTC_SIGN_REQUEST)
        throw new Error("Invalid response to request");
      if (!Buffer.isBuffer(signature))
        throw new Error("Signature argument must be a Buffer");
      if (signature.length === 0)
        throw new Error("Signature argument must be non-empty");
      let p = 0;
      const sigFormat = req.getContext();
      const sigFormatLen = Buffer.byteLength(sigFormat);
      const buf = Buffer.allocUnsafe(
        4 + 1 + 4 + 4 + sigFormatLen + 4 + signature.length
      );
      writeUInt32BE$5(buf, buf.length - 4, p);
      buf[p += 4] = SSH_AGENT_SIGN_RESPONSE;
      writeUInt32BE$5(buf, 4 + sigFormatLen + 4 + signature.length, ++p);
      writeUInt32BE$5(buf, sigFormatLen, p += 4);
      buf.utf8Write(sigFormat, p += 4, sigFormatLen);
      writeUInt32BE$5(buf, signature.length, p += sigFormatLen);
      signature.copy(buf, p += 4);
      return respond(this, req, buf);
    }
  };
})();
const SYM_AGENT = Symbol("Agent");
const SYM_AGENT_KEYS = Symbol("Agent Keys");
const SYM_AGENT_KEYS_IDX = Symbol("Agent Keys Index");
const SYM_AGENT_CBS = Symbol("Agent Init Callbacks");
let AgentContext$1 = class AgentContext {
  constructor(agent2) {
    if (typeof agent2 === "string")
      agent2 = createAgent$2(agent2);
    else if (!isAgent$1(agent2))
      throw new Error("Invalid agent argument");
    this[SYM_AGENT] = agent2;
    this[SYM_AGENT_KEYS] = null;
    this[SYM_AGENT_KEYS_IDX] = -1;
    this[SYM_AGENT_CBS] = null;
  }
  init(cb) {
    if (typeof cb !== "function")
      cb = noop$4;
    if (this[SYM_AGENT_KEYS] === null) {
      if (this[SYM_AGENT_CBS] === null) {
        this[SYM_AGENT_CBS] = [cb];
        const doCbs = (...args) => {
          process.nextTick(() => {
            const cbs = this[SYM_AGENT_CBS];
            this[SYM_AGENT_CBS] = null;
            for (const cb2 of cbs)
              cb2(...args);
          });
        };
        this[SYM_AGENT].getIdentities(once((err, keys) => {
          if (err)
            return doCbs(err);
          if (!Array.isArray(keys)) {
            return doCbs(new Error(
              "Agent implementation failed to provide keys"
            ));
          }
          const newKeys = [];
          for (let key2 of keys) {
            key2 = parseKey$5(key2);
            if (key2 instanceof Error) {
              continue;
            }
            newKeys.push(key2);
          }
          this[SYM_AGENT_KEYS] = newKeys;
          this[SYM_AGENT_KEYS_IDX] = -1;
          doCbs();
        }));
      } else {
        this[SYM_AGENT_CBS].push(cb);
      }
    } else {
      process.nextTick(cb);
    }
  }
  nextKey() {
    if (this[SYM_AGENT_KEYS] === null || ++this[SYM_AGENT_KEYS_IDX] >= this[SYM_AGENT_KEYS].length) {
      return false;
    }
    return this[SYM_AGENT_KEYS][this[SYM_AGENT_KEYS_IDX]];
  }
  currentKey() {
    if (this[SYM_AGENT_KEYS] === null || this[SYM_AGENT_KEYS_IDX] >= this[SYM_AGENT_KEYS].length) {
      return null;
    }
    return this[SYM_AGENT_KEYS][this[SYM_AGENT_KEYS_IDX]];
  }
  pos() {
    if (this[SYM_AGENT_KEYS] === null || this[SYM_AGENT_KEYS_IDX] >= this[SYM_AGENT_KEYS].length) {
      return -1;
    }
    return this[SYM_AGENT_KEYS_IDX];
  }
  reset() {
    this[SYM_AGENT_KEYS_IDX] = -1;
  }
  sign(...args) {
    this[SYM_AGENT].sign(...args);
  }
};
function isAgent$1(val) {
  return val instanceof BaseAgent$1;
}
var agent = {
  AgentContext: AgentContext$1,
  AgentProtocol: AgentProtocol$1,
  BaseAgent: BaseAgent$1,
  createAgent: createAgent$2,
  CygwinAgent: CygwinAgent$1,
  isAgent: isAgent$1,
  OpenSSHAgent: OpenSSHAgent$1,
  PageantAgent: PageantAgent$1
};
var httpAgents = {};
const { kMaxLength } = require$$0$4;
const {
  createInflate,
  constants: {
    DEFLATE,
    INFLATE,
    Z_DEFAULT_CHUNK,
    Z_DEFAULT_COMPRESSION,
    Z_DEFAULT_MEMLEVEL,
    Z_DEFAULT_STRATEGY,
    Z_DEFAULT_WINDOWBITS,
    Z_PARTIAL_FLUSH
  }
} = require$$1$4;
const ZlibHandle = createInflate()._handle.constructor;
function processCallback() {
  throw new Error("Should not get here");
}
function zlibOnError(message, errno, code2) {
  const self2 = this._owner;
  const error2 = new Error(message);
  error2.errno = errno;
  error2.code = code2;
  self2._err = error2;
}
function _close(engine) {
  if (!engine._handle)
    return;
  engine._handle.close();
  engine._handle = null;
}
class Zlib {
  constructor(mode) {
    const windowBits = Z_DEFAULT_WINDOWBITS;
    const level = Z_DEFAULT_COMPRESSION;
    const memLevel = Z_DEFAULT_MEMLEVEL;
    const strategy = Z_DEFAULT_STRATEGY;
    const dictionary = void 0;
    this._err = void 0;
    this._writeState = new Uint32Array(2);
    this._chunkSize = Z_DEFAULT_CHUNK;
    this._maxOutputLength = kMaxLength;
    this._outBuffer = Buffer.allocUnsafe(this._chunkSize);
    this._outOffset = 0;
    this._handle = new ZlibHandle(mode);
    this._handle._owner = this;
    this._handle.onerror = zlibOnError;
    this._handle.init(
      windowBits,
      level,
      memLevel,
      strategy,
      this._writeState,
      processCallback,
      dictionary
    );
  }
  writeSync(chunk, retChunks) {
    const handle = this._handle;
    if (!handle)
      throw new Error("Invalid Zlib instance");
    let availInBefore = chunk.length;
    let availOutBefore = this._chunkSize - this._outOffset;
    let inOff = 0;
    let availOutAfter;
    let availInAfter;
    let buffers;
    let nread = 0;
    const state = this._writeState;
    let buffer2 = this._outBuffer;
    let offset = this._outOffset;
    const chunkSize = this._chunkSize;
    while (true) {
      handle.writeSync(
        Z_PARTIAL_FLUSH,
        chunk,
        // in
        inOff,
        // in_off
        availInBefore,
        // in_len
        buffer2,
        // out
        offset,
        // out_off
        availOutBefore
      );
      if (this._err)
        throw this._err;
      availOutAfter = state[0];
      availInAfter = state[1];
      const inDelta = availInBefore - availInAfter;
      const have = availOutBefore - availOutAfter;
      if (have > 0) {
        const out = offset === 0 && have === buffer2.length ? buffer2 : buffer2.slice(offset, offset + have);
        offset += have;
        if (!buffers)
          buffers = out;
        else if (buffers.push === void 0)
          buffers = [buffers, out];
        else
          buffers.push(out);
        nread += out.byteLength;
        if (nread > this._maxOutputLength) {
          _close(this);
          throw new Error(
            `Output length exceeded maximum of ${this._maxOutputLength}`
          );
        }
      } else if (have !== 0) {
        throw new Error("have should not go down");
      }
      if (availOutAfter === 0 || offset >= chunkSize) {
        availOutBefore = chunkSize;
        offset = 0;
        buffer2 = Buffer.allocUnsafe(chunkSize);
      }
      if (availOutAfter === 0) {
        inOff += inDelta;
        availInBefore = availInAfter;
      } else {
        break;
      }
    }
    this._outBuffer = buffer2;
    this._outOffset = offset;
    if (nread === 0)
      buffers = Buffer.alloc(0);
    if (retChunks) {
      buffers.totalLen = nread;
      return buffers;
    }
    if (buffers.push === void 0)
      return buffers;
    const output = Buffer.allocUnsafe(nread);
    for (let i = 0, p = 0; i < buffers.length; ++i) {
      const buf = buffers[i];
      output.set(buf, p);
      p += buf.length;
    }
    return output;
  }
}
let ZlibPacketWriter$1 = class ZlibPacketWriter {
  constructor(protocol) {
    this.allocStart = 0;
    this.allocStartKEX = 0;
    this._protocol = protocol;
    this._zlib = new Zlib(DEFLATE);
  }
  cleanup() {
    if (this._zlib)
      _close(this._zlib);
  }
  alloc(payloadSize, force) {
    return Buffer.allocUnsafe(payloadSize);
  }
  finalize(payload, force) {
    if (this._protocol._kexinit === void 0 || force) {
      const output = this._zlib.writeSync(payload, true);
      const packet = this._protocol._cipher.allocPacket(output.totalLen);
      if (output.push === void 0) {
        packet.set(output, 5);
      } else {
        for (let i = 0, p = 5; i < output.length; ++i) {
          const chunk = output[i];
          packet.set(chunk, p);
          p += chunk.length;
        }
      }
      return packet;
    }
    return payload;
  }
};
let PacketWriter$1 = class PacketWriter {
  constructor(protocol) {
    this.allocStart = 5;
    this.allocStartKEX = 5;
    this._protocol = protocol;
  }
  cleanup() {
  }
  alloc(payloadSize, force) {
    if (this._protocol._kexinit === void 0 || force)
      return this._protocol._cipher.allocPacket(payloadSize);
    return Buffer.allocUnsafe(payloadSize);
  }
  finalize(packet, force) {
    return packet;
  }
};
let ZlibPacketReader$1 = class ZlibPacketReader {
  constructor() {
    this._zlib = new Zlib(INFLATE);
  }
  cleanup() {
    if (this._zlib)
      _close(this._zlib);
  }
  read(data) {
    return this._zlib.writeSync(data, false);
  }
};
let PacketReader$1 = class PacketReader {
  cleanup() {
  }
  read(data) {
    return data;
  }
};
var zlib = {
  PacketReader: PacketReader$1,
  PacketWriter: PacketWriter$1,
  ZlibPacketReader: ZlibPacketReader$1,
  ZlibPacketWriter: ZlibPacketWriter$1
};
const {
  bufferSlice: bufferSlice$3,
  bufferParser: bufferParser$2,
  doFatalError,
  sigSSHToASN1: sigSSHToASN1$1,
  writeUInt32BE: writeUInt32BE$4
} = requireUtils();
const {
  CHANNEL_OPEN_FAILURE: CHANNEL_OPEN_FAILURE$2,
  COMPAT: COMPAT$1,
  MESSAGE: MESSAGE$1,
  TERMINAL_MODE: TERMINAL_MODE$1
} = requireConstants();
const {
  parseKey: parseKey$4
} = keyParser;
const TERMINAL_MODE_BY_VALUE = Array.from(Object.entries(TERMINAL_MODE$1)).reduce((obj, [key2, value]) => ({ ...obj, [key2]: value }), {});
var handlers_misc = {
  // Transport layer protocol ==================================================
  [MESSAGE$1.DISCONNECT]: (self2, payload) => {
    bufferParser$2.init(payload, 1);
    const reason = bufferParser$2.readUInt32BE();
    const desc = bufferParser$2.readString(true);
    const lang2 = bufferParser$2.readString();
    bufferParser$2.clear();
    if (lang2 === void 0) {
      return doFatalError(
        self2,
        "Inbound: Malformed DISCONNECT packet"
      );
    }
    self2._debug && self2._debug(
      `Inbound: Received DISCONNECT (${reason}, "${desc}")`
    );
    const handler = self2._handlers.DISCONNECT;
    handler && handler(self2, reason, desc);
  },
  [MESSAGE$1.IGNORE]: (self2, payload) => {
    self2._debug && self2._debug("Inbound: Received IGNORE");
  },
  [MESSAGE$1.UNIMPLEMENTED]: (self2, payload) => {
    bufferParser$2.init(payload, 1);
    const seqno = bufferParser$2.readUInt32BE();
    bufferParser$2.clear();
    if (seqno === void 0) {
      return doFatalError(
        self2,
        "Inbound: Malformed UNIMPLEMENTED packet"
      );
    }
    self2._debug && self2._debug(`Inbound: Received UNIMPLEMENTED (seqno ${seqno})`);
  },
  [MESSAGE$1.DEBUG]: (self2, payload) => {
    bufferParser$2.init(payload, 1);
    const display = bufferParser$2.readBool();
    const msg = bufferParser$2.readString(true);
    const lang2 = bufferParser$2.readString();
    bufferParser$2.clear();
    if (lang2 === void 0) {
      return doFatalError(
        self2,
        "Inbound: Malformed DEBUG packet"
      );
    }
    self2._debug && self2._debug("Inbound: Received DEBUG");
    const handler = self2._handlers.DEBUG;
    handler && handler(self2, display, msg);
  },
  [MESSAGE$1.SERVICE_REQUEST]: (self2, payload) => {
    bufferParser$2.init(payload, 1);
    const name = bufferParser$2.readString(true);
    bufferParser$2.clear();
    if (name === void 0) {
      return doFatalError(
        self2,
        "Inbound: Malformed SERVICE_REQUEST packet"
      );
    }
    self2._debug && self2._debug(`Inbound: Received SERVICE_REQUEST (${name})`);
    const handler = self2._handlers.SERVICE_REQUEST;
    handler && handler(self2, name);
  },
  [MESSAGE$1.SERVICE_ACCEPT]: (self2, payload) => {
    bufferParser$2.init(payload, 1);
    const name = bufferParser$2.readString(true);
    bufferParser$2.clear();
    if (name === void 0) {
      return doFatalError(
        self2,
        "Inbound: Malformed SERVICE_ACCEPT packet"
      );
    }
    self2._debug && self2._debug(`Inbound: Received SERVICE_ACCEPT (${name})`);
    const handler = self2._handlers.SERVICE_ACCEPT;
    handler && handler(self2, name);
  },
  [MESSAGE$1.EXT_INFO]: (self2, payload) => {
    bufferParser$2.init(payload, 1);
    const numExts = bufferParser$2.readUInt32BE();
    let exts;
    if (numExts !== void 0) {
      exts = [];
      for (let i = 0; i < numExts; ++i) {
        const name = bufferParser$2.readString(true);
        const data = bufferParser$2.readString();
        if (data !== void 0) {
          switch (name) {
            case "server-sig-algs": {
              const algs = data.latin1Slice(0, data.length).split(",");
              exts.push({ name, algs });
              continue;
            }
            default:
              continue;
          }
        }
        exts = void 0;
        break;
      }
    }
    bufferParser$2.clear();
    if (exts === void 0)
      return doFatalError(self2, "Inbound: Malformed EXT_INFO packet");
    self2._debug && self2._debug("Inbound: Received EXT_INFO");
    const handler = self2._handlers.EXT_INFO;
    handler && handler(self2, exts);
  },
  // User auth protocol -- generic =============================================
  [MESSAGE$1.USERAUTH_REQUEST]: (self2, payload) => {
    bufferParser$2.init(payload, 1);
    const user = bufferParser$2.readString(true);
    const service = bufferParser$2.readString(true);
    const method = bufferParser$2.readString(true);
    let methodData;
    let methodDesc;
    switch (method) {
      case "none":
        methodData = null;
        break;
      case "password": {
        const isChange = bufferParser$2.readBool();
        if (isChange !== void 0) {
          methodData = bufferParser$2.readString(true);
          if (methodData !== void 0 && isChange) {
            const newPassword = bufferParser$2.readString(true);
            if (newPassword !== void 0)
              methodData = { oldPassword: methodData, newPassword };
            else
              methodData = void 0;
          }
        }
        break;
      }
      case "publickey": {
        const hasSig = bufferParser$2.readBool();
        if (hasSig !== void 0) {
          const keyAlgo = bufferParser$2.readString(true);
          let realKeyAlgo = keyAlgo;
          const key2 = bufferParser$2.readString();
          let hashAlgo;
          switch (keyAlgo) {
            case "rsa-sha2-256":
              realKeyAlgo = "ssh-rsa";
              hashAlgo = "sha256";
              break;
            case "rsa-sha2-512":
              realKeyAlgo = "ssh-rsa";
              hashAlgo = "sha512";
              break;
          }
          if (hasSig) {
            const blobEnd = bufferParser$2.pos();
            let signature = bufferParser$2.readString();
            if (signature !== void 0) {
              if (signature.length > 4 + keyAlgo.length + 4 && signature.utf8Slice(4, 4 + keyAlgo.length) === keyAlgo) {
                signature = bufferSlice$3(signature, 4 + keyAlgo.length + 4);
              }
              signature = sigSSHToASN1$1(signature, realKeyAlgo);
              if (signature) {
                const sessionID = self2._kex.sessionID;
                const blob = Buffer.allocUnsafe(4 + sessionID.length + blobEnd);
                writeUInt32BE$4(blob, sessionID.length, 0);
                blob.set(sessionID, 4);
                blob.set(
                  new Uint8Array(payload.buffer, payload.byteOffset, blobEnd),
                  4 + sessionID.length
                );
                methodData = {
                  keyAlgo: realKeyAlgo,
                  key: key2,
                  signature,
                  blob,
                  hashAlgo
                };
              }
            }
          } else {
            methodData = { keyAlgo: realKeyAlgo, key: key2, hashAlgo };
            methodDesc = "publickey -- check";
          }
        }
        break;
      }
      case "hostbased": {
        const keyAlgo = bufferParser$2.readString(true);
        let realKeyAlgo = keyAlgo;
        const key2 = bufferParser$2.readString();
        const localHostname = bufferParser$2.readString(true);
        const localUsername = bufferParser$2.readString(true);
        let hashAlgo;
        switch (keyAlgo) {
          case "rsa-sha2-256":
            realKeyAlgo = "ssh-rsa";
            hashAlgo = "sha256";
            break;
          case "rsa-sha2-512":
            realKeyAlgo = "ssh-rsa";
            hashAlgo = "sha512";
            break;
        }
        const blobEnd = bufferParser$2.pos();
        let signature = bufferParser$2.readString();
        if (signature !== void 0) {
          if (signature.length > 4 + keyAlgo.length + 4 && signature.utf8Slice(4, 4 + keyAlgo.length) === keyAlgo) {
            signature = bufferSlice$3(signature, 4 + keyAlgo.length + 4);
          }
          signature = sigSSHToASN1$1(signature, realKeyAlgo);
          if (signature !== void 0) {
            const sessionID = self2._kex.sessionID;
            const blob = Buffer.allocUnsafe(4 + sessionID.length + blobEnd);
            writeUInt32BE$4(blob, sessionID.length, 0);
            blob.set(sessionID, 4);
            blob.set(
              new Uint8Array(payload.buffer, payload.byteOffset, blobEnd),
              4 + sessionID.length
            );
            methodData = {
              keyAlgo: realKeyAlgo,
              key: key2,
              signature,
              blob,
              localHostname,
              localUsername,
              hashAlgo
            };
          }
        }
        break;
      }
      case "keyboard-interactive":
        bufferParser$2.skipString();
        methodData = bufferParser$2.readList();
        break;
      default:
        if (method !== void 0)
          methodData = bufferParser$2.readRaw();
    }
    bufferParser$2.clear();
    if (methodData === void 0) {
      return doFatalError(
        self2,
        "Inbound: Malformed USERAUTH_REQUEST packet"
      );
    }
    if (methodDesc === void 0)
      methodDesc = method;
    self2._authsQueue.push(method);
    self2._debug && self2._debug(`Inbound: Received USERAUTH_REQUEST (${methodDesc})`);
    const handler = self2._handlers.USERAUTH_REQUEST;
    handler && handler(self2, user, service, method, methodData);
  },
  [MESSAGE$1.USERAUTH_FAILURE]: (self2, payload) => {
    bufferParser$2.init(payload, 1);
    const authMethods = bufferParser$2.readList();
    const partialSuccess = bufferParser$2.readBool();
    bufferParser$2.clear();
    if (partialSuccess === void 0) {
      return doFatalError(
        self2,
        "Inbound: Malformed USERAUTH_FAILURE packet"
      );
    }
    self2._debug && self2._debug(`Inbound: Received USERAUTH_FAILURE (${authMethods})`);
    self2._authsQueue.shift();
    const handler = self2._handlers.USERAUTH_FAILURE;
    handler && handler(self2, authMethods, partialSuccess);
  },
  [MESSAGE$1.USERAUTH_SUCCESS]: (self2, payload) => {
    self2._debug && self2._debug("Inbound: Received USERAUTH_SUCCESS");
    self2._authsQueue.shift();
    const handler = self2._handlers.USERAUTH_SUCCESS;
    handler && handler(self2);
  },
  [MESSAGE$1.USERAUTH_BANNER]: (self2, payload) => {
    bufferParser$2.init(payload, 1);
    const msg = bufferParser$2.readString(true);
    const lang2 = bufferParser$2.readString();
    bufferParser$2.clear();
    if (lang2 === void 0) {
      return doFatalError(
        self2,
        "Inbound: Malformed USERAUTH_BANNER packet"
      );
    }
    self2._debug && self2._debug("Inbound: Received USERAUTH_BANNER");
    const handler = self2._handlers.USERAUTH_BANNER;
    handler && handler(self2, msg);
  },
  // User auth protocol -- method-specific =====================================
  60: (self2, payload) => {
    if (!self2._authsQueue.length) {
      self2._debug && self2._debug("Inbound: Received payload type 60 without auth");
      return;
    }
    switch (self2._authsQueue[0]) {
      case "password": {
        bufferParser$2.init(payload, 1);
        const prompt = bufferParser$2.readString(true);
        const lang2 = bufferParser$2.readString();
        bufferParser$2.clear();
        if (lang2 === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed USERAUTH_PASSWD_CHANGEREQ packet"
          );
        }
        self2._debug && self2._debug("Inbound: Received USERAUTH_PASSWD_CHANGEREQ");
        const handler = self2._handlers.USERAUTH_PASSWD_CHANGEREQ;
        handler && handler(self2, prompt);
        break;
      }
      case "publickey": {
        bufferParser$2.init(payload, 1);
        const keyAlgo = bufferParser$2.readString(true);
        const key2 = bufferParser$2.readString();
        bufferParser$2.clear();
        if (key2 === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed USERAUTH_PK_OK packet"
          );
        }
        self2._debug && self2._debug("Inbound: Received USERAUTH_PK_OK");
        self2._authsQueue.shift();
        const handler = self2._handlers.USERAUTH_PK_OK;
        handler && handler(self2, keyAlgo, key2);
        break;
      }
      case "keyboard-interactive": {
        bufferParser$2.init(payload, 1);
        const name = bufferParser$2.readString(true);
        const instructions = bufferParser$2.readString(true);
        bufferParser$2.readString();
        const numPrompts = bufferParser$2.readUInt32BE();
        let prompts;
        if (numPrompts !== void 0) {
          prompts = new Array(numPrompts);
          let i;
          for (i = 0; i < numPrompts; ++i) {
            const prompt = bufferParser$2.readString(true);
            const echo = bufferParser$2.readBool();
            if (echo === void 0)
              break;
            prompts[i] = { prompt, echo };
          }
          if (i !== numPrompts)
            prompts = void 0;
        }
        bufferParser$2.clear();
        if (prompts === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed USERAUTH_INFO_REQUEST packet"
          );
        }
        self2._debug && self2._debug("Inbound: Received USERAUTH_INFO_REQUEST");
        const handler = self2._handlers.USERAUTH_INFO_REQUEST;
        handler && handler(self2, name, instructions, prompts);
        break;
      }
      default:
        self2._debug && self2._debug("Inbound: Received unexpected payload type 60");
    }
  },
  61: (self2, payload) => {
    if (!self2._authsQueue.length) {
      self2._debug && self2._debug("Inbound: Received payload type 61 without auth");
      return;
    }
    if (self2._authsQueue[0] !== "keyboard-interactive") {
      return doFatalError(
        self2,
        "Inbound: Received unexpected payload type 61"
      );
    }
    bufferParser$2.init(payload, 1);
    const numResponses = bufferParser$2.readUInt32BE();
    let responses;
    if (numResponses !== void 0) {
      responses = new Array(numResponses);
      let i;
      for (i = 0; i < numResponses; ++i) {
        const response = bufferParser$2.readString(true);
        if (response === void 0)
          break;
        responses[i] = response;
      }
      if (i !== numResponses)
        responses = void 0;
    }
    bufferParser$2.clear();
    if (responses === void 0) {
      return doFatalError(
        self2,
        "Inbound: Malformed USERAUTH_INFO_RESPONSE packet"
      );
    }
    self2._debug && self2._debug("Inbound: Received USERAUTH_INFO_RESPONSE");
    const handler = self2._handlers.USERAUTH_INFO_RESPONSE;
    handler && handler(self2, responses);
  },
  // Connection protocol -- generic ============================================
  [MESSAGE$1.GLOBAL_REQUEST]: (self2, payload) => {
    bufferParser$2.init(payload, 1);
    const name = bufferParser$2.readString(true);
    const wantReply = bufferParser$2.readBool();
    let data;
    if (wantReply !== void 0) {
      switch (name) {
        case "tcpip-forward":
        case "cancel-tcpip-forward": {
          const bindAddr = bufferParser$2.readString(true);
          const bindPort = bufferParser$2.readUInt32BE();
          if (bindPort !== void 0)
            data = { bindAddr, bindPort };
          break;
        }
        case "streamlocal-forward@openssh.com":
        case "cancel-streamlocal-forward@openssh.com": {
          const socketPath = bufferParser$2.readString(true);
          if (socketPath !== void 0)
            data = { socketPath };
          break;
        }
        case "no-more-sessions@openssh.com":
          data = null;
          break;
        case "hostkeys-00@openssh.com": {
          data = [];
          while (bufferParser$2.avail() > 0) {
            const keyRaw = bufferParser$2.readString();
            if (keyRaw === void 0) {
              data = void 0;
              break;
            }
            const key2 = parseKey$4(keyRaw);
            if (!(key2 instanceof Error))
              data.push(key2);
          }
          break;
        }
        default:
          data = bufferParser$2.readRaw();
      }
    }
    bufferParser$2.clear();
    if (data === void 0) {
      return doFatalError(
        self2,
        "Inbound: Malformed GLOBAL_REQUEST packet"
      );
    }
    self2._debug && self2._debug(`Inbound: GLOBAL_REQUEST (${name})`);
    const handler = self2._handlers.GLOBAL_REQUEST;
    if (handler)
      handler(self2, name, wantReply, data);
    else
      self2.requestFailure();
  },
  [MESSAGE$1.REQUEST_SUCCESS]: (self2, payload) => {
    const data = payload.length > 1 ? bufferSlice$3(payload, 1) : null;
    self2._debug && self2._debug("Inbound: REQUEST_SUCCESS");
    const handler = self2._handlers.REQUEST_SUCCESS;
    handler && handler(self2, data);
  },
  [MESSAGE$1.REQUEST_FAILURE]: (self2, payload) => {
    self2._debug && self2._debug("Inbound: Received REQUEST_FAILURE");
    const handler = self2._handlers.REQUEST_FAILURE;
    handler && handler(self2);
  },
  // Connection protocol -- channel-related ====================================
  [MESSAGE$1.CHANNEL_OPEN]: (self2, payload) => {
    bufferParser$2.init(payload, 1);
    const type2 = bufferParser$2.readString(true);
    const sender = bufferParser$2.readUInt32BE();
    const window2 = bufferParser$2.readUInt32BE();
    const packetSize = bufferParser$2.readUInt32BE();
    let channelInfo;
    switch (type2) {
      case "forwarded-tcpip":
      case "direct-tcpip": {
        const destIP = bufferParser$2.readString(true);
        const destPort = bufferParser$2.readUInt32BE();
        const srcIP = bufferParser$2.readString(true);
        const srcPort = bufferParser$2.readUInt32BE();
        if (srcPort !== void 0) {
          channelInfo = {
            type: type2,
            sender,
            window: window2,
            packetSize,
            data: { destIP, destPort, srcIP, srcPort }
          };
        }
        break;
      }
      case "forwarded-streamlocal@openssh.com":
      case "direct-streamlocal@openssh.com": {
        const socketPath = bufferParser$2.readString(true);
        if (socketPath !== void 0) {
          channelInfo = {
            type: type2,
            sender,
            window: window2,
            packetSize,
            data: { socketPath }
          };
        }
        break;
      }
      case "x11": {
        const srcIP = bufferParser$2.readString(true);
        const srcPort = bufferParser$2.readUInt32BE();
        if (srcPort !== void 0) {
          channelInfo = {
            type: type2,
            sender,
            window: window2,
            packetSize,
            data: { srcIP, srcPort }
          };
        }
        break;
      }
      default:
        channelInfo = {
          type: type2,
          sender,
          window: window2,
          packetSize,
          data: {}
        };
    }
    bufferParser$2.clear();
    if (channelInfo === void 0) {
      return doFatalError(
        self2,
        "Inbound: Malformed CHANNEL_OPEN packet"
      );
    }
    self2._debug && self2._debug(`Inbound: CHANNEL_OPEN (s:${sender}, ${type2})`);
    const handler = self2._handlers.CHANNEL_OPEN;
    if (handler) {
      handler(self2, channelInfo);
    } else {
      self2.channelOpenFail(
        channelInfo.sender,
        CHANNEL_OPEN_FAILURE$2.ADMINISTRATIVELY_PROHIBITED,
        "",
        ""
      );
    }
  },
  [MESSAGE$1.CHANNEL_OPEN_CONFIRMATION]: (self2, payload) => {
    bufferParser$2.init(payload, 1);
    const recipient = bufferParser$2.readUInt32BE();
    const sender = bufferParser$2.readUInt32BE();
    const window2 = bufferParser$2.readUInt32BE();
    const packetSize = bufferParser$2.readUInt32BE();
    const data = bufferParser$2.avail() ? bufferParser$2.readRaw() : void 0;
    bufferParser$2.clear();
    if (packetSize === void 0) {
      return doFatalError(
        self2,
        "Inbound: Malformed CHANNEL_OPEN_CONFIRMATION packet"
      );
    }
    self2._debug && self2._debug(
      `Inbound: CHANNEL_OPEN_CONFIRMATION (r:${recipient}, s:${sender})`
    );
    const handler = self2._handlers.CHANNEL_OPEN_CONFIRMATION;
    if (handler)
      handler(self2, { recipient, sender, window: window2, packetSize, data });
  },
  [MESSAGE$1.CHANNEL_OPEN_FAILURE]: (self2, payload) => {
    bufferParser$2.init(payload, 1);
    const recipient = bufferParser$2.readUInt32BE();
    const reason = bufferParser$2.readUInt32BE();
    const description2 = bufferParser$2.readString(true);
    const lang2 = bufferParser$2.readString();
    bufferParser$2.clear();
    if (lang2 === void 0) {
      return doFatalError(
        self2,
        "Inbound: Malformed CHANNEL_OPEN_FAILURE packet"
      );
    }
    self2._debug && self2._debug(`Inbound: CHANNEL_OPEN_FAILURE (r:${recipient})`);
    const handler = self2._handlers.CHANNEL_OPEN_FAILURE;
    handler && handler(self2, recipient, reason, description2);
  },
  [MESSAGE$1.CHANNEL_WINDOW_ADJUST]: (self2, payload) => {
    bufferParser$2.init(payload, 1);
    const recipient = bufferParser$2.readUInt32BE();
    const bytesToAdd = bufferParser$2.readUInt32BE();
    bufferParser$2.clear();
    if (bytesToAdd === void 0) {
      return doFatalError(
        self2,
        "Inbound: Malformed CHANNEL_WINDOW_ADJUST packet"
      );
    }
    self2._debug && self2._debug(
      `Inbound: CHANNEL_WINDOW_ADJUST (r:${recipient}, ${bytesToAdd})`
    );
    const handler = self2._handlers.CHANNEL_WINDOW_ADJUST;
    handler && handler(self2, recipient, bytesToAdd);
  },
  [MESSAGE$1.CHANNEL_DATA]: (self2, payload) => {
    bufferParser$2.init(payload, 1);
    const recipient = bufferParser$2.readUInt32BE();
    const data = bufferParser$2.readString();
    bufferParser$2.clear();
    if (data === void 0) {
      return doFatalError(
        self2,
        "Inbound: Malformed CHANNEL_DATA packet"
      );
    }
    self2._debug && self2._debug(`Inbound: CHANNEL_DATA (r:${recipient}, ${data.length})`);
    const handler = self2._handlers.CHANNEL_DATA;
    handler && handler(self2, recipient, data);
  },
  [MESSAGE$1.CHANNEL_EXTENDED_DATA]: (self2, payload) => {
    bufferParser$2.init(payload, 1);
    const recipient = bufferParser$2.readUInt32BE();
    const type2 = bufferParser$2.readUInt32BE();
    const data = bufferParser$2.readString();
    bufferParser$2.clear();
    if (data === void 0) {
      return doFatalError(
        self2,
        "Inbound: Malformed CHANNEL_EXTENDED_DATA packet"
      );
    }
    self2._debug && self2._debug(
      `Inbound: CHANNEL_EXTENDED_DATA (r:${recipient}, ${data.length})`
    );
    const handler = self2._handlers.CHANNEL_EXTENDED_DATA;
    handler && handler(self2, recipient, data, type2);
  },
  [MESSAGE$1.CHANNEL_EOF]: (self2, payload) => {
    bufferParser$2.init(payload, 1);
    const recipient = bufferParser$2.readUInt32BE();
    bufferParser$2.clear();
    if (recipient === void 0) {
      return doFatalError(
        self2,
        "Inbound: Malformed CHANNEL_EOF packet"
      );
    }
    self2._debug && self2._debug(`Inbound: CHANNEL_EOF (r:${recipient})`);
    const handler = self2._handlers.CHANNEL_EOF;
    handler && handler(self2, recipient);
  },
  [MESSAGE$1.CHANNEL_CLOSE]: (self2, payload) => {
    bufferParser$2.init(payload, 1);
    const recipient = bufferParser$2.readUInt32BE();
    bufferParser$2.clear();
    if (recipient === void 0) {
      return doFatalError(
        self2,
        "Inbound: Malformed CHANNEL_CLOSE packet"
      );
    }
    self2._debug && self2._debug(`Inbound: CHANNEL_CLOSE (r:${recipient})`);
    const handler = self2._handlers.CHANNEL_CLOSE;
    handler && handler(self2, recipient);
  },
  [MESSAGE$1.CHANNEL_REQUEST]: (self2, payload) => {
    bufferParser$2.init(payload, 1);
    const recipient = bufferParser$2.readUInt32BE();
    const type2 = bufferParser$2.readString(true);
    const wantReply = bufferParser$2.readBool();
    let data;
    if (wantReply !== void 0) {
      switch (type2) {
        case "exit-status":
          data = bufferParser$2.readUInt32BE();
          self2._debug && self2._debug(
            `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type2}: ${data})`
          );
          break;
        case "exit-signal": {
          let signal;
          let coreDumped;
          if (self2._compatFlags & COMPAT$1.OLD_EXIT) {
            const num = bufferParser$2.readUInt32BE();
            switch (num) {
              case 1:
                signal = "HUP";
                break;
              case 2:
                signal = "INT";
                break;
              case 3:
                signal = "QUIT";
                break;
              case 6:
                signal = "ABRT";
                break;
              case 9:
                signal = "KILL";
                break;
              case 14:
                signal = "ALRM";
                break;
              case 15:
                signal = "TERM";
                break;
              default:
                if (num !== void 0) {
                  signal = `UNKNOWN (${num})`;
                }
            }
            coreDumped = false;
          } else {
            signal = bufferParser$2.readString(true);
            coreDumped = bufferParser$2.readBool();
            if (coreDumped === void 0)
              signal = void 0;
          }
          const errorMessage = bufferParser$2.readString(true);
          if (bufferParser$2.skipString() !== void 0)
            data = { signal, coreDumped, errorMessage };
          self2._debug && self2._debug(
            `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type2}: ${signal})`
          );
          break;
        }
        case "pty-req": {
          const term = bufferParser$2.readString(true);
          const cols = bufferParser$2.readUInt32BE();
          const rows = bufferParser$2.readUInt32BE();
          const width = bufferParser$2.readUInt32BE();
          const height = bufferParser$2.readUInt32BE();
          const modesBinary = bufferParser$2.readString();
          if (modesBinary !== void 0) {
            bufferParser$2.init(modesBinary, 1);
            let modes = {};
            while (bufferParser$2.avail()) {
              const opcode = bufferParser$2.readByte();
              if (opcode === TERMINAL_MODE$1.TTY_OP_END)
                break;
              const name = TERMINAL_MODE_BY_VALUE[opcode];
              const value = bufferParser$2.readUInt32BE();
              if (opcode === void 0 || name === void 0 || value === void 0) {
                modes = void 0;
                break;
              }
              modes[name] = value;
            }
            if (modes !== void 0)
              data = { term, cols, rows, width, height, modes };
          }
          self2._debug && self2._debug(
            `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type2})`
          );
          break;
        }
        case "window-change": {
          const cols = bufferParser$2.readUInt32BE();
          const rows = bufferParser$2.readUInt32BE();
          const width = bufferParser$2.readUInt32BE();
          const height = bufferParser$2.readUInt32BE();
          if (height !== void 0)
            data = { cols, rows, width, height };
          self2._debug && self2._debug(
            `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type2})`
          );
          break;
        }
        case "x11-req": {
          const single = bufferParser$2.readBool();
          const protocol = bufferParser$2.readString(true);
          const cookie = bufferParser$2.readString();
          const screen = bufferParser$2.readUInt32BE();
          if (screen !== void 0)
            data = { single, protocol, cookie, screen };
          self2._debug && self2._debug(
            `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type2})`
          );
          break;
        }
        case "env": {
          const name = bufferParser$2.readString(true);
          const value = bufferParser$2.readString(true);
          if (value !== void 0)
            data = { name, value };
          if (self2._debug) {
            self2._debug(
              `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type2}: ${name}=${value})`
            );
          }
          break;
        }
        case "shell":
          data = null;
          self2._debug && self2._debug(
            `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type2})`
          );
          break;
        case "exec":
          data = bufferParser$2.readString(true);
          self2._debug && self2._debug(
            `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type2}: ${data})`
          );
          break;
        case "subsystem":
          data = bufferParser$2.readString(true);
          self2._debug && self2._debug(
            `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type2}: ${data})`
          );
          break;
        case "signal":
          data = bufferParser$2.readString(true);
          self2._debug && self2._debug(
            `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type2}: ${data})`
          );
          break;
        case "xon-xoff":
          data = bufferParser$2.readBool();
          self2._debug && self2._debug(
            `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type2}: ${data})`
          );
          break;
        case "auth-agent-req@openssh.com":
          data = null;
          self2._debug && self2._debug(
            `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type2})`
          );
          break;
        default:
          data = bufferParser$2.avail() ? bufferParser$2.readRaw() : null;
          self2._debug && self2._debug(
            `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type2})`
          );
      }
    }
    bufferParser$2.clear();
    if (data === void 0) {
      return doFatalError(
        self2,
        "Inbound: Malformed CHANNEL_REQUEST packet"
      );
    }
    const handler = self2._handlers.CHANNEL_REQUEST;
    handler && handler(self2, recipient, type2, wantReply, data);
  },
  [MESSAGE$1.CHANNEL_SUCCESS]: (self2, payload) => {
    bufferParser$2.init(payload, 1);
    const recipient = bufferParser$2.readUInt32BE();
    bufferParser$2.clear();
    if (recipient === void 0) {
      return doFatalError(
        self2,
        "Inbound: Malformed CHANNEL_SUCCESS packet"
      );
    }
    self2._debug && self2._debug(`Inbound: CHANNEL_SUCCESS (r:${recipient})`);
    const handler = self2._handlers.CHANNEL_SUCCESS;
    handler && handler(self2, recipient);
  },
  [MESSAGE$1.CHANNEL_FAILURE]: (self2, payload) => {
    bufferParser$2.init(payload, 1);
    const recipient = bufferParser$2.readUInt32BE();
    bufferParser$2.clear();
    if (recipient === void 0) {
      return doFatalError(
        self2,
        "Inbound: Malformed CHANNEL_FAILURE packet"
      );
    }
    self2._debug && self2._debug(`Inbound: CHANNEL_FAILURE (r:${recipient})`);
    const handler = self2._handlers.CHANNEL_FAILURE;
    handler && handler(self2, recipient);
  }
};
var handlers;
var hasRequiredHandlers;
function requireHandlers() {
  if (hasRequiredHandlers) return handlers;
  hasRequiredHandlers = 1;
  const MESSAGE_HANDLERS2 = new Array(256);
  [
    requireKex().HANDLERS,
    handlers_misc
  ].forEach((handlers2) => {
    for (let [type2, handler] of Object.entries(handlers2)) {
      type2 = +type2;
      if (isFinite(type2) && type2 >= 0 && type2 < MESSAGE_HANDLERS2.length)
        MESSAGE_HANDLERS2[type2] = handler;
    }
  });
  handlers = MESSAGE_HANDLERS2;
  return handlers;
}
var kex;
var hasRequiredKex;
function requireKex() {
  if (hasRequiredKex) return kex;
  hasRequiredKex = 1;
  const {
    createDiffieHellman,
    createDiffieHellmanGroup,
    createECDH: createECDH2,
    createHash: createHash2,
    createPublicKey,
    diffieHellman,
    generateKeyPairSync,
    randomFillSync: randomFillSync2
  } = require$$0$3;
  const { Ber: Ber2 } = lib$1;
  const {
    COMPAT: COMPAT2,
    curve25519Supported,
    DEFAULT_KEX: DEFAULT_KEX2,
    DEFAULT_SERVER_HOST_KEY: DEFAULT_SERVER_HOST_KEY2,
    DEFAULT_CIPHER: DEFAULT_CIPHER2,
    DEFAULT_MAC: DEFAULT_MAC2,
    DEFAULT_COMPRESSION: DEFAULT_COMPRESSION2,
    DISCONNECT_REASON: DISCONNECT_REASON2,
    MESSAGE: MESSAGE2
  } = requireConstants();
  const {
    CIPHER_INFO: CIPHER_INFO2,
    createCipher,
    createDecipher,
    MAC_INFO
  } = requireCrypto();
  const { parseDERKey } = keyParser;
  const {
    bufferFill: bufferFill2,
    bufferParser: bufferParser2,
    convertSignature: convertSignature2,
    doFatalError: doFatalError2,
    FastBuffer: FastBuffer2,
    sigSSHToASN1: sigSSHToASN12,
    writeUInt32BE: writeUInt32BE2
  } = requireUtils();
  const {
    PacketReader: PacketReader3,
    PacketWriter: PacketWriter3,
    ZlibPacketReader: ZlibPacketReader3,
    ZlibPacketWriter: ZlibPacketWriter3
  } = zlib;
  let MESSAGE_HANDLERS2;
  const GEX_MIN_BITS = 2048;
  const GEX_MAX_BITS = 8192;
  const EMPTY_BUFFER = Buffer.alloc(0);
  function kexinit2(self2) {
    let payload;
    if (self2._compatFlags & COMPAT2.BAD_DHGEX) {
      const entry = self2._offer.lists.kex;
      let kex2 = entry.array;
      let found = false;
      for (let i = 0; i < kex2.length; ++i) {
        if (kex2[i].includes("group-exchange")) {
          if (!found) {
            found = true;
            kex2 = kex2.slice();
          }
          kex2.splice(i--, 1);
        }
      }
      if (found) {
        let len = 1 + 16 + self2._offer.totalSize + 1 + 4;
        const newKexBuf = Buffer.from(kex2.join(","));
        len -= entry.buffer.length - newKexBuf.length;
        const all = self2._offer.lists.all;
        const rest = new Uint8Array(
          all.buffer,
          all.byteOffset + 4 + entry.buffer.length,
          all.length - (4 + entry.buffer.length)
        );
        payload = Buffer.allocUnsafe(len);
        writeUInt32BE2(payload, newKexBuf.length, 17);
        payload.set(newKexBuf, 17 + 4);
        payload.set(rest, 17 + 4 + newKexBuf.length);
      }
    }
    if (payload === void 0) {
      payload = Buffer.allocUnsafe(1 + 16 + self2._offer.totalSize + 1 + 4);
      self2._offer.copyAllTo(payload, 17);
    }
    self2._debug && self2._debug("Outbound: Sending KEXINIT");
    payload[0] = MESSAGE2.KEXINIT;
    randomFillSync2(payload, 1, 16);
    bufferFill2(payload, 0, payload.length - 5);
    self2._kexinit = payload;
    self2._packetRW.write.allocStart = 0;
    {
      const p = self2._packetRW.write.allocStartKEX;
      const packet = self2._packetRW.write.alloc(payload.length, true);
      packet.set(payload, p);
      self2._cipher.encrypt(self2._packetRW.write.finalize(packet, true));
    }
  }
  function handleKexInit(self2, payload) {
    const init = {
      kex: void 0,
      serverHostKey: void 0,
      cs: {
        cipher: void 0,
        mac: void 0,
        compress: void 0,
        lang: void 0
      },
      sc: {
        cipher: void 0,
        mac: void 0,
        compress: void 0,
        lang: void 0
      }
    };
    bufferParser2.init(payload, 17);
    if ((init.kex = bufferParser2.readList()) === void 0 || (init.serverHostKey = bufferParser2.readList()) === void 0 || (init.cs.cipher = bufferParser2.readList()) === void 0 || (init.sc.cipher = bufferParser2.readList()) === void 0 || (init.cs.mac = bufferParser2.readList()) === void 0 || (init.sc.mac = bufferParser2.readList()) === void 0 || (init.cs.compress = bufferParser2.readList()) === void 0 || (init.sc.compress = bufferParser2.readList()) === void 0 || (init.cs.lang = bufferParser2.readList()) === void 0 || (init.sc.lang = bufferParser2.readList()) === void 0) {
      bufferParser2.clear();
      return doFatalError2(
        self2,
        "Received malformed KEXINIT",
        "handshake",
        DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
      );
    }
    const pos = bufferParser2.pos();
    const firstFollows = pos < payload.length && payload[pos] === 1;
    bufferParser2.clear();
    const local = self2._offer;
    const remote = init;
    let localKex = local.lists.kex.array;
    if (self2._compatFlags & COMPAT2.BAD_DHGEX) {
      let found = false;
      for (let i2 = 0; i2 < localKex.length; ++i2) {
        if (localKex[i2].indexOf("group-exchange") !== -1) {
          if (!found) {
            found = true;
            localKex = localKex.slice();
          }
          localKex.splice(i2--, 1);
        }
      }
    }
    let clientList;
    let serverList;
    let i;
    const debug2 = self2._debug;
    debug2 && debug2("Inbound: Handshake in progress");
    debug2 && debug2(`Handshake: (local) KEX method: ${localKex}`);
    debug2 && debug2(`Handshake: (remote) KEX method: ${remote.kex}`);
    let remoteExtInfoEnabled;
    if (self2._server) {
      serverList = localKex;
      clientList = remote.kex;
      remoteExtInfoEnabled = clientList.indexOf("ext-info-c") !== -1;
    } else {
      serverList = remote.kex;
      clientList = localKex;
      remoteExtInfoEnabled = serverList.indexOf("ext-info-s") !== -1;
    }
    if (self2._strictMode === void 0) {
      if (self2._server) {
        self2._strictMode = clientList.indexOf("kex-strict-c-v00@openssh.com") !== -1;
      } else {
        self2._strictMode = serverList.indexOf("kex-strict-s-v00@openssh.com") !== -1;
      }
      if (self2._strictMode) {
        debug2 && debug2("Handshake: strict KEX mode enabled");
        if (self2._decipher.inSeqno !== 1) {
          if (debug2)
            debug2("Handshake: KEXINIT not first packet in strict KEX mode");
          return doFatalError2(
            self2,
            "Handshake failed: KEXINIT not first packet in strict KEX mode",
            "handshake",
            DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
          );
        }
      }
    }
    for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i) ;
    if (i === clientList.length) {
      debug2 && debug2("Handshake: no matching key exchange algorithm");
      return doFatalError2(
        self2,
        "Handshake failed: no matching key exchange algorithm",
        "handshake",
        DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
      );
    }
    init.kex = clientList[i];
    debug2 && debug2(`Handshake: KEX algorithm: ${clientList[i]}`);
    if (firstFollows && (!remote.kex.length || clientList[i] !== remote.kex[0])) {
      self2._skipNextInboundPacket = true;
    }
    const localSrvHostKey = local.lists.serverHostKey.array;
    debug2 && debug2(`Handshake: (local) Host key format: ${localSrvHostKey}`);
    debug2 && debug2(
      `Handshake: (remote) Host key format: ${remote.serverHostKey}`
    );
    if (self2._server) {
      serverList = localSrvHostKey;
      clientList = remote.serverHostKey;
    } else {
      serverList = remote.serverHostKey;
      clientList = localSrvHostKey;
    }
    for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i) ;
    if (i === clientList.length) {
      debug2 && debug2("Handshake: No matching host key format");
      return doFatalError2(
        self2,
        "Handshake failed: no matching host key format",
        "handshake",
        DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
      );
    }
    init.serverHostKey = clientList[i];
    debug2 && debug2(`Handshake: Host key format: ${clientList[i]}`);
    const localCSCipher = local.lists.cs.cipher.array;
    debug2 && debug2(`Handshake: (local) C->S cipher: ${localCSCipher}`);
    debug2 && debug2(`Handshake: (remote) C->S cipher: ${remote.cs.cipher}`);
    if (self2._server) {
      serverList = localCSCipher;
      clientList = remote.cs.cipher;
    } else {
      serverList = remote.cs.cipher;
      clientList = localCSCipher;
    }
    for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i) ;
    if (i === clientList.length) {
      debug2 && debug2("Handshake: No matching C->S cipher");
      return doFatalError2(
        self2,
        "Handshake failed: no matching C->S cipher",
        "handshake",
        DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
      );
    }
    init.cs.cipher = clientList[i];
    debug2 && debug2(`Handshake: C->S Cipher: ${clientList[i]}`);
    const localSCCipher = local.lists.sc.cipher.array;
    debug2 && debug2(`Handshake: (local) S->C cipher: ${localSCCipher}`);
    debug2 && debug2(`Handshake: (remote) S->C cipher: ${remote.sc.cipher}`);
    if (self2._server) {
      serverList = localSCCipher;
      clientList = remote.sc.cipher;
    } else {
      serverList = remote.sc.cipher;
      clientList = localSCCipher;
    }
    for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i) ;
    if (i === clientList.length) {
      debug2 && debug2("Handshake: No matching S->C cipher");
      return doFatalError2(
        self2,
        "Handshake failed: no matching S->C cipher",
        "handshake",
        DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
      );
    }
    init.sc.cipher = clientList[i];
    debug2 && debug2(`Handshake: S->C cipher: ${clientList[i]}`);
    const localCSMAC = local.lists.cs.mac.array;
    debug2 && debug2(`Handshake: (local) C->S MAC: ${localCSMAC}`);
    debug2 && debug2(`Handshake: (remote) C->S MAC: ${remote.cs.mac}`);
    if (CIPHER_INFO2[init.cs.cipher].authLen > 0) {
      init.cs.mac = "";
      debug2 && debug2("Handshake: C->S MAC: <implicit>");
    } else {
      if (self2._server) {
        serverList = localCSMAC;
        clientList = remote.cs.mac;
      } else {
        serverList = remote.cs.mac;
        clientList = localCSMAC;
      }
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i) ;
      if (i === clientList.length) {
        debug2 && debug2("Handshake: No matching C->S MAC");
        return doFatalError2(
          self2,
          "Handshake failed: no matching C->S MAC",
          "handshake",
          DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
        );
      }
      init.cs.mac = clientList[i];
      debug2 && debug2(`Handshake: C->S MAC: ${clientList[i]}`);
    }
    const localSCMAC = local.lists.sc.mac.array;
    debug2 && debug2(`Handshake: (local) S->C MAC: ${localSCMAC}`);
    debug2 && debug2(`Handshake: (remote) S->C MAC: ${remote.sc.mac}`);
    if (CIPHER_INFO2[init.sc.cipher].authLen > 0) {
      init.sc.mac = "";
      debug2 && debug2("Handshake: S->C MAC: <implicit>");
    } else {
      if (self2._server) {
        serverList = localSCMAC;
        clientList = remote.sc.mac;
      } else {
        serverList = remote.sc.mac;
        clientList = localSCMAC;
      }
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i) ;
      if (i === clientList.length) {
        debug2 && debug2("Handshake: No matching S->C MAC");
        return doFatalError2(
          self2,
          "Handshake failed: no matching S->C MAC",
          "handshake",
          DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
        );
      }
      init.sc.mac = clientList[i];
      debug2 && debug2(`Handshake: S->C MAC: ${clientList[i]}`);
    }
    const localCSCompress = local.lists.cs.compress.array;
    debug2 && debug2(`Handshake: (local) C->S compression: ${localCSCompress}`);
    debug2 && debug2(`Handshake: (remote) C->S compression: ${remote.cs.compress}`);
    if (self2._server) {
      serverList = localCSCompress;
      clientList = remote.cs.compress;
    } else {
      serverList = remote.cs.compress;
      clientList = localCSCompress;
    }
    for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i) ;
    if (i === clientList.length) {
      debug2 && debug2("Handshake: No matching C->S compression");
      return doFatalError2(
        self2,
        "Handshake failed: no matching C->S compression",
        "handshake",
        DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
      );
    }
    init.cs.compress = clientList[i];
    debug2 && debug2(`Handshake: C->S compression: ${clientList[i]}`);
    const localSCCompress = local.lists.sc.compress.array;
    debug2 && debug2(`Handshake: (local) S->C compression: ${localSCCompress}`);
    debug2 && debug2(`Handshake: (remote) S->C compression: ${remote.sc.compress}`);
    if (self2._server) {
      serverList = localSCCompress;
      clientList = remote.sc.compress;
    } else {
      serverList = remote.sc.compress;
      clientList = localSCCompress;
    }
    for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i) ;
    if (i === clientList.length) {
      debug2 && debug2("Handshake: No matching S->C compression");
      return doFatalError2(
        self2,
        "Handshake failed: no matching S->C compression",
        "handshake",
        DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
      );
    }
    init.sc.compress = clientList[i];
    debug2 && debug2(`Handshake: S->C compression: ${clientList[i]}`);
    init.cs.lang = "";
    init.sc.lang = "";
    if (self2._kex) {
      if (!self2._kexinit) {
        kexinit2(self2);
      }
      self2._decipher._onPayload = onKEXPayload2.bind(self2, { firstPacket: false });
    }
    self2._kex = createKeyExchange(init, self2, payload);
    self2._kex.remoteExtInfoEnabled = remoteExtInfoEnabled;
    self2._kex.start();
  }
  const createKeyExchange = /* @__PURE__ */ (() => {
    function convertToMpint(buf) {
      let idx = 0;
      let length = buf.length;
      while (buf[idx] === 0) {
        ++idx;
        --length;
      }
      let newBuf;
      if (buf[idx] & 128) {
        newBuf = Buffer.allocUnsafe(1 + length);
        newBuf[0] = 0;
        buf.copy(newBuf, 1, idx);
        buf = newBuf;
      } else if (length !== buf.length) {
        newBuf = Buffer.allocUnsafe(length);
        buf.copy(newBuf, 0, idx);
        buf = newBuf;
      }
      return buf;
    }
    class KeyExchange {
      constructor(negotiated, protocol, remoteKexinit) {
        this._protocol = protocol;
        this.sessionID = protocol._kex ? protocol._kex.sessionID : void 0;
        this.negotiated = negotiated;
        this.remoteExtInfoEnabled = false;
        this._step = 1;
        this._public = null;
        this._dh = null;
        this._sentNEWKEYS = false;
        this._receivedNEWKEYS = false;
        this._finished = false;
        this._hostVerified = false;
        this._kexinit = protocol._kexinit;
        this._remoteKexinit = remoteKexinit;
        this._identRaw = protocol._identRaw;
        this._remoteIdentRaw = protocol._remoteIdentRaw;
        this._hostKey = void 0;
        this._dhData = void 0;
        this._sig = void 0;
      }
      finish(scOnly) {
        if (this._finished)
          return false;
        this._finished = true;
        const isServer = this._protocol._server;
        const negotiated = this.negotiated;
        const pubKey = this.convertPublicKey(this._dhData);
        let secret = this.computeSecret(this._dhData);
        if (secret instanceof Error) {
          secret.message = `Error while computing DH secret (${this.type}): ${secret.message}`;
          secret.level = "handshake";
          return doFatalError2(
            this._protocol,
            secret,
            DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
          );
        }
        const hash = createHash2(this.hashName);
        hashString(hash, isServer ? this._remoteIdentRaw : this._identRaw);
        hashString(hash, isServer ? this._identRaw : this._remoteIdentRaw);
        hashString(hash, isServer ? this._remoteKexinit : this._kexinit);
        hashString(hash, isServer ? this._kexinit : this._remoteKexinit);
        const serverPublicHostKey = isServer ? this._hostKey.getPublicSSH() : this._hostKey;
        hashString(hash, serverPublicHostKey);
        if (this.type === "groupex") {
          const params = this.getDHParams();
          const num = Buffer.allocUnsafe(4);
          writeUInt32BE2(num, this._minBits, 0);
          hash.update(num);
          writeUInt32BE2(num, this._prefBits, 0);
          hash.update(num);
          writeUInt32BE2(num, this._maxBits, 0);
          hash.update(num);
          hashString(hash, params.prime);
          hashString(hash, params.generator);
        }
        hashString(hash, isServer ? pubKey : this.getPublicKey());
        const serverPublicKey = isServer ? this.getPublicKey() : pubKey;
        hashString(hash, serverPublicKey);
        hashString(hash, secret);
        const exchangeHash = hash.digest();
        if (!isServer) {
          bufferParser2.init(this._sig, 0);
          const sigType = bufferParser2.readString(true);
          if (!sigType) {
            return doFatalError2(
              this._protocol,
              "Malformed packet while reading signature",
              "handshake",
              DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
            );
          }
          if (sigType !== negotiated.serverHostKey) {
            return doFatalError2(
              this._protocol,
              `Wrong signature type: ${sigType}, expected: ${negotiated.serverHostKey}`,
              "handshake",
              DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
            );
          }
          let sigValue = bufferParser2.readString();
          bufferParser2.clear();
          if (sigValue === void 0) {
            return doFatalError2(
              this._protocol,
              "Malformed packet while reading signature",
              "handshake",
              DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
            );
          }
          if (!(sigValue = sigSSHToASN12(sigValue, sigType))) {
            return doFatalError2(
              this._protocol,
              "Malformed signature",
              "handshake",
              DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
            );
          }
          let parsedHostKey;
          {
            bufferParser2.init(this._hostKey, 0);
            const name = bufferParser2.readString(true);
            const hostKey = this._hostKey.slice(bufferParser2.pos());
            bufferParser2.clear();
            parsedHostKey = parseDERKey(hostKey, name);
            if (parsedHostKey instanceof Error) {
              parsedHostKey.level = "handshake";
              return doFatalError2(
                this._protocol,
                parsedHostKey,
                DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
              );
            }
          }
          let hashAlgo;
          switch (this.negotiated.serverHostKey) {
            case "rsa-sha2-256":
              hashAlgo = "sha256";
              break;
            case "rsa-sha2-512":
              hashAlgo = "sha512";
              break;
          }
          this._protocol._debug && this._protocol._debug("Verifying signature ...");
          const verified = parsedHostKey.verify(exchangeHash, sigValue, hashAlgo);
          if (verified !== true) {
            if (verified instanceof Error) {
              this._protocol._debug && this._protocol._debug(
                `Signature verification failed: ${verified.stack}`
              );
            } else {
              this._protocol._debug && this._protocol._debug(
                "Signature verification failed"
              );
            }
            return doFatalError2(
              this._protocol,
              "Handshake failed: signature verification failed",
              "handshake",
              DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
            );
          }
          this._protocol._debug && this._protocol._debug("Verified signature");
        } else {
          let hashAlgo;
          switch (this.negotiated.serverHostKey) {
            case "rsa-sha2-256":
              hashAlgo = "sha256";
              break;
            case "rsa-sha2-512":
              hashAlgo = "sha512";
              break;
          }
          this._protocol._debug && this._protocol._debug(
            "Generating signature ..."
          );
          let signature = this._hostKey.sign(exchangeHash, hashAlgo);
          if (signature instanceof Error) {
            return doFatalError2(
              this._protocol,
              `Handshake failed: signature generation failed for ${this._hostKey.type} host key: ${signature.message}`,
              "handshake",
              DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
            );
          }
          signature = convertSignature2(signature, this._hostKey.type);
          if (signature === false) {
            return doFatalError2(
              this._protocol,
              `Handshake failed: signature conversion failed for ${this._hostKey.type} host key`,
              "handshake",
              DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
            );
          }
          const sigType = this.negotiated.serverHostKey;
          const sigTypeLen = Buffer.byteLength(sigType);
          const sigLen = 4 + sigTypeLen + 4 + signature.length;
          let p = this._protocol._packetRW.write.allocStartKEX;
          const packet = this._protocol._packetRW.write.alloc(
            1 + 4 + serverPublicHostKey.length + 4 + serverPublicKey.length + 4 + sigLen,
            true
          );
          packet[p] = MESSAGE2.KEXDH_REPLY;
          writeUInt32BE2(packet, serverPublicHostKey.length, ++p);
          packet.set(serverPublicHostKey, p += 4);
          writeUInt32BE2(
            packet,
            serverPublicKey.length,
            p += serverPublicHostKey.length
          );
          packet.set(serverPublicKey, p += 4);
          writeUInt32BE2(packet, sigLen, p += serverPublicKey.length);
          writeUInt32BE2(packet, sigTypeLen, p += 4);
          packet.utf8Write(sigType, p += 4, sigTypeLen);
          writeUInt32BE2(packet, signature.length, p += sigTypeLen);
          packet.set(signature, p += 4);
          if (this._protocol._debug) {
            let type2;
            switch (this.type) {
              case "group":
                type2 = "KEXDH_REPLY";
                break;
              case "groupex":
                type2 = "KEXDH_GEX_REPLY";
                break;
              default:
                type2 = "KEXECDH_REPLY";
            }
            this._protocol._debug(`Outbound: Sending ${type2}`);
          }
          this._protocol._cipher.encrypt(
            this._protocol._packetRW.write.finalize(packet, true)
          );
        }
        if (isServer || !scOnly)
          trySendNEWKEYS(this);
        let hsCipherConfig;
        let hsWrite;
        const completeHandshake = (partial) => {
          if (hsCipherConfig) {
            trySendNEWKEYS(this);
            hsCipherConfig.outbound.seqno = this._protocol._cipher.outSeqno;
            this._protocol._cipher.free();
            this._protocol._cipher = createCipher(hsCipherConfig);
            this._protocol._packetRW.write = hsWrite;
            hsCipherConfig = void 0;
            hsWrite = void 0;
            this._protocol._onHandshakeComplete(negotiated);
            return false;
          }
          if (!this.sessionID)
            this.sessionID = exchangeHash;
          {
            const newSecret = Buffer.allocUnsafe(4 + secret.length);
            writeUInt32BE2(newSecret, secret.length, 0);
            newSecret.set(secret, 4);
            secret = newSecret;
          }
          const csCipherInfo = CIPHER_INFO2[negotiated.cs.cipher];
          const scCipherInfo = CIPHER_INFO2[negotiated.sc.cipher];
          const csIV = generateKEXVal(
            csCipherInfo.ivLen,
            this.hashName,
            secret,
            exchangeHash,
            this.sessionID,
            "A"
          );
          const scIV = generateKEXVal(
            scCipherInfo.ivLen,
            this.hashName,
            secret,
            exchangeHash,
            this.sessionID,
            "B"
          );
          const csKey = generateKEXVal(
            csCipherInfo.keyLen,
            this.hashName,
            secret,
            exchangeHash,
            this.sessionID,
            "C"
          );
          const scKey = generateKEXVal(
            scCipherInfo.keyLen,
            this.hashName,
            secret,
            exchangeHash,
            this.sessionID,
            "D"
          );
          let csMacInfo;
          let csMacKey;
          if (!csCipherInfo.authLen) {
            csMacInfo = MAC_INFO[negotiated.cs.mac];
            csMacKey = generateKEXVal(
              csMacInfo.len,
              this.hashName,
              secret,
              exchangeHash,
              this.sessionID,
              "E"
            );
          }
          let scMacInfo;
          let scMacKey;
          if (!scCipherInfo.authLen) {
            scMacInfo = MAC_INFO[negotiated.sc.mac];
            scMacKey = generateKEXVal(
              scMacInfo.len,
              this.hashName,
              secret,
              exchangeHash,
              this.sessionID,
              "F"
            );
          }
          const config = {
            inbound: {
              onPayload: this._protocol._onPayload,
              seqno: this._protocol._decipher.inSeqno,
              decipherInfo: !isServer ? scCipherInfo : csCipherInfo,
              decipherIV: !isServer ? scIV : csIV,
              decipherKey: !isServer ? scKey : csKey,
              macInfo: !isServer ? scMacInfo : csMacInfo,
              macKey: !isServer ? scMacKey : csMacKey
            },
            outbound: {
              onWrite: this._protocol._onWrite,
              seqno: this._protocol._cipher.outSeqno,
              cipherInfo: isServer ? scCipherInfo : csCipherInfo,
              cipherIV: isServer ? scIV : csIV,
              cipherKey: isServer ? scKey : csKey,
              macInfo: isServer ? scMacInfo : csMacInfo,
              macKey: isServer ? scMacKey : csMacKey
            }
          };
          this._protocol._decipher.free();
          hsCipherConfig = config;
          this._protocol._decipher = createDecipher(config);
          const rw = {
            read: void 0,
            write: void 0
          };
          switch (negotiated.cs.compress) {
            case "zlib":
              if (isServer)
                rw.read = new ZlibPacketReader3();
              else
                rw.write = new ZlibPacketWriter3(this._protocol);
              break;
            case "zlib@openssh.com":
              if (this._protocol._authenticated) {
                if (isServer)
                  rw.read = new ZlibPacketReader3();
                else
                  rw.write = new ZlibPacketWriter3(this._protocol);
                break;
              }
            default:
              if (isServer)
                rw.read = new PacketReader3();
              else
                rw.write = new PacketWriter3(this._protocol);
          }
          switch (negotiated.sc.compress) {
            case "zlib":
              if (isServer)
                rw.write = new ZlibPacketWriter3(this._protocol);
              else
                rw.read = new ZlibPacketReader3();
              break;
            case "zlib@openssh.com":
              if (this._protocol._authenticated) {
                if (isServer)
                  rw.write = new ZlibPacketWriter3(this._protocol);
                else
                  rw.read = new ZlibPacketReader3();
                break;
              }
            default:
              if (isServer)
                rw.write = new PacketWriter3(this._protocol);
              else
                rw.read = new PacketReader3();
          }
          this._protocol._packetRW.read.cleanup();
          this._protocol._packetRW.write.cleanup();
          this._protocol._packetRW.read = rw.read;
          hsWrite = rw.write;
          this._public = null;
          this._dh = null;
          this._kexinit = this._protocol._kexinit = void 0;
          this._remoteKexinit = void 0;
          this._identRaw = void 0;
          this._remoteIdentRaw = void 0;
          this._hostKey = void 0;
          this._dhData = void 0;
          this._sig = void 0;
          if (!partial)
            return completeHandshake();
          return false;
        };
        if (isServer || scOnly)
          this.finish = completeHandshake;
        if (!isServer)
          return completeHandshake(scOnly);
      }
      start() {
        if (!this._protocol._server) {
          if (this._protocol._debug) {
            let type2;
            switch (this.type) {
              case "group":
                type2 = "KEXDH_INIT";
                break;
              default:
                type2 = "KEXECDH_INIT";
            }
            this._protocol._debug(`Outbound: Sending ${type2}`);
          }
          const pubKey = this.getPublicKey();
          let p = this._protocol._packetRW.write.allocStartKEX;
          const packet = this._protocol._packetRW.write.alloc(
            1 + 4 + pubKey.length,
            true
          );
          packet[p] = MESSAGE2.KEXDH_INIT;
          writeUInt32BE2(packet, pubKey.length, ++p);
          packet.set(pubKey, p += 4);
          this._protocol._cipher.encrypt(
            this._protocol._packetRW.write.finalize(packet, true)
          );
        }
      }
      getPublicKey() {
        this.generateKeys();
        const key2 = this._public;
        if (key2)
          return this.convertPublicKey(key2);
      }
      convertPublicKey(key2) {
        let newKey;
        let idx = 0;
        let len = key2.length;
        while (key2[idx] === 0) {
          ++idx;
          --len;
        }
        if (key2[idx] & 128) {
          newKey = Buffer.allocUnsafe(1 + len);
          newKey[0] = 0;
          key2.copy(newKey, 1, idx);
          return newKey;
        }
        if (len !== key2.length) {
          newKey = Buffer.allocUnsafe(len);
          key2.copy(newKey, 0, idx);
          key2 = newKey;
        }
        return key2;
      }
      computeSecret(otherPublicKey) {
        this.generateKeys();
        try {
          return convertToMpint(this._dh.computeSecret(otherPublicKey));
        } catch (ex) {
          return ex;
        }
      }
      parse(payload) {
        const type2 = payload[0];
        switch (this._step) {
          case 1:
            if (this._protocol._server) {
              if (type2 !== MESSAGE2.KEXDH_INIT) {
                return doFatalError2(
                  this._protocol,
                  `Received packet ${type2} instead of ${MESSAGE2.KEXDH_INIT}`,
                  "handshake",
                  DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
                );
              }
              this._protocol._debug && this._protocol._debug(
                "Received DH Init"
              );
              bufferParser2.init(payload, 1);
              const dhData = bufferParser2.readString();
              bufferParser2.clear();
              if (dhData === void 0) {
                return doFatalError2(
                  this._protocol,
                  "Received malformed KEX*_INIT",
                  "handshake",
                  DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
                );
              }
              this._dhData = dhData;
              let hostKey = this._protocol._hostKeys[this.negotiated.serverHostKey];
              if (Array.isArray(hostKey))
                hostKey = hostKey[0];
              this._hostKey = hostKey;
              this.finish();
            } else {
              if (type2 !== MESSAGE2.KEXDH_REPLY) {
                return doFatalError2(
                  this._protocol,
                  `Received packet ${type2} instead of ${MESSAGE2.KEXDH_REPLY}`,
                  "handshake",
                  DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
                );
              }
              this._protocol._debug && this._protocol._debug(
                "Received DH Reply"
              );
              bufferParser2.init(payload, 1);
              let hostPubKey;
              let dhData;
              let sig;
              if ((hostPubKey = bufferParser2.readString()) === void 0 || (dhData = bufferParser2.readString()) === void 0 || (sig = bufferParser2.readString()) === void 0) {
                bufferParser2.clear();
                return doFatalError2(
                  this._protocol,
                  "Received malformed KEX*_REPLY",
                  "handshake",
                  DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
                );
              }
              bufferParser2.clear();
              bufferParser2.init(hostPubKey, 0);
              const hostPubKeyType = bufferParser2.readString(true);
              bufferParser2.clear();
              if (hostPubKeyType === void 0) {
                return doFatalError2(
                  this._protocol,
                  "Received malformed host public key",
                  "handshake",
                  DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
                );
              }
              if (hostPubKeyType !== this.negotiated.serverHostKey) {
                switch (this.negotiated.serverHostKey) {
                  case "rsa-sha2-256":
                  case "rsa-sha2-512":
                    if (hostPubKeyType === "ssh-rsa")
                      break;
                  default:
                    return doFatalError2(
                      this._protocol,
                      "Host key does not match negotiated type",
                      "handshake",
                      DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
                    );
                }
              }
              this._hostKey = hostPubKey;
              this._dhData = dhData;
              this._sig = sig;
              let checked = false;
              let ret;
              if (this._protocol._hostVerifier === void 0) {
                ret = true;
                this._protocol._debug && this._protocol._debug(
                  "Host accepted by default (no verification)"
                );
              } else {
                ret = this._protocol._hostVerifier(hostPubKey, (permitted) => {
                  if (checked)
                    return;
                  checked = true;
                  if (permitted === false) {
                    this._protocol._debug && this._protocol._debug(
                      "Host denied (verification failed)"
                    );
                    return doFatalError2(
                      this._protocol,
                      "Host denied (verification failed)",
                      "handshake",
                      DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
                    );
                  }
                  this._protocol._debug && this._protocol._debug(
                    "Host accepted (verified)"
                  );
                  this._hostVerified = true;
                  if (this._receivedNEWKEYS)
                    this.finish();
                  else
                    trySendNEWKEYS(this);
                });
              }
              if (ret === void 0) {
                ++this._step;
                return;
              }
              checked = true;
              if (ret === false) {
                this._protocol._debug && this._protocol._debug(
                  "Host denied (verification failed)"
                );
                return doFatalError2(
                  this._protocol,
                  "Host denied (verification failed)",
                  "handshake",
                  DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
                );
              }
              this._protocol._debug && this._protocol._debug(
                "Host accepted (verified)"
              );
              this._hostVerified = true;
              trySendNEWKEYS(this);
            }
            ++this._step;
            break;
          case 2:
            if (type2 !== MESSAGE2.NEWKEYS) {
              return doFatalError2(
                this._protocol,
                `Received packet ${type2} instead of ${MESSAGE2.NEWKEYS}`,
                "handshake",
                DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
              );
            }
            this._protocol._debug && this._protocol._debug(
              "Inbound: NEWKEYS"
            );
            this._receivedNEWKEYS = true;
            if (this._protocol._strictMode)
              this._protocol._decipher.inSeqno = 0;
            ++this._step;
            return this.finish(!this._protocol._server && !this._hostVerified);
          default:
            return doFatalError2(
              this._protocol,
              `Received unexpected packet ${type2} after NEWKEYS`,
              "handshake",
              DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
            );
        }
      }
    }
    class Curve25519Exchange extends KeyExchange {
      constructor(hashName, ...args) {
        super(...args);
        this.type = "25519";
        this.hashName = hashName;
        this._keys = null;
      }
      generateKeys() {
        if (!this._keys)
          this._keys = generateKeyPairSync("x25519");
      }
      getPublicKey() {
        this.generateKeys();
        const key2 = this._keys.publicKey.export({ type: "spki", format: "der" });
        return key2.slice(-32);
      }
      convertPublicKey(key2) {
        let newKey;
        let idx = 0;
        let len = key2.length;
        while (key2[idx] === 0) {
          ++idx;
          --len;
        }
        if (key2.length === 32)
          return key2;
        if (len !== key2.length) {
          newKey = Buffer.allocUnsafe(len);
          key2.copy(newKey, 0, idx);
          key2 = newKey;
        }
        return key2;
      }
      computeSecret(otherPublicKey) {
        this.generateKeys();
        try {
          const asnWriter = new Ber2.Writer();
          asnWriter.startSequence();
          asnWriter.startSequence();
          asnWriter.writeOID("1.3.101.110");
          asnWriter.endSequence();
          asnWriter.startSequence(Ber2.BitString);
          asnWriter.writeByte(0);
          asnWriter._ensure(otherPublicKey.length);
          otherPublicKey.copy(
            asnWriter._buf,
            asnWriter._offset,
            0,
            otherPublicKey.length
          );
          asnWriter._offset += otherPublicKey.length;
          asnWriter.endSequence();
          asnWriter.endSequence();
          return convertToMpint(diffieHellman({
            privateKey: this._keys.privateKey,
            publicKey: createPublicKey({
              key: asnWriter.buffer,
              type: "spki",
              format: "der"
            })
          }));
        } catch (ex) {
          return ex;
        }
      }
    }
    class ECDHExchange extends KeyExchange {
      constructor(curveName, hashName, ...args) {
        super(...args);
        this.type = "ecdh";
        this.curveName = curveName;
        this.hashName = hashName;
      }
      generateKeys() {
        if (!this._dh) {
          this._dh = createECDH2(this.curveName);
          this._public = this._dh.generateKeys();
        }
      }
    }
    class DHGroupExchange extends KeyExchange {
      constructor(hashName, ...args) {
        super(...args);
        this.type = "groupex";
        this.hashName = hashName;
        this._prime = null;
        this._generator = null;
        this._minBits = GEX_MIN_BITS;
        this._prefBits = dhEstimate(this.negotiated);
        if (this._protocol._compatFlags & COMPAT2.BUG_DHGEX_LARGE)
          this._prefBits = Math.min(this._prefBits, 4096);
        this._maxBits = GEX_MAX_BITS;
      }
      start() {
        if (this._protocol._server)
          return;
        this._protocol._debug && this._protocol._debug(
          "Outbound: Sending KEXDH_GEX_REQUEST"
        );
        let p = this._protocol._packetRW.write.allocStartKEX;
        const packet = this._protocol._packetRW.write.alloc(
          1 + 4 + 4 + 4,
          true
        );
        packet[p] = MESSAGE2.KEXDH_GEX_REQUEST;
        writeUInt32BE2(packet, this._minBits, ++p);
        writeUInt32BE2(packet, this._prefBits, p += 4);
        writeUInt32BE2(packet, this._maxBits, p += 4);
        this._protocol._cipher.encrypt(
          this._protocol._packetRW.write.finalize(packet, true)
        );
      }
      generateKeys() {
        if (!this._dh && this._prime && this._generator) {
          this._dh = createDiffieHellman(this._prime, this._generator);
          this._public = this._dh.generateKeys();
        }
      }
      setDHParams(prime, generator) {
        if (!Buffer.isBuffer(prime))
          throw new Error("Invalid prime value");
        if (!Buffer.isBuffer(generator))
          throw new Error("Invalid generator value");
        this._prime = prime;
        this._generator = generator;
      }
      getDHParams() {
        if (this._dh) {
          return {
            prime: convertToMpint(this._dh.getPrime()),
            generator: convertToMpint(this._dh.getGenerator())
          };
        }
      }
      parse(payload) {
        const type2 = payload[0];
        switch (this._step) {
          case 1: {
            if (this._protocol._server) {
              if (type2 !== MESSAGE2.KEXDH_GEX_REQUEST) {
                return doFatalError2(
                  this._protocol,
                  `Received packet ${type2} instead of ` + MESSAGE2.KEXDH_GEX_REQUEST,
                  "handshake",
                  DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
                );
              }
              return doFatalError2(
                this._protocol,
                "Group exchange not implemented for server",
                "handshake",
                DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
              );
            }
            if (type2 !== MESSAGE2.KEXDH_GEX_GROUP) {
              return doFatalError2(
                this._protocol,
                `Received packet ${type2} instead of ${MESSAGE2.KEXDH_GEX_GROUP}`,
                "handshake",
                DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
              );
            }
            this._protocol._debug && this._protocol._debug(
              "Received DH GEX Group"
            );
            bufferParser2.init(payload, 1);
            let prime;
            let gen;
            if ((prime = bufferParser2.readString()) === void 0 || (gen = bufferParser2.readString()) === void 0) {
              bufferParser2.clear();
              return doFatalError2(
                this._protocol,
                "Received malformed KEXDH_GEX_GROUP",
                "handshake",
                DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
              );
            }
            bufferParser2.clear();
            this.setDHParams(prime, gen);
            this.generateKeys();
            const pubkey = this.getPublicKey();
            this._protocol._debug && this._protocol._debug(
              "Outbound: Sending KEXDH_GEX_INIT"
            );
            let p = this._protocol._packetRW.write.allocStartKEX;
            const packet = this._protocol._packetRW.write.alloc(1 + 4 + pubkey.length, true);
            packet[p] = MESSAGE2.KEXDH_GEX_INIT;
            writeUInt32BE2(packet, pubkey.length, ++p);
            packet.set(pubkey, p += 4);
            this._protocol._cipher.encrypt(
              this._protocol._packetRW.write.finalize(packet, true)
            );
            ++this._step;
            break;
          }
          case 2:
            if (this._protocol._server) {
              if (type2 !== MESSAGE2.KEXDH_GEX_INIT) {
                return doFatalError2(
                  this._protocol,
                  `Received packet ${type2} instead of ${MESSAGE2.KEXDH_GEX_INIT}`,
                  "handshake",
                  DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
                );
              }
              this._protocol._debug && this._protocol._debug(
                "Received DH GEX Init"
              );
              return doFatalError2(
                this._protocol,
                "Group exchange not implemented for server",
                "handshake",
                DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
              );
            } else if (type2 !== MESSAGE2.KEXDH_GEX_REPLY) {
              return doFatalError2(
                this._protocol,
                `Received packet ${type2} instead of ${MESSAGE2.KEXDH_GEX_REPLY}`,
                "handshake",
                DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
              );
            }
            this._protocol._debug && this._protocol._debug(
              "Received DH GEX Reply"
            );
            this._step = 1;
            payload[0] = MESSAGE2.KEXDH_REPLY;
            this.parse = KeyExchange.prototype.parse;
            this.parse(payload);
        }
      }
    }
    class DHExchange extends KeyExchange {
      constructor(groupName, hashName, ...args) {
        super(...args);
        this.type = "group";
        this.groupName = groupName;
        this.hashName = hashName;
      }
      start() {
        if (!this._protocol._server) {
          this._protocol._debug && this._protocol._debug(
            "Outbound: Sending KEXDH_INIT"
          );
          const pubKey = this.getPublicKey();
          let p = this._protocol._packetRW.write.allocStartKEX;
          const packet = this._protocol._packetRW.write.alloc(1 + 4 + pubKey.length, true);
          packet[p] = MESSAGE2.KEXDH_INIT;
          writeUInt32BE2(packet, pubKey.length, ++p);
          packet.set(pubKey, p += 4);
          this._protocol._cipher.encrypt(
            this._protocol._packetRW.write.finalize(packet, true)
          );
        }
      }
      generateKeys() {
        if (!this._dh) {
          this._dh = createDiffieHellmanGroup(this.groupName);
          this._public = this._dh.generateKeys();
        }
      }
      getDHParams() {
        if (this._dh) {
          return {
            prime: convertToMpint(this._dh.getPrime()),
            generator: convertToMpint(this._dh.getGenerator())
          };
        }
      }
    }
    return (negotiated, ...args) => {
      if (typeof negotiated !== "object" || negotiated === null)
        throw new Error("Invalid negotiated argument");
      const kexType = negotiated.kex;
      if (typeof kexType === "string") {
        args = [negotiated, ...args];
        switch (kexType) {
          case "curve25519-sha256":
          case "curve25519-sha256@libssh.org":
            if (!curve25519Supported)
              break;
            return new Curve25519Exchange("sha256", ...args);
          case "ecdh-sha2-nistp256":
            return new ECDHExchange("prime256v1", "sha256", ...args);
          case "ecdh-sha2-nistp384":
            return new ECDHExchange("secp384r1", "sha384", ...args);
          case "ecdh-sha2-nistp521":
            return new ECDHExchange("secp521r1", "sha512", ...args);
          case "diffie-hellman-group1-sha1":
            return new DHExchange("modp2", "sha1", ...args);
          case "diffie-hellman-group14-sha1":
            return new DHExchange("modp14", "sha1", ...args);
          case "diffie-hellman-group14-sha256":
            return new DHExchange("modp14", "sha256", ...args);
          case "diffie-hellman-group15-sha512":
            return new DHExchange("modp15", "sha512", ...args);
          case "diffie-hellman-group16-sha512":
            return new DHExchange("modp16", "sha512", ...args);
          case "diffie-hellman-group17-sha512":
            return new DHExchange("modp17", "sha512", ...args);
          case "diffie-hellman-group18-sha512":
            return new DHExchange("modp18", "sha512", ...args);
          case "diffie-hellman-group-exchange-sha1":
            return new DHGroupExchange("sha1", ...args);
          case "diffie-hellman-group-exchange-sha256":
            return new DHGroupExchange("sha256", ...args);
        }
        throw new Error(`Unsupported key exchange algorithm: ${kexType}`);
      }
      throw new Error(`Invalid key exchange type: ${kexType}`);
    };
  })();
  const KexInit2 = /* @__PURE__ */ (() => {
    const KEX_PROPERTY_NAMES = [
      "kex",
      "serverHostKey",
      ["cs", "cipher"],
      ["sc", "cipher"],
      ["cs", "mac"],
      ["sc", "mac"],
      ["cs", "compress"],
      ["sc", "compress"],
      ["cs", "lang"],
      ["sc", "lang"]
    ];
    return class KexInit {
      constructor(obj) {
        if (typeof obj !== "object" || obj === null)
          throw new TypeError("Argument must be an object");
        const lists = {
          kex: void 0,
          serverHostKey: void 0,
          cs: {
            cipher: void 0,
            mac: void 0,
            compress: void 0,
            lang: void 0
          },
          sc: {
            cipher: void 0,
            mac: void 0,
            compress: void 0,
            lang: void 0
          },
          all: void 0
        };
        let totalSize = 0;
        for (const prop of KEX_PROPERTY_NAMES) {
          let base;
          let val;
          let desc;
          let key2;
          if (typeof prop === "string") {
            base = lists;
            val = obj[prop];
            desc = key2 = prop;
          } else {
            const parent = prop[0];
            base = lists[parent];
            key2 = prop[1];
            val = obj[parent][key2];
            desc = `${parent}.${key2}`;
          }
          const entry = { array: void 0, buffer: void 0 };
          if (Buffer.isBuffer(val)) {
            entry.array = ("" + val).split(",");
            entry.buffer = val;
            totalSize += 4 + val.length;
          } else {
            if (typeof val === "string")
              val = val.split(",");
            if (Array.isArray(val)) {
              entry.array = val;
              entry.buffer = Buffer.from(val.join(","));
            } else {
              throw new TypeError(`Invalid \`${desc}\` type: ${typeof val}`);
            }
            totalSize += 4 + entry.buffer.length;
          }
          base[key2] = entry;
        }
        const all = Buffer.allocUnsafe(totalSize);
        lists.all = all;
        let allPos = 0;
        for (const prop of KEX_PROPERTY_NAMES) {
          let data;
          if (typeof prop === "string")
            data = lists[prop].buffer;
          else
            data = lists[prop[0]][prop[1]].buffer;
          allPos = writeUInt32BE2(all, data.length, allPos);
          all.set(data, allPos);
          allPos += data.length;
        }
        this.totalSize = totalSize;
        this.lists = lists;
      }
      copyAllTo(buf, offset) {
        const src = this.lists.all;
        if (typeof offset !== "number")
          throw new TypeError(`Invalid offset value: ${typeof offset}`);
        if (buf.length - offset < src.length)
          throw new Error("Insufficient space to copy list");
        buf.set(src, offset);
        return src.length;
      }
    };
  })();
  const hashString = (() => {
    const LEN = Buffer.allocUnsafe(4);
    return (hash, buf) => {
      writeUInt32BE2(LEN, buf.length, 0);
      hash.update(LEN);
      hash.update(buf);
    };
  })();
  function generateKEXVal(len, hashName, secret, exchangeHash, sessionID, char) {
    let ret;
    if (len) {
      let digest = createHash2(hashName).update(secret).update(exchangeHash).update(char).update(sessionID).digest();
      while (digest.length < len) {
        const chunk = createHash2(hashName).update(secret).update(exchangeHash).update(digest).digest();
        const extended = Buffer.allocUnsafe(digest.length + chunk.length);
        extended.set(digest, 0);
        extended.set(chunk, digest.length);
        digest = extended;
      }
      if (digest.length === len)
        ret = digest;
      else
        ret = new FastBuffer2(digest.buffer, digest.byteOffset, len);
    } else {
      ret = EMPTY_BUFFER;
    }
    return ret;
  }
  function onKEXPayload2(state, payload) {
    if (payload.length === 0) {
      this._debug && this._debug("Inbound: Skipping empty packet payload");
      return;
    }
    if (this._skipNextInboundPacket) {
      this._skipNextInboundPacket = false;
      return;
    }
    payload = this._packetRW.read.read(payload);
    const type2 = payload[0];
    if (!this._strictMode) {
      switch (type2) {
        case MESSAGE2.IGNORE:
        case MESSAGE2.UNIMPLEMENTED:
        case MESSAGE2.DEBUG:
          if (!MESSAGE_HANDLERS2)
            MESSAGE_HANDLERS2 = requireHandlers();
          return MESSAGE_HANDLERS2[type2](this, payload);
      }
    }
    switch (type2) {
      case MESSAGE2.DISCONNECT:
        if (!MESSAGE_HANDLERS2)
          MESSAGE_HANDLERS2 = requireHandlers();
        return MESSAGE_HANDLERS2[type2](this, payload);
      case MESSAGE2.KEXINIT:
        if (!state.firstPacket) {
          return doFatalError2(
            this,
            "Received extra KEXINIT during handshake",
            "handshake",
            DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
          );
        }
        state.firstPacket = false;
        return handleKexInit(this, payload);
      default:
        if (type2 < 20 || type2 > 49) {
          return doFatalError2(
            this,
            `Received unexpected packet type ${type2}`,
            "handshake",
            DISCONNECT_REASON2.KEY_EXCHANGE_FAILED
          );
        }
    }
    return this._kex.parse(payload);
  }
  function dhEstimate(neg) {
    const csCipher = CIPHER_INFO2[neg.cs.cipher];
    const scCipher = CIPHER_INFO2[neg.sc.cipher];
    const bits = Math.max(
      0,
      csCipher.sslName === "des-ede3-cbc" ? 14 : csCipher.keyLen,
      csCipher.blockLen,
      csCipher.ivLen,
      scCipher.sslName === "des-ede3-cbc" ? 14 : scCipher.keyLen,
      scCipher.blockLen,
      scCipher.ivLen
    ) * 8;
    if (bits <= 112)
      return 2048;
    if (bits <= 128)
      return 3072;
    if (bits <= 192)
      return 7680;
    return 8192;
  }
  function trySendNEWKEYS(kex2) {
    if (!kex2._sentNEWKEYS) {
      kex2._protocol._debug && kex2._protocol._debug(
        "Outbound: Sending NEWKEYS"
      );
      const p = kex2._protocol._packetRW.write.allocStartKEX;
      const packet = kex2._protocol._packetRW.write.alloc(1, true);
      packet[p] = MESSAGE2.NEWKEYS;
      kex2._protocol._cipher.encrypt(
        kex2._protocol._packetRW.write.finalize(packet, true)
      );
      kex2._sentNEWKEYS = true;
      if (kex2._protocol._strictMode)
        kex2._protocol._cipher.outSeqno = 0;
    }
  }
  kex = {
    KexInit: KexInit2,
    kexinit: kexinit2,
    onKEXPayload: onKEXPayload2,
    DEFAULT_KEXINIT_CLIENT: new KexInit2({
      kex: DEFAULT_KEX2.concat(["ext-info-c", "kex-strict-c-v00@openssh.com"]),
      serverHostKey: DEFAULT_SERVER_HOST_KEY2,
      cs: {
        cipher: DEFAULT_CIPHER2,
        mac: DEFAULT_MAC2,
        compress: DEFAULT_COMPRESSION2,
        lang: []
      },
      sc: {
        cipher: DEFAULT_CIPHER2,
        mac: DEFAULT_MAC2,
        compress: DEFAULT_COMPRESSION2,
        lang: []
      }
    }),
    DEFAULT_KEXINIT_SERVER: new KexInit2({
      kex: DEFAULT_KEX2.concat(["kex-strict-s-v00@openssh.com"]),
      serverHostKey: DEFAULT_SERVER_HOST_KEY2,
      cs: {
        cipher: DEFAULT_CIPHER2,
        mac: DEFAULT_MAC2,
        compress: DEFAULT_COMPRESSION2,
        lang: []
      },
      sc: {
        cipher: DEFAULT_CIPHER2,
        mac: DEFAULT_MAC2,
        compress: DEFAULT_COMPRESSION2,
        lang: []
      }
    }),
    HANDLERS: {
      [MESSAGE2.KEXINIT]: handleKexInit
    }
  };
  return kex;
}
const version = "1.17.0";
const require$$8 = {
  version
};
const { inspect: inspect$1 } = require$$0$1;
const { bindingAvailable, NullCipher, NullDecipher } = requireCrypto();
const {
  COMPAT_CHECKS,
  DISCONNECT_REASON: DISCONNECT_REASON$2,
  eddsaSupported,
  MESSAGE,
  SIGNALS,
  TERMINAL_MODE
} = requireConstants();
const {
  DEFAULT_KEXINIT_CLIENT,
  DEFAULT_KEXINIT_SERVER,
  KexInit: KexInit$1,
  kexinit,
  onKEXPayload
} = requireKex();
const {
  parseKey: parseKey$3
} = keyParser;
const MESSAGE_HANDLERS = requireHandlers();
const {
  bufferCopy: bufferCopy$2,
  bufferFill,
  bufferSlice: bufferSlice$2,
  convertSignature,
  sendPacket,
  writeUInt32BE: writeUInt32BE$3
} = requireUtils();
const {
  PacketReader: PacketReader2,
  PacketWriter: PacketWriter2,
  ZlibPacketReader: ZlibPacketReader2,
  ZlibPacketWriter: ZlibPacketWriter2
} = zlib;
const MODULE_VER = require$$8.version;
const VALID_DISCONNECT_REASONS = new Map(
  Object.values(DISCONNECT_REASON$2).map((n) => [n, 1])
);
const IDENT_RAW = Buffer.from(`SSH-2.0-ssh2js${MODULE_VER}`);
const IDENT = Buffer.from(`${IDENT_RAW}\r
`);
const MAX_LINE_LEN = 8192;
const MAX_LINES = 1024;
const PING_PAYLOAD = Buffer.from([
  MESSAGE.GLOBAL_REQUEST,
  // "keepalive@openssh.com"
  0,
  0,
  0,
  21,
  107,
  101,
  101,
  112,
  97,
  108,
  105,
  118,
  101,
  64,
  111,
  112,
  101,
  110,
  115,
  115,
  104,
  46,
  99,
  111,
  109,
  // Request a reply
  1
]);
const NO_TERMINAL_MODES_BUFFER = Buffer.from([TERMINAL_MODE.TTY_OP_END]);
function noop$3() {
}
let Protocol$2 = class Protocol {
  constructor(config) {
    const onWrite = config.onWrite;
    if (typeof onWrite !== "function")
      throw new Error("Missing onWrite function");
    this._onWrite = (data) => {
      onWrite(data);
    };
    const onError = config.onError;
    if (typeof onError !== "function")
      throw new Error("Missing onError function");
    this._onError = (err) => {
      onError(err);
    };
    const debug2 = config.debug;
    this._debug = typeof debug2 === "function" ? (msg) => {
      debug2(msg);
    } : void 0;
    const onHeader = config.onHeader;
    this._onHeader = typeof onHeader === "function" ? (...args) => {
      onHeader(...args);
    } : noop$3;
    const onPacket = config.onPacket;
    this._onPacket = typeof onPacket === "function" ? () => {
      onPacket();
    } : noop$3;
    let onHandshakeComplete = config.onHandshakeComplete;
    if (typeof onHandshakeComplete !== "function")
      onHandshakeComplete = noop$3;
    let firstHandshake;
    this._onHandshakeComplete = (...args) => {
      this._debug && this._debug("Handshake completed");
      if (firstHandshake === void 0)
        firstHandshake = true;
      else
        firstHandshake = false;
      const oldQueue = this._queue;
      if (oldQueue) {
        this._queue = void 0;
        this._debug && this._debug(
          `Draining outbound queue (${oldQueue.length}) ...`
        );
        for (let i = 0; i < oldQueue.length; ++i) {
          const data = oldQueue[i];
          let finalized = this._packetRW.write.finalize(data);
          if (finalized === data) {
            const packet = this._cipher.allocPacket(data.length);
            packet.set(data, 5);
            finalized = packet;
          }
          sendPacket(this, finalized);
        }
        this._debug && this._debug("... finished draining outbound queue");
      }
      if (firstHandshake && this._server && this._kex.remoteExtInfoEnabled)
        sendExtInfo(this);
      onHandshakeComplete(...args);
    };
    this._queue = void 0;
    const messageHandlers = config.messageHandlers;
    if (typeof messageHandlers === "object" && messageHandlers !== null)
      this._handlers = messageHandlers;
    else
      this._handlers = {};
    this._onPayload = onPayload.bind(this);
    this._server = !!config.server;
    this._banner = void 0;
    let greeting;
    if (this._server) {
      if (typeof config.hostKeys !== "object" || config.hostKeys === null)
        throw new Error("Missing server host key(s)");
      this._hostKeys = config.hostKeys;
      if (typeof config.greeting === "string" && config.greeting.length) {
        greeting = config.greeting.slice(-2) === "\r\n" ? config.greeting : `${config.greeting}\r
`;
      }
      if (typeof config.banner === "string" && config.banner.length) {
        this._banner = config.banner.slice(-2) === "\r\n" ? config.banner : `${config.banner}\r
`;
      }
    } else {
      this._hostKeys = void 0;
    }
    let offer = config.offer;
    if (typeof offer !== "object" || offer === null) {
      offer = this._server ? DEFAULT_KEXINIT_SERVER : DEFAULT_KEXINIT_CLIENT;
    } else if (offer.constructor !== KexInit$1) {
      if (this._server) {
        offer.kex = offer.kex.concat(["kex-strict-s-v00@openssh.com"]);
      } else {
        offer.kex = offer.kex.concat([
          "ext-info-c",
          "kex-strict-c-v00@openssh.com"
        ]);
      }
      offer = new KexInit$1(offer);
    }
    this._kex = void 0;
    this._strictMode = void 0;
    this._kexinit = void 0;
    this._offer = offer;
    this._cipher = new NullCipher(0, this._onWrite);
    this._decipher = void 0;
    this._skipNextInboundPacket = false;
    this._packetRW = {
      read: new PacketReader2(),
      write: new PacketWriter2(this)
    };
    this._hostVerifier = !this._server && typeof config.hostVerifier === "function" ? config.hostVerifier : void 0;
    this._parse = parseHeader;
    this._buffer = void 0;
    this._authsQueue = [];
    this._authenticated = false;
    this._remoteIdentRaw = void 0;
    let sentIdent;
    if (typeof config.ident === "string") {
      this._identRaw = Buffer.from(`SSH-2.0-${config.ident}`);
      sentIdent = Buffer.allocUnsafe(this._identRaw.length + 2);
      sentIdent.set(this._identRaw, 0);
      sentIdent[sentIdent.length - 2] = 13;
      sentIdent[sentIdent.length - 1] = 10;
    } else if (Buffer.isBuffer(config.ident)) {
      const fullIdent = Buffer.allocUnsafe(8 + config.ident.length);
      fullIdent.latin1Write("SSH-2.0-", 0, 8);
      fullIdent.set(config.ident, 8);
      this._identRaw = fullIdent;
      sentIdent = Buffer.allocUnsafe(fullIdent.length + 2);
      sentIdent.set(fullIdent, 0);
      sentIdent[sentIdent.length - 2] = 13;
      sentIdent[sentIdent.length - 1] = 10;
    } else {
      this._identRaw = IDENT_RAW;
      sentIdent = IDENT;
    }
    this._compatFlags = 0;
    if (this._debug) {
      if (bindingAvailable)
        this._debug("Custom crypto binding available");
      else
        this._debug("Custom crypto binding not available");
    }
    this._debug && this._debug(
      `Local ident: ${inspect$1(this._identRaw.toString())}`
    );
    this.start = () => {
      this.start = void 0;
      if (greeting)
        this._onWrite(greeting);
      this._onWrite(sentIdent);
    };
  }
  _destruct(reason) {
    this._packetRW.read.cleanup();
    this._packetRW.write.cleanup();
    this._cipher && this._cipher.free();
    this._decipher && this._decipher.free();
    if (typeof reason !== "string" || reason.length === 0)
      reason = "fatal error";
    this.parse = () => {
      throw new Error(`Instance unusable after ${reason}`);
    };
    this._onWrite = () => {
      throw new Error(`Instance unusable after ${reason}`);
    };
    this._destruct = void 0;
  }
  cleanup() {
    this._destruct && this._destruct();
  }
  parse(chunk, i, len) {
    while (i < len)
      i = this._parse(chunk, i, len);
  }
  // Protocol message API
  // ===========================================================================
  // Common/Shared =============================================================
  // ===========================================================================
  // Global
  // ------
  disconnect(reason) {
    const pktLen = 1 + 4 + 4 + 4;
    let p = this._packetRW.write.allocStartKEX;
    const packet = this._packetRW.write.alloc(pktLen, true);
    const end = p + pktLen;
    if (!VALID_DISCONNECT_REASONS.has(reason))
      reason = DISCONNECT_REASON$2.PROTOCOL_ERROR;
    packet[p] = MESSAGE.DISCONNECT;
    writeUInt32BE$3(packet, reason, ++p);
    packet.fill(0, p += 4, end);
    this._debug && this._debug(`Outbound: Sending DISCONNECT (${reason})`);
    sendPacket(this, this._packetRW.write.finalize(packet, true), true);
  }
  ping() {
    const p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(PING_PAYLOAD.length);
    packet.set(PING_PAYLOAD, p);
    this._debug && this._debug(
      "Outbound: Sending ping (GLOBAL_REQUEST: keepalive@openssh.com)"
    );
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  rekey() {
    if (this._kexinit === void 0) {
      this._debug && this._debug("Outbound: Initiated explicit rekey");
      this._queue = [];
      kexinit(this);
    } else {
      this._debug && this._debug("Outbound: Ignoring rekey during handshake");
    }
  }
  // 'ssh-connection' service-specific
  // ---------------------------------
  requestSuccess(data) {
    let p = this._packetRW.write.allocStart;
    let packet;
    if (Buffer.isBuffer(data)) {
      packet = this._packetRW.write.alloc(1 + data.length);
      packet[p] = MESSAGE.REQUEST_SUCCESS;
      packet.set(data, ++p);
    } else {
      packet = this._packetRW.write.alloc(1);
      packet[p] = MESSAGE.REQUEST_SUCCESS;
    }
    this._debug && this._debug("Outbound: Sending REQUEST_SUCCESS");
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  requestFailure() {
    const p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1);
    packet[p] = MESSAGE.REQUEST_FAILURE;
    this._debug && this._debug("Outbound: Sending REQUEST_FAILURE");
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  channelSuccess(chan) {
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4);
    packet[p] = MESSAGE.CHANNEL_SUCCESS;
    writeUInt32BE$3(packet, chan, ++p);
    this._debug && this._debug(`Outbound: Sending CHANNEL_SUCCESS (r:${chan})`);
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  channelFailure(chan) {
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4);
    packet[p] = MESSAGE.CHANNEL_FAILURE;
    writeUInt32BE$3(packet, chan, ++p);
    this._debug && this._debug(`Outbound: Sending CHANNEL_FAILURE (r:${chan})`);
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  channelEOF(chan) {
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4);
    packet[p] = MESSAGE.CHANNEL_EOF;
    writeUInt32BE$3(packet, chan, ++p);
    this._debug && this._debug(`Outbound: Sending CHANNEL_EOF (r:${chan})`);
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  channelClose(chan) {
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4);
    packet[p] = MESSAGE.CHANNEL_CLOSE;
    writeUInt32BE$3(packet, chan, ++p);
    this._debug && this._debug(`Outbound: Sending CHANNEL_CLOSE (r:${chan})`);
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  channelWindowAdjust(chan, amount) {
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4 + 4);
    packet[p] = MESSAGE.CHANNEL_WINDOW_ADJUST;
    writeUInt32BE$3(packet, chan, ++p);
    writeUInt32BE$3(packet, amount, p += 4);
    this._debug && this._debug(
      `Outbound: Sending CHANNEL_WINDOW_ADJUST (r:${chan}, ${amount})`
    );
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  channelData(chan, data) {
    const isBuffer = Buffer.isBuffer(data);
    const dataLen = isBuffer ? data.length : Buffer.byteLength(data);
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4 + 4 + dataLen);
    packet[p] = MESSAGE.CHANNEL_DATA;
    writeUInt32BE$3(packet, chan, ++p);
    writeUInt32BE$3(packet, dataLen, p += 4);
    if (isBuffer)
      packet.set(data, p += 4);
    else
      packet.utf8Write(data, p += 4, dataLen);
    this._debug && this._debug(
      `Outbound: Sending CHANNEL_DATA (r:${chan}, ${dataLen})`
    );
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  channelExtData(chan, data, type2) {
    const isBuffer = Buffer.isBuffer(data);
    const dataLen = isBuffer ? data.length : Buffer.byteLength(data);
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + dataLen);
    packet[p] = MESSAGE.CHANNEL_EXTENDED_DATA;
    writeUInt32BE$3(packet, chan, ++p);
    writeUInt32BE$3(packet, type2, p += 4);
    writeUInt32BE$3(packet, dataLen, p += 4);
    if (isBuffer)
      packet.set(data, p += 4);
    else
      packet.utf8Write(data, p += 4, dataLen);
    this._debug && this._debug(`Outbound: Sending CHANNEL_EXTENDED_DATA (r:${chan})`);
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  channelOpenConfirm(remote, local, initWindow, maxPacket) {
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 4);
    packet[p] = MESSAGE.CHANNEL_OPEN_CONFIRMATION;
    writeUInt32BE$3(packet, remote, ++p);
    writeUInt32BE$3(packet, local, p += 4);
    writeUInt32BE$3(packet, initWindow, p += 4);
    writeUInt32BE$3(packet, maxPacket, p += 4);
    this._debug && this._debug(
      `Outbound: Sending CHANNEL_OPEN_CONFIRMATION (r:${remote}, l:${local})`
    );
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  channelOpenFail(remote, reason, desc) {
    if (typeof desc !== "string")
      desc = "";
    const descLen = Buffer.byteLength(desc);
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + descLen + 4);
    packet[p] = MESSAGE.CHANNEL_OPEN_FAILURE;
    writeUInt32BE$3(packet, remote, ++p);
    writeUInt32BE$3(packet, reason, p += 4);
    writeUInt32BE$3(packet, descLen, p += 4);
    p += 4;
    if (descLen) {
      packet.utf8Write(desc, p, descLen);
      p += descLen;
    }
    writeUInt32BE$3(packet, 0, p);
    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN_FAILURE (r:${remote})`);
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  // ===========================================================================
  // Client-specific ===========================================================
  // ===========================================================================
  // Global
  // ------
  service(name) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const nameLen = Buffer.byteLength(name);
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4 + nameLen);
    packet[p] = MESSAGE.SERVICE_REQUEST;
    writeUInt32BE$3(packet, nameLen, ++p);
    packet.utf8Write(name, p += 4, nameLen);
    this._debug && this._debug(`Outbound: Sending SERVICE_REQUEST (${name})`);
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  // 'ssh-userauth' service-specific
  // -------------------------------
  authPassword(username, password, newPassword) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const userLen = Buffer.byteLength(username);
    const passLen = Buffer.byteLength(password);
    const newPassLen = newPassword ? Buffer.byteLength(newPassword) : 0;
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(
      1 + 4 + userLen + 4 + 14 + 4 + 8 + 1 + 4 + passLen + (newPassword ? 4 + newPassLen : 0)
    );
    packet[p] = MESSAGE.USERAUTH_REQUEST;
    writeUInt32BE$3(packet, userLen, ++p);
    packet.utf8Write(username, p += 4, userLen);
    writeUInt32BE$3(packet, 14, p += userLen);
    packet.utf8Write("ssh-connection", p += 4, 14);
    writeUInt32BE$3(packet, 8, p += 14);
    packet.utf8Write("password", p += 4, 8);
    packet[p += 8] = newPassword ? 1 : 0;
    writeUInt32BE$3(packet, passLen, ++p);
    if (Buffer.isBuffer(password))
      bufferCopy$2(password, packet, 0, passLen, p += 4);
    else
      packet.utf8Write(password, p += 4, passLen);
    if (newPassword) {
      writeUInt32BE$3(packet, newPassLen, p += passLen);
      if (Buffer.isBuffer(newPassword))
        bufferCopy$2(newPassword, packet, 0, newPassLen, p += 4);
      else
        packet.utf8Write(newPassword, p += 4, newPassLen);
      this._debug && this._debug(
        "Outbound: Sending USERAUTH_REQUEST (changed password)"
      );
    } else {
      this._debug && this._debug(
        "Outbound: Sending USERAUTH_REQUEST (password)"
      );
    }
    this._authsQueue.push("password");
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  authPK(username, pubKey, keyAlgo, cbSign) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    pubKey = parseKey$3(pubKey);
    if (pubKey instanceof Error)
      throw new Error("Invalid key");
    const keyType = pubKey.type;
    pubKey = pubKey.getPublicSSH();
    if (typeof keyAlgo === "function") {
      cbSign = keyAlgo;
      keyAlgo = void 0;
    }
    if (!keyAlgo)
      keyAlgo = keyType;
    const userLen = Buffer.byteLength(username);
    const algoLen = Buffer.byteLength(keyAlgo);
    const pubKeyLen = pubKey.length;
    const sessionID = this._kex.sessionID;
    const sesLen = sessionID.length;
    const payloadLen = (cbSign ? 4 + sesLen : 0) + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen;
    let packet;
    let p;
    if (cbSign) {
      packet = Buffer.allocUnsafe(payloadLen);
      p = 0;
      writeUInt32BE$3(packet, sesLen, p);
      packet.set(sessionID, p += 4);
      p += sesLen;
    } else {
      packet = this._packetRW.write.alloc(payloadLen);
      p = this._packetRW.write.allocStart;
    }
    packet[p] = MESSAGE.USERAUTH_REQUEST;
    writeUInt32BE$3(packet, userLen, ++p);
    packet.utf8Write(username, p += 4, userLen);
    writeUInt32BE$3(packet, 14, p += userLen);
    packet.utf8Write("ssh-connection", p += 4, 14);
    writeUInt32BE$3(packet, 9, p += 14);
    packet.utf8Write("publickey", p += 4, 9);
    packet[p += 9] = cbSign ? 1 : 0;
    writeUInt32BE$3(packet, algoLen, ++p);
    packet.utf8Write(keyAlgo, p += 4, algoLen);
    writeUInt32BE$3(packet, pubKeyLen, p += algoLen);
    packet.set(pubKey, p += 4);
    if (!cbSign) {
      this._authsQueue.push("publickey");
      this._debug && this._debug(
        "Outbound: Sending USERAUTH_REQUEST (publickey -- check)"
      );
      sendPacket(this, this._packetRW.write.finalize(packet));
      return;
    }
    cbSign(packet, (signature) => {
      signature = convertSignature(signature, keyType);
      if (signature === false)
        throw new Error("Error while converting handshake signature");
      const sigLen = signature.length;
      p = this._packetRW.write.allocStart;
      packet = this._packetRW.write.alloc(
        1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen + 4 + 4 + algoLen + 4 + sigLen
      );
      packet[p] = MESSAGE.USERAUTH_REQUEST;
      writeUInt32BE$3(packet, userLen, ++p);
      packet.utf8Write(username, p += 4, userLen);
      writeUInt32BE$3(packet, 14, p += userLen);
      packet.utf8Write("ssh-connection", p += 4, 14);
      writeUInt32BE$3(packet, 9, p += 14);
      packet.utf8Write("publickey", p += 4, 9);
      packet[p += 9] = 1;
      writeUInt32BE$3(packet, algoLen, ++p);
      packet.utf8Write(keyAlgo, p += 4, algoLen);
      writeUInt32BE$3(packet, pubKeyLen, p += algoLen);
      packet.set(pubKey, p += 4);
      writeUInt32BE$3(packet, 4 + algoLen + 4 + sigLen, p += pubKeyLen);
      writeUInt32BE$3(packet, algoLen, p += 4);
      packet.utf8Write(keyAlgo, p += 4, algoLen);
      writeUInt32BE$3(packet, sigLen, p += algoLen);
      packet.set(signature, p += 4);
      this._authsQueue.push("publickey");
      this._debug && this._debug(
        "Outbound: Sending USERAUTH_REQUEST (publickey)"
      );
      sendPacket(this, this._packetRW.write.finalize(packet));
    });
  }
  authHostbased(username, pubKey, hostname, userlocal, keyAlgo, cbSign) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    pubKey = parseKey$3(pubKey);
    if (pubKey instanceof Error)
      throw new Error("Invalid key");
    const keyType = pubKey.type;
    pubKey = pubKey.getPublicSSH();
    if (typeof keyAlgo === "function") {
      cbSign = keyAlgo;
      keyAlgo = void 0;
    }
    if (!keyAlgo)
      keyAlgo = keyType;
    const userLen = Buffer.byteLength(username);
    const algoLen = Buffer.byteLength(keyAlgo);
    const pubKeyLen = pubKey.length;
    const sessionID = this._kex.sessionID;
    const sesLen = sessionID.length;
    const hostnameLen = Buffer.byteLength(hostname);
    const userlocalLen = Buffer.byteLength(userlocal);
    const data = Buffer.allocUnsafe(
      4 + sesLen + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 4 + algoLen + 4 + pubKeyLen + 4 + hostnameLen + 4 + userlocalLen
    );
    let p = 0;
    writeUInt32BE$3(data, sesLen, p);
    data.set(sessionID, p += 4);
    data[p += sesLen] = MESSAGE.USERAUTH_REQUEST;
    writeUInt32BE$3(data, userLen, ++p);
    data.utf8Write(username, p += 4, userLen);
    writeUInt32BE$3(data, 14, p += userLen);
    data.utf8Write("ssh-connection", p += 4, 14);
    writeUInt32BE$3(data, 9, p += 14);
    data.utf8Write("hostbased", p += 4, 9);
    writeUInt32BE$3(data, algoLen, p += 9);
    data.utf8Write(keyAlgo, p += 4, algoLen);
    writeUInt32BE$3(data, pubKeyLen, p += algoLen);
    data.set(pubKey, p += 4);
    writeUInt32BE$3(data, hostnameLen, p += pubKeyLen);
    data.utf8Write(hostname, p += 4, hostnameLen);
    writeUInt32BE$3(data, userlocalLen, p += hostnameLen);
    data.utf8Write(userlocal, p += 4, userlocalLen);
    cbSign(data, (signature) => {
      signature = convertSignature(signature, keyType);
      if (!signature)
        throw new Error("Error while converting handshake signature");
      const sigLen = signature.length;
      const reqDataLen = data.length - sesLen - 4;
      p = this._packetRW.write.allocStart;
      const packet = this._packetRW.write.alloc(
        reqDataLen + 4 + 4 + algoLen + 4 + sigLen
      );
      bufferCopy$2(data, packet, 4 + sesLen, data.length, p);
      writeUInt32BE$3(packet, 4 + algoLen + 4 + sigLen, p += reqDataLen);
      writeUInt32BE$3(packet, algoLen, p += 4);
      packet.utf8Write(keyAlgo, p += 4, algoLen);
      writeUInt32BE$3(packet, sigLen, p += algoLen);
      packet.set(signature, p += 4);
      this._authsQueue.push("hostbased");
      this._debug && this._debug(
        "Outbound: Sending USERAUTH_REQUEST (hostbased)"
      );
      sendPacket(this, this._packetRW.write.finalize(packet));
    });
  }
  authKeyboard(username) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const userLen = Buffer.byteLength(username);
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(
      1 + 4 + userLen + 4 + 14 + 4 + 20 + 4 + 4
    );
    packet[p] = MESSAGE.USERAUTH_REQUEST;
    writeUInt32BE$3(packet, userLen, ++p);
    packet.utf8Write(username, p += 4, userLen);
    writeUInt32BE$3(packet, 14, p += userLen);
    packet.utf8Write("ssh-connection", p += 4, 14);
    writeUInt32BE$3(packet, 20, p += 14);
    packet.utf8Write("keyboard-interactive", p += 4, 20);
    writeUInt32BE$3(packet, 0, p += 20);
    writeUInt32BE$3(packet, 0, p += 4);
    this._authsQueue.push("keyboard-interactive");
    this._debug && this._debug(
      "Outbound: Sending USERAUTH_REQUEST (keyboard-interactive)"
    );
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  authNone(username) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const userLen = Buffer.byteLength(username);
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 4);
    packet[p] = MESSAGE.USERAUTH_REQUEST;
    writeUInt32BE$3(packet, userLen, ++p);
    packet.utf8Write(username, p += 4, userLen);
    writeUInt32BE$3(packet, 14, p += userLen);
    packet.utf8Write("ssh-connection", p += 4, 14);
    writeUInt32BE$3(packet, 4, p += 14);
    packet.utf8Write("none", p += 4, 4);
    this._authsQueue.push("none");
    this._debug && this._debug("Outbound: Sending USERAUTH_REQUEST (none)");
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  authInfoRes(responses) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    let responsesTotalLen = 0;
    let responseLens;
    if (responses) {
      responseLens = new Array(responses.length);
      for (let i = 0; i < responses.length; ++i) {
        const len = Buffer.byteLength(responses[i]);
        responseLens[i] = len;
        responsesTotalLen += 4 + len;
      }
    }
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4 + responsesTotalLen);
    packet[p] = MESSAGE.USERAUTH_INFO_RESPONSE;
    if (responses) {
      writeUInt32BE$3(packet, responses.length, ++p);
      p += 4;
      for (let i = 0; i < responses.length; ++i) {
        const len = responseLens[i];
        writeUInt32BE$3(packet, len, p);
        p += 4;
        if (len) {
          packet.utf8Write(responses[i], p, len);
          p += len;
        }
      }
    } else {
      writeUInt32BE$3(packet, 0, ++p);
    }
    this._debug && this._debug("Outbound: Sending USERAUTH_INFO_RESPONSE");
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  // 'ssh-connection' service-specific
  // ---------------------------------
  tcpipForward(bindAddr, bindPort, wantReply) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const addrLen = Buffer.byteLength(bindAddr);
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4 + 13 + 1 + 4 + addrLen + 4);
    packet[p] = MESSAGE.GLOBAL_REQUEST;
    writeUInt32BE$3(packet, 13, ++p);
    packet.utf8Write("tcpip-forward", p += 4, 13);
    packet[p += 13] = wantReply === void 0 || wantReply === true ? 1 : 0;
    writeUInt32BE$3(packet, addrLen, ++p);
    packet.utf8Write(bindAddr, p += 4, addrLen);
    writeUInt32BE$3(packet, bindPort, p += addrLen);
    this._debug && this._debug("Outbound: Sending GLOBAL_REQUEST (tcpip-forward)");
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  cancelTcpipForward(bindAddr, bindPort, wantReply) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const addrLen = Buffer.byteLength(bindAddr);
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4 + 20 + 1 + 4 + addrLen + 4);
    packet[p] = MESSAGE.GLOBAL_REQUEST;
    writeUInt32BE$3(packet, 20, ++p);
    packet.utf8Write("cancel-tcpip-forward", p += 4, 20);
    packet[p += 20] = wantReply === void 0 || wantReply === true ? 1 : 0;
    writeUInt32BE$3(packet, addrLen, ++p);
    packet.utf8Write(bindAddr, p += 4, addrLen);
    writeUInt32BE$3(packet, bindPort, p += addrLen);
    this._debug && this._debug("Outbound: Sending GLOBAL_REQUEST (cancel-tcpip-forward)");
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  openssh_streamLocalForward(socketPath, wantReply) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const socketPathLen = Buffer.byteLength(socketPath);
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(
      1 + 4 + 31 + 1 + 4 + socketPathLen
    );
    packet[p] = MESSAGE.GLOBAL_REQUEST;
    writeUInt32BE$3(packet, 31, ++p);
    packet.utf8Write("streamlocal-forward@openssh.com", p += 4, 31);
    packet[p += 31] = wantReply === void 0 || wantReply === true ? 1 : 0;
    writeUInt32BE$3(packet, socketPathLen, ++p);
    packet.utf8Write(socketPath, p += 4, socketPathLen);
    this._debug && this._debug(
      "Outbound: Sending GLOBAL_REQUEST (streamlocal-forward@openssh.com)"
    );
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  openssh_cancelStreamLocalForward(socketPath, wantReply) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const socketPathLen = Buffer.byteLength(socketPath);
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(
      1 + 4 + 38 + 1 + 4 + socketPathLen
    );
    packet[p] = MESSAGE.GLOBAL_REQUEST;
    writeUInt32BE$3(packet, 38, ++p);
    packet.utf8Write("cancel-streamlocal-forward@openssh.com", p += 4, 38);
    packet[p += 38] = wantReply === void 0 || wantReply === true ? 1 : 0;
    writeUInt32BE$3(packet, socketPathLen, ++p);
    packet.utf8Write(socketPath, p += 4, socketPathLen);
    if (this._debug) {
      this._debug(
        "Outbound: Sending GLOBAL_REQUEST (cancel-streamlocal-forward@openssh.com)"
      );
    }
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  directTcpip(chan, initWindow, maxPacket, cfg) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const srcLen = Buffer.byteLength(cfg.srcIP);
    const dstLen = Buffer.byteLength(cfg.dstIP);
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(
      1 + 4 + 12 + 4 + 4 + 4 + 4 + srcLen + 4 + 4 + dstLen + 4
    );
    packet[p] = MESSAGE.CHANNEL_OPEN;
    writeUInt32BE$3(packet, 12, ++p);
    packet.utf8Write("direct-tcpip", p += 4, 12);
    writeUInt32BE$3(packet, chan, p += 12);
    writeUInt32BE$3(packet, initWindow, p += 4);
    writeUInt32BE$3(packet, maxPacket, p += 4);
    writeUInt32BE$3(packet, dstLen, p += 4);
    packet.utf8Write(cfg.dstIP, p += 4, dstLen);
    writeUInt32BE$3(packet, cfg.dstPort, p += dstLen);
    writeUInt32BE$3(packet, srcLen, p += 4);
    packet.utf8Write(cfg.srcIP, p += 4, srcLen);
    writeUInt32BE$3(packet, cfg.srcPort, p += srcLen);
    this._debug && this._debug(
      `Outbound: Sending CHANNEL_OPEN (r:${chan}, direct-tcpip)`
    );
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  openssh_directStreamLocal(chan, initWindow, maxPacket, cfg) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const pathLen = Buffer.byteLength(cfg.socketPath);
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(
      1 + 4 + 30 + 4 + 4 + 4 + 4 + pathLen + 4 + 4
    );
    packet[p] = MESSAGE.CHANNEL_OPEN;
    writeUInt32BE$3(packet, 30, ++p);
    packet.utf8Write("direct-streamlocal@openssh.com", p += 4, 30);
    writeUInt32BE$3(packet, chan, p += 30);
    writeUInt32BE$3(packet, initWindow, p += 4);
    writeUInt32BE$3(packet, maxPacket, p += 4);
    writeUInt32BE$3(packet, pathLen, p += 4);
    packet.utf8Write(cfg.socketPath, p += 4, pathLen);
    bufferFill(packet, 0, p += pathLen, p + 8);
    if (this._debug) {
      this._debug(
        `Outbound: Sending CHANNEL_OPEN (r:${chan}, direct-streamlocal@openssh.com)`
      );
    }
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  openssh_noMoreSessions(wantReply) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4 + 28 + 1);
    packet[p] = MESSAGE.GLOBAL_REQUEST;
    writeUInt32BE$3(packet, 28, ++p);
    packet.utf8Write("no-more-sessions@openssh.com", p += 4, 28);
    packet[p += 28] = wantReply === void 0 || wantReply === true ? 1 : 0;
    this._debug && this._debug(
      "Outbound: Sending GLOBAL_REQUEST (no-more-sessions@openssh.com)"
    );
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  session(chan, initWindow, maxPacket) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4 + 7 + 4 + 4 + 4);
    packet[p] = MESSAGE.CHANNEL_OPEN;
    writeUInt32BE$3(packet, 7, ++p);
    packet.utf8Write("session", p += 4, 7);
    writeUInt32BE$3(packet, chan, p += 7);
    writeUInt32BE$3(packet, initWindow, p += 4);
    writeUInt32BE$3(packet, maxPacket, p += 4);
    this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, session)`);
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  windowChange(chan, rows, cols, height, width) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(
      1 + 4 + 4 + 13 + 1 + 4 + 4 + 4 + 4
    );
    packet[p] = MESSAGE.CHANNEL_REQUEST;
    writeUInt32BE$3(packet, chan, ++p);
    writeUInt32BE$3(packet, 13, p += 4);
    packet.utf8Write("window-change", p += 4, 13);
    packet[p += 13] = 0;
    writeUInt32BE$3(packet, cols, ++p);
    writeUInt32BE$3(packet, rows, p += 4);
    writeUInt32BE$3(packet, width, p += 4);
    writeUInt32BE$3(packet, height, p += 4);
    this._debug && this._debug(
      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, window-change)`
    );
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  pty(chan, rows, cols, height, width, term, modes, wantReply) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    if (!term || !term.length)
      term = "vt100";
    if (modes && !Buffer.isBuffer(modes) && !Array.isArray(modes) && typeof modes === "object" && modes !== null) {
      modes = modesToBytes(modes);
    }
    if (!modes || !modes.length)
      modes = NO_TERMINAL_MODES_BUFFER;
    const termLen = term.length;
    const modesLen = modes.length;
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(
      1 + 4 + 4 + 7 + 1 + 4 + termLen + 4 + 4 + 4 + 4 + 4 + modesLen
    );
    packet[p] = MESSAGE.CHANNEL_REQUEST;
    writeUInt32BE$3(packet, chan, ++p);
    writeUInt32BE$3(packet, 7, p += 4);
    packet.utf8Write("pty-req", p += 4, 7);
    packet[p += 7] = wantReply === void 0 || wantReply === true ? 1 : 0;
    writeUInt32BE$3(packet, termLen, ++p);
    packet.utf8Write(term, p += 4, termLen);
    writeUInt32BE$3(packet, cols, p += termLen);
    writeUInt32BE$3(packet, rows, p += 4);
    writeUInt32BE$3(packet, width, p += 4);
    writeUInt32BE$3(packet, height, p += 4);
    writeUInt32BE$3(packet, modesLen, p += 4);
    p += 4;
    if (Array.isArray(modes)) {
      for (let i = 0; i < modesLen; ++i)
        packet[p++] = modes[i];
    } else if (Buffer.isBuffer(modes)) {
      packet.set(modes, p);
    }
    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, pty-req)`);
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  shell(chan, wantReply) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 5 + 1);
    packet[p] = MESSAGE.CHANNEL_REQUEST;
    writeUInt32BE$3(packet, chan, ++p);
    writeUInt32BE$3(packet, 5, p += 4);
    packet.utf8Write("shell", p += 4, 5);
    packet[p += 5] = wantReply === void 0 || wantReply === true ? 1 : 0;
    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, shell)`);
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  exec(chan, cmd, wantReply) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const isBuf = Buffer.isBuffer(cmd);
    const cmdLen = isBuf ? cmd.length : Buffer.byteLength(cmd);
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 1 + 4 + cmdLen);
    packet[p] = MESSAGE.CHANNEL_REQUEST;
    writeUInt32BE$3(packet, chan, ++p);
    writeUInt32BE$3(packet, 4, p += 4);
    packet.utf8Write("exec", p += 4, 4);
    packet[p += 4] = wantReply === void 0 || wantReply === true ? 1 : 0;
    writeUInt32BE$3(packet, cmdLen, ++p);
    if (isBuf)
      packet.set(cmd, p += 4);
    else
      packet.utf8Write(cmd, p += 4, cmdLen);
    this._debug && this._debug(
      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exec: ${cmd})`
    );
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  signal(chan, signal) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const origSignal = signal;
    signal = signal.toUpperCase();
    if (signal.slice(0, 3) === "SIG")
      signal = signal.slice(3);
    if (SIGNALS[signal] !== 1)
      throw new Error(`Invalid signal: ${origSignal}`);
    const signalLen = signal.length;
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(
      1 + 4 + 4 + 6 + 1 + 4 + signalLen
    );
    packet[p] = MESSAGE.CHANNEL_REQUEST;
    writeUInt32BE$3(packet, chan, ++p);
    writeUInt32BE$3(packet, 6, p += 4);
    packet.utf8Write("signal", p += 4, 6);
    packet[p += 6] = 0;
    writeUInt32BE$3(packet, signalLen, ++p);
    packet.utf8Write(signal, p += 4, signalLen);
    this._debug && this._debug(
      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, signal: ${signal})`
    );
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  env(chan, key2, val, wantReply) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const keyLen = Buffer.byteLength(key2);
    const isBuf = Buffer.isBuffer(val);
    const valLen = isBuf ? val.length : Buffer.byteLength(val);
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(
      1 + 4 + 4 + 3 + 1 + 4 + keyLen + 4 + valLen
    );
    packet[p] = MESSAGE.CHANNEL_REQUEST;
    writeUInt32BE$3(packet, chan, ++p);
    writeUInt32BE$3(packet, 3, p += 4);
    packet.utf8Write("env", p += 4, 3);
    packet[p += 3] = wantReply === void 0 || wantReply === true ? 1 : 0;
    writeUInt32BE$3(packet, keyLen, ++p);
    packet.utf8Write(key2, p += 4, keyLen);
    writeUInt32BE$3(packet, valLen, p += keyLen);
    if (isBuf)
      packet.set(val, p += 4);
    else
      packet.utf8Write(val, p += 4, valLen);
    this._debug && this._debug(
      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, env: ${key2}=${val})`
    );
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  x11Forward(chan, cfg, wantReply) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const protocol = cfg.protocol;
    const cookie = cfg.cookie;
    const isBufProto = Buffer.isBuffer(protocol);
    const protoLen = isBufProto ? protocol.length : Buffer.byteLength(protocol);
    const isBufCookie = Buffer.isBuffer(cookie);
    const cookieLen = isBufCookie ? cookie.length : Buffer.byteLength(cookie);
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(
      1 + 4 + 4 + 7 + 1 + 1 + 4 + protoLen + 4 + cookieLen + 4
    );
    packet[p] = MESSAGE.CHANNEL_REQUEST;
    writeUInt32BE$3(packet, chan, ++p);
    writeUInt32BE$3(packet, 7, p += 4);
    packet.utf8Write("x11-req", p += 4, 7);
    packet[p += 7] = wantReply === void 0 || wantReply === true ? 1 : 0;
    packet[++p] = cfg.single ? 1 : 0;
    writeUInt32BE$3(packet, protoLen, ++p);
    if (isBufProto)
      packet.set(protocol, p += 4);
    else
      packet.utf8Write(protocol, p += 4, protoLen);
    writeUInt32BE$3(packet, cookieLen, p += protoLen);
    if (isBufCookie)
      packet.set(cookie, p += 4);
    else
      packet.latin1Write(cookie, p += 4, cookieLen);
    writeUInt32BE$3(packet, cfg.screen || 0, p += cookieLen);
    this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, x11-req)`);
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  subsystem(chan, name, wantReply) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const nameLen = Buffer.byteLength(name);
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 9 + 1 + 4 + nameLen);
    packet[p] = MESSAGE.CHANNEL_REQUEST;
    writeUInt32BE$3(packet, chan, ++p);
    writeUInt32BE$3(packet, 9, p += 4);
    packet.utf8Write("subsystem", p += 4, 9);
    packet[p += 9] = wantReply === void 0 || wantReply === true ? 1 : 0;
    writeUInt32BE$3(packet, nameLen, ++p);
    packet.utf8Write(name, p += 4, nameLen);
    this._debug && this._debug(
      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, subsystem: ${name})`
    );
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  openssh_agentForward(chan, wantReply) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 26 + 1);
    packet[p] = MESSAGE.CHANNEL_REQUEST;
    writeUInt32BE$3(packet, chan, ++p);
    writeUInt32BE$3(packet, 26, p += 4);
    packet.utf8Write("auth-agent-req@openssh.com", p += 4, 26);
    packet[p += 26] = wantReply === void 0 || wantReply === true ? 1 : 0;
    if (this._debug) {
      this._debug(
        `Outbound: Sending CHANNEL_REQUEST (r:${chan}, auth-agent-req@openssh.com)`
      );
    }
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  openssh_hostKeysProve(keys) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    let keysTotal = 0;
    const publicKeys = [];
    for (const key2 of keys) {
      const publicKey = key2.getPublicSSH();
      keysTotal += 4 + publicKey.length;
      publicKeys.push(publicKey);
    }
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4 + 29 + 1 + keysTotal);
    packet[p] = MESSAGE.GLOBAL_REQUEST;
    writeUInt32BE$3(packet, 29, ++p);
    packet.utf8Write("hostkeys-prove-00@openssh.com", p += 4, 29);
    packet[p += 29] = 1;
    ++p;
    for (const buf of publicKeys) {
      writeUInt32BE$3(packet, buf.length, p);
      bufferCopy$2(buf, packet, 0, buf.length, p += 4);
      p += buf.length;
    }
    if (this._debug) {
      this._debug(
        "Outbound: Sending GLOBAL_REQUEST (hostkeys-prove-00@openssh.com)"
      );
    }
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  // ===========================================================================
  // Server-specific ===========================================================
  // ===========================================================================
  // Global
  // ------
  serviceAccept(svcName) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    const svcNameLen = Buffer.byteLength(svcName);
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4 + svcNameLen);
    packet[p] = MESSAGE.SERVICE_ACCEPT;
    writeUInt32BE$3(packet, svcNameLen, ++p);
    packet.utf8Write(svcName, p += 4, svcNameLen);
    this._debug && this._debug(`Outbound: Sending SERVICE_ACCEPT (${svcName})`);
    sendPacket(this, this._packetRW.write.finalize(packet));
    if (this._server && this._banner && svcName === "ssh-userauth") {
      const banner = this._banner;
      this._banner = void 0;
      const bannerLen = Buffer.byteLength(banner);
      p = this._packetRW.write.allocStart;
      const packet2 = this._packetRW.write.alloc(1 + 4 + bannerLen + 4);
      packet2[p] = MESSAGE.USERAUTH_BANNER;
      writeUInt32BE$3(packet2, bannerLen, ++p);
      packet2.utf8Write(banner, p += 4, bannerLen);
      writeUInt32BE$3(packet2, 0, p += bannerLen);
      this._debug && this._debug("Outbound: Sending USERAUTH_BANNER");
      sendPacket(this, this._packetRW.write.finalize(packet2));
    }
  }
  // 'ssh-connection' service-specific
  forwardedTcpip(chan, initWindow, maxPacket, cfg) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    const boundAddrLen = Buffer.byteLength(cfg.boundAddr);
    const remoteAddrLen = Buffer.byteLength(cfg.remoteAddr);
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(
      1 + 4 + 15 + 4 + 4 + 4 + 4 + boundAddrLen + 4 + 4 + remoteAddrLen + 4
    );
    packet[p] = MESSAGE.CHANNEL_OPEN;
    writeUInt32BE$3(packet, 15, ++p);
    packet.utf8Write("forwarded-tcpip", p += 4, 15);
    writeUInt32BE$3(packet, chan, p += 15);
    writeUInt32BE$3(packet, initWindow, p += 4);
    writeUInt32BE$3(packet, maxPacket, p += 4);
    writeUInt32BE$3(packet, boundAddrLen, p += 4);
    packet.utf8Write(cfg.boundAddr, p += 4, boundAddrLen);
    writeUInt32BE$3(packet, cfg.boundPort, p += boundAddrLen);
    writeUInt32BE$3(packet, remoteAddrLen, p += 4);
    packet.utf8Write(cfg.remoteAddr, p += 4, remoteAddrLen);
    writeUInt32BE$3(packet, cfg.remotePort, p += remoteAddrLen);
    this._debug && this._debug(
      `Outbound: Sending CHANNEL_OPEN (r:${chan}, forwarded-tcpip)`
    );
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  x11(chan, initWindow, maxPacket, cfg) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    const addrLen = Buffer.byteLength(cfg.originAddr);
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(
      1 + 4 + 3 + 4 + 4 + 4 + 4 + addrLen + 4
    );
    packet[p] = MESSAGE.CHANNEL_OPEN;
    writeUInt32BE$3(packet, 3, ++p);
    packet.utf8Write("x11", p += 4, 3);
    writeUInt32BE$3(packet, chan, p += 3);
    writeUInt32BE$3(packet, initWindow, p += 4);
    writeUInt32BE$3(packet, maxPacket, p += 4);
    writeUInt32BE$3(packet, addrLen, p += 4);
    packet.utf8Write(cfg.originAddr, p += 4, addrLen);
    writeUInt32BE$3(packet, cfg.originPort, p += addrLen);
    this._debug && this._debug(
      `Outbound: Sending CHANNEL_OPEN (r:${chan}, x11)`
    );
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  openssh_authAgent(chan, initWindow, maxPacket) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4 + 22 + 4 + 4 + 4);
    packet[p] = MESSAGE.CHANNEL_OPEN;
    writeUInt32BE$3(packet, 22, ++p);
    packet.utf8Write("auth-agent@openssh.com", p += 4, 22);
    writeUInt32BE$3(packet, chan, p += 22);
    writeUInt32BE$3(packet, initWindow, p += 4);
    writeUInt32BE$3(packet, maxPacket, p += 4);
    this._debug && this._debug(
      `Outbound: Sending CHANNEL_OPEN (r:${chan}, auth-agent@openssh.com)`
    );
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  openssh_forwardedStreamLocal(chan, initWindow, maxPacket, cfg) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    const pathLen = Buffer.byteLength(cfg.socketPath);
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(
      1 + 4 + 33 + 4 + 4 + 4 + 4 + pathLen + 4
    );
    packet[p] = MESSAGE.CHANNEL_OPEN;
    writeUInt32BE$3(packet, 33, ++p);
    packet.utf8Write("forwarded-streamlocal@openssh.com", p += 4, 33);
    writeUInt32BE$3(packet, chan, p += 33);
    writeUInt32BE$3(packet, initWindow, p += 4);
    writeUInt32BE$3(packet, maxPacket, p += 4);
    writeUInt32BE$3(packet, pathLen, p += 4);
    packet.utf8Write(cfg.socketPath, p += 4, pathLen);
    writeUInt32BE$3(packet, 0, p += pathLen);
    if (this._debug) {
      this._debug(
        `Outbound: Sending CHANNEL_OPEN (r:${chan}, forwarded-streamlocal@openssh.com)`
      );
    }
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  exitStatus(chan, status) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4 + 4 + 11 + 1 + 4);
    packet[p] = MESSAGE.CHANNEL_REQUEST;
    writeUInt32BE$3(packet, chan, ++p);
    writeUInt32BE$3(packet, 11, p += 4);
    packet.utf8Write("exit-status", p += 4, 11);
    packet[p += 11] = 0;
    writeUInt32BE$3(packet, status, ++p);
    this._debug && this._debug(
      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-status: ${status})`
    );
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  exitSignal(chan, name, coreDumped, msg) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    const origSignal = name;
    if (typeof origSignal !== "string" || !origSignal)
      throw new Error(`Invalid signal: ${origSignal}`);
    let signal = name.toUpperCase();
    if (signal.slice(0, 3) === "SIG")
      signal = signal.slice(3);
    if (SIGNALS[signal] !== 1)
      throw new Error(`Invalid signal: ${origSignal}`);
    const nameLen = Buffer.byteLength(signal);
    const msgLen = msg ? Buffer.byteLength(msg) : 0;
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(
      1 + 4 + 4 + 11 + 1 + 4 + nameLen + 1 + 4 + msgLen + 4
    );
    packet[p] = MESSAGE.CHANNEL_REQUEST;
    writeUInt32BE$3(packet, chan, ++p);
    writeUInt32BE$3(packet, 11, p += 4);
    packet.utf8Write("exit-signal", p += 4, 11);
    packet[p += 11] = 0;
    writeUInt32BE$3(packet, nameLen, ++p);
    packet.utf8Write(signal, p += 4, nameLen);
    packet[p += nameLen] = coreDumped ? 1 : 0;
    writeUInt32BE$3(packet, msgLen, ++p);
    p += 4;
    if (msgLen) {
      packet.utf8Write(msg, p, msgLen);
      p += msgLen;
    }
    writeUInt32BE$3(packet, 0, p);
    this._debug && this._debug(
      `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-signal: ${name})`
    );
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  // 'ssh-userauth' service-specific
  authFailure(authMethods, isPartial) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    if (this._authsQueue.length === 0)
      throw new Error("No auth in progress");
    let methods;
    if (typeof authMethods === "boolean") {
      isPartial = authMethods;
      authMethods = void 0;
    }
    if (authMethods) {
      methods = [];
      for (let i = 0; i < authMethods.length; ++i) {
        if (authMethods[i].toLowerCase() === "none")
          continue;
        methods.push(authMethods[i]);
      }
      methods = methods.join(",");
    } else {
      methods = "";
    }
    const methodsLen = methods.length;
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4 + methodsLen + 1);
    packet[p] = MESSAGE.USERAUTH_FAILURE;
    writeUInt32BE$3(packet, methodsLen, ++p);
    packet.utf8Write(methods, p += 4, methodsLen);
    packet[p += methodsLen] = isPartial === true ? 1 : 0;
    this._authsQueue.shift();
    this._debug && this._debug("Outbound: Sending USERAUTH_FAILURE");
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  authSuccess() {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    if (this._authsQueue.length === 0)
      throw new Error("No auth in progress");
    const p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1);
    packet[p] = MESSAGE.USERAUTH_SUCCESS;
    this._authsQueue.shift();
    this._authenticated = true;
    this._debug && this._debug("Outbound: Sending USERAUTH_SUCCESS");
    sendPacket(this, this._packetRW.write.finalize(packet));
    if (this._kex.negotiated.cs.compress === "zlib@openssh.com")
      this._packetRW.read = new ZlibPacketReader2();
    if (this._kex.negotiated.sc.compress === "zlib@openssh.com")
      this._packetRW.write = new ZlibPacketWriter2(this);
  }
  authPKOK(keyAlgo, key2) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    if (this._authsQueue.length === 0 || this._authsQueue[0] !== "publickey")
      throw new Error('"publickey" auth not in progress');
    const keyAlgoLen = Buffer.byteLength(keyAlgo);
    const keyLen = key2.length;
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4 + keyAlgoLen + 4 + keyLen);
    packet[p] = MESSAGE.USERAUTH_PK_OK;
    writeUInt32BE$3(packet, keyAlgoLen, ++p);
    packet.utf8Write(keyAlgo, p += 4, keyAlgoLen);
    writeUInt32BE$3(packet, keyLen, p += keyAlgoLen);
    packet.set(key2, p += 4);
    this._authsQueue.shift();
    this._debug && this._debug("Outbound: Sending USERAUTH_PK_OK");
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  authPasswdChg(prompt) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    const promptLen = Buffer.byteLength(prompt);
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(1 + 4 + promptLen + 4);
    packet[p] = MESSAGE.USERAUTH_PASSWD_CHANGEREQ;
    writeUInt32BE$3(packet, promptLen, ++p);
    packet.utf8Write(prompt, p += 4, promptLen);
    writeUInt32BE$3(packet, 0, p += promptLen);
    this._debug && this._debug("Outbound: Sending USERAUTH_PASSWD_CHANGEREQ");
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
  authInfoReq(name, instructions, prompts) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    let promptsLen = 0;
    const nameLen = name ? Buffer.byteLength(name) : 0;
    const instrLen = instructions ? Buffer.byteLength(instructions) : 0;
    for (let i = 0; i < prompts.length; ++i)
      promptsLen += 4 + Buffer.byteLength(prompts[i].prompt) + 1;
    let p = this._packetRW.write.allocStart;
    const packet = this._packetRW.write.alloc(
      1 + 4 + nameLen + 4 + instrLen + 4 + 4 + promptsLen
    );
    packet[p] = MESSAGE.USERAUTH_INFO_REQUEST;
    writeUInt32BE$3(packet, nameLen, ++p);
    p += 4;
    if (name) {
      packet.utf8Write(name, p, nameLen);
      p += nameLen;
    }
    writeUInt32BE$3(packet, instrLen, p);
    p += 4;
    if (instructions) {
      packet.utf8Write(instructions, p, instrLen);
      p += instrLen;
    }
    writeUInt32BE$3(packet, 0, p);
    writeUInt32BE$3(packet, prompts.length, p += 4);
    p += 4;
    for (let i = 0; i < prompts.length; ++i) {
      const prompt = prompts[i];
      const promptLen = Buffer.byteLength(prompt.prompt);
      writeUInt32BE$3(packet, promptLen, p);
      p += 4;
      if (promptLen) {
        packet.utf8Write(prompt.prompt, p, promptLen);
        p += promptLen;
      }
      packet[p++] = prompt.echo ? 1 : 0;
    }
    this._debug && this._debug("Outbound: Sending USERAUTH_INFO_REQUEST");
    sendPacket(this, this._packetRW.write.finalize(packet));
  }
};
const RE_IDENT = /^SSH-(2\.0|1\.99)-([^ ]+)(?: (.*))?$/;
function parseHeader(chunk, p, len) {
  let data;
  let chunkOffset;
  if (this._buffer) {
    data = Buffer.allocUnsafe(this._buffer.length + (len - p));
    data.set(this._buffer, 0);
    if (p === 0) {
      data.set(chunk, this._buffer.length);
    } else {
      data.set(
        new Uint8Array(
          chunk.buffer,
          chunk.byteOffset + p,
          len - p
        ),
        this._buffer.length
      );
    }
    chunkOffset = this._buffer.length;
    p = 0;
  } else {
    data = chunk;
    chunkOffset = 0;
  }
  const op = p;
  let start = p;
  let end = p;
  let needNL = false;
  let lineLen = 0;
  let lines = 0;
  for (; p < data.length; ++p) {
    const ch = data[p];
    if (ch === 13) {
      needNL = true;
      continue;
    }
    if (ch === 10) {
      if (end > start && end - start > 4 && data[start] === 83 && data[start + 1] === 83 && data[start + 2] === 72 && data[start + 3] === 45) {
        const full = data.latin1Slice(op, end + 1);
        const identRaw = start === op ? full : full.slice(start - op);
        const m = RE_IDENT.exec(identRaw);
        if (!m)
          throw new Error("Invalid identification string");
        const header = {
          greeting: start === op ? "" : full.slice(0, start - op),
          identRaw,
          versions: {
            protocol: m[1],
            software: m[2]
          },
          comments: m[3]
        };
        this._remoteIdentRaw = Buffer.from(identRaw);
        this._debug && this._debug(`Remote ident: ${inspect$1(identRaw)}`);
        this._compatFlags = getCompatFlags(header);
        this._buffer = void 0;
        this._decipher = new NullDecipher(0, onKEXPayload.bind(this, { firstPacket: true }));
        this._parse = parsePacket;
        this._onHeader(header);
        if (!this._destruct) {
          return len;
        }
        kexinit(this);
        return p + 1 - chunkOffset;
      }
      if (this._server)
        throw new Error("Greetings from clients not permitted");
      if (++lines > MAX_LINES)
        throw new Error("Max greeting lines exceeded");
      needNL = false;
      start = p + 1;
      lineLen = 0;
    } else if (needNL) {
      throw new Error("Invalid header: expected newline");
    } else if (++lineLen >= MAX_LINE_LEN) {
      throw new Error("Header line too long");
    }
    end = p;
  }
  if (!this._buffer)
    this._buffer = bufferSlice$2(data, op);
  return p - chunkOffset;
}
function parsePacket(chunk, p, len) {
  return this._decipher.decrypt(chunk, p, len);
}
function onPayload(payload) {
  this._onPacket();
  if (payload.length === 0) {
    this._debug && this._debug("Inbound: Skipping empty packet payload");
    return;
  }
  payload = this._packetRW.read.read(payload);
  const type2 = payload[0];
  if (type2 === MESSAGE.USERAUTH_SUCCESS && !this._server && !this._authenticated) {
    this._authenticated = true;
    if (this._kex.negotiated.cs.compress === "zlib@openssh.com")
      this._packetRW.write = new ZlibPacketWriter2(this);
    if (this._kex.negotiated.sc.compress === "zlib@openssh.com")
      this._packetRW.read = new ZlibPacketReader2();
  }
  const handler = MESSAGE_HANDLERS[type2];
  if (handler === void 0) {
    this._debug && this._debug(`Inbound: Unsupported message type: ${type2}`);
    return;
  }
  return handler(this, payload);
}
function getCompatFlags(header) {
  const software = header.versions.software;
  let flags = 0;
  for (const rule of COMPAT_CHECKS) {
    if (typeof rule[0] === "string") {
      if (software === rule[0])
        flags |= rule[1];
    } else if (rule[0].test(software)) {
      flags |= rule[1];
    }
  }
  return flags;
}
function modesToBytes(modes) {
  const keys = Object.keys(modes);
  const bytes = Buffer.allocUnsafe(5 * keys.length + 1);
  let b = 0;
  for (let i = 0; i < keys.length; ++i) {
    const key2 = keys[i];
    if (key2 === "TTY_OP_END")
      continue;
    const opcode = TERMINAL_MODE[key2];
    if (opcode === void 0)
      continue;
    const val = modes[key2];
    if (typeof val === "number" && isFinite(val)) {
      bytes[b++] = opcode;
      bytes[b++] = val >>> 24;
      bytes[b++] = val >>> 16;
      bytes[b++] = val >>> 8;
      bytes[b++] = val;
    }
  }
  bytes[b++] = TERMINAL_MODE.TTY_OP_END;
  if (b < bytes.length)
    return bufferSlice$2(bytes, 0, b);
  return bytes;
}
function sendExtInfo(proto) {
  let serverSigAlgs = "ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521rsa-sha2-512,rsa-sha2-256,ssh-rsa,ssh-dss";
  if (eddsaSupported)
    serverSigAlgs = `ssh-ed25519,${serverSigAlgs}`;
  const algsLen = Buffer.byteLength(serverSigAlgs);
  let p = proto._packetRW.write.allocStart;
  const packet = proto._packetRW.write.alloc(1 + 4 + 4 + 15 + 4 + algsLen);
  packet[p] = MESSAGE.EXT_INFO;
  writeUInt32BE$3(packet, 1, ++p);
  writeUInt32BE$3(packet, 15, p += 4);
  packet.utf8Write("server-sig-algs", p += 4, 15);
  writeUInt32BE$3(packet, algsLen, p += 15);
  packet.utf8Write(serverSigAlgs, p += 4, algsLen);
  proto._debug && proto._debug("Outbound: Sending EXT_INFO");
  sendPacket(proto, proto._packetRW.write.finalize(packet));
}
var Protocol_1 = Protocol$2;
var nodeFsCompat = {};
const assert = require$$0$2;
const { inspect } = require$$0$1;
function addNumericalSeparator(val) {
  let res = "";
  let i = val.length;
  const start = val[0] === "-" ? 1 : 0;
  for (; i >= start + 4; i -= 3)
    res = `_${val.slice(i - 3, i)}${res}`;
  return `${val.slice(0, i)}${res}`;
}
function oneOf(expected, thing) {
  assert(typeof thing === "string", "`thing` has to be of type string");
  if (Array.isArray(expected)) {
    const len = expected.length;
    assert(len > 0, "At least one expected value needs to be specified");
    expected = expected.map((i) => String(i));
    if (len > 2) {
      return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
    } else if (len === 2) {
      return `one of ${thing} ${expected[0]} or ${expected[1]}`;
    }
    return `of ${thing} ${expected[0]}`;
  }
  return `of ${thing} ${String(expected)}`;
}
nodeFsCompat.ERR_INTERNAL_ASSERTION = class ERR_INTERNAL_ASSERTION extends Error {
  constructor(message) {
    super();
    Error.captureStackTrace(this, ERR_INTERNAL_ASSERTION);
    const suffix = "This is caused by either a bug in ssh2 or incorrect usage of ssh2 internals.\nPlease open an issue with this stack trace at https://github.com/mscdex/ssh2/issues\n";
    this.message = message === void 0 ? suffix : `${message}
${suffix}`;
  }
};
const MAX_32BIT_INT = 2 ** 32;
const MAX_32BIT_BIGINT = (() => {
  try {
    return new Function("return 2n ** 32n")();
  } catch {
  }
})();
nodeFsCompat.ERR_OUT_OF_RANGE = class ERR_OUT_OF_RANGE extends RangeError {
  constructor(str, range2, input, replaceDefaultBoolean) {
    super();
    Error.captureStackTrace(this, ERR_OUT_OF_RANGE);
    assert(range2, 'Missing "range" argument');
    let msg = replaceDefaultBoolean ? str : `The value of "${str}" is out of range.`;
    let received;
    if (Number.isInteger(input) && Math.abs(input) > MAX_32BIT_INT) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > MAX_32BIT_BIGINT || input < -MAX_32BIT_BIGINT)
        received = addNumericalSeparator(received);
      received += "n";
    } else {
      received = inspect(input);
    }
    msg += ` It must be ${range2}. Received ${received}`;
    this.message = msg;
  }
};
let ERR_INVALID_ARG_TYPE$1 = class ERR_INVALID_ARG_TYPE extends TypeError {
  constructor(name, expected, actual) {
    super();
    Error.captureStackTrace(this, ERR_INVALID_ARG_TYPE);
    assert(typeof name === "string", `'name' must be a string`);
    let determiner;
    if (typeof expected === "string" && expected.startsWith("not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    let msg;
    if (name.endsWith(" argument")) {
      msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
    } else {
      const type2 = name.includes(".") ? "property" : "argument";
      msg = `The "${name}" ${type2} ${determiner} ${oneOf(expected, "type")}`;
    }
    msg += `. Received type ${typeof actual}`;
    this.message = msg;
  }
};
nodeFsCompat.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE$1;
nodeFsCompat.validateNumber = function validateNumber(value, name) {
  if (typeof value !== "number")
    throw new ERR_INVALID_ARG_TYPE$1(name, "number", value);
};
const EventEmitter$2 = require$$5;
const fs$1 = require$$1;
const { constants } = fs$1;
const {
  Readable: ReadableStream$1,
  Writable: WritableStream$1
} = require$$1$3;
const { inherits, types: { isDate } } = require$$0$1;
const FastBuffer = Buffer[Symbol.species];
const {
  bufferCopy: bufferCopy$1,
  bufferSlice: bufferSlice$1,
  makeBufferParser: makeBufferParser$1,
  writeUInt32BE: writeUInt32BE$2
} = requireUtils();
const ATTR = {
  SIZE: 1,
  UIDGID: 2,
  PERMISSIONS: 4,
  ACMODTIME: 8,
  EXTENDED: 2147483648
};
const ATTRS_BUF = Buffer.alloc(28);
const STATUS_CODE$1 = {
  OK: 0,
  EOF: 1,
  NO_SUCH_FILE: 2,
  PERMISSION_DENIED: 3,
  FAILURE: 4,
  BAD_MESSAGE: 5,
  NO_CONNECTION: 6,
  CONNECTION_LOST: 7,
  OP_UNSUPPORTED: 8
};
const VALID_STATUS_CODES = new Map(
  Object.values(STATUS_CODE$1).map((n) => [n, 1])
);
const STATUS_CODE_STR = {
  [STATUS_CODE$1.OK]: "No error",
  [STATUS_CODE$1.EOF]: "End of file",
  [STATUS_CODE$1.NO_SUCH_FILE]: "No such file or directory",
  [STATUS_CODE$1.PERMISSION_DENIED]: "Permission denied",
  [STATUS_CODE$1.FAILURE]: "Failure",
  [STATUS_CODE$1.BAD_MESSAGE]: "Bad message",
  [STATUS_CODE$1.NO_CONNECTION]: "No connection",
  [STATUS_CODE$1.CONNECTION_LOST]: "Connection lost",
  [STATUS_CODE$1.OP_UNSUPPORTED]: "Operation unsupported"
};
const REQUEST = {
  INIT: 1,
  OPEN: 3,
  CLOSE: 4,
  READ: 5,
  WRITE: 6,
  LSTAT: 7,
  FSTAT: 8,
  SETSTAT: 9,
  FSETSTAT: 10,
  OPENDIR: 11,
  READDIR: 12,
  REMOVE: 13,
  MKDIR: 14,
  RMDIR: 15,
  REALPATH: 16,
  STAT: 17,
  RENAME: 18,
  READLINK: 19,
  SYMLINK: 20,
  EXTENDED: 200
};
const RESPONSE = {
  VERSION: 2,
  STATUS: 101,
  HANDLE: 102,
  DATA: 103,
  NAME: 104,
  ATTRS: 105,
  EXTENDED: 201
};
const OPEN_MODE$1 = {
  READ: 1,
  WRITE: 2,
  APPEND: 4,
  CREAT: 8,
  TRUNC: 16,
  EXCL: 32
};
const PKT_RW_OVERHEAD = 2 * 1024;
const MAX_REQID = 2 ** 32 - 1;
const CLIENT_VERSION_BUFFER = Buffer.from([
  0,
  0,
  0,
  5,
  REQUEST.INIT,
  0,
  0,
  0,
  3
  /* version */
]);
const SERVER_VERSION_BUFFER = Buffer.from([
  0,
  0,
  0,
  5,
  RESPONSE.VERSION,
  0,
  0,
  0,
  3
  /* version */
]);
const RE_OPENSSH$1 = /^SSH-2.0-(?:OpenSSH|dropbear)/;
const OPENSSH_MAX_PKT_LEN = 256 * 1024;
const bufferParser$1 = makeBufferParser$1();
const fakeStderr = {
  readable: false,
  writable: false,
  push: (data) => {
  },
  once: () => {
  },
  on: () => {
  },
  emit: () => {
  },
  end: () => {
  }
};
function noop$2() {
}
let SFTP$3 = class SFTP extends EventEmitter$2 {
  constructor(client2, chanInfo, cfg) {
    super();
    if (typeof cfg !== "object" || !cfg)
      cfg = {};
    const remoteIdentRaw = client2._protocol._remoteIdentRaw;
    this.server = !!cfg.server;
    this._debug = typeof cfg.debug === "function" ? cfg.debug : void 0;
    this._isOpenSSH = remoteIdentRaw && RE_OPENSSH$1.test(remoteIdentRaw);
    this._version = -1;
    this._extensions = {};
    this._biOpt = cfg.biOpt;
    this._pktLenBytes = 0;
    this._pktLen = 0;
    this._pktPos = 0;
    this._pktType = 0;
    this._pktData = void 0;
    this._writeReqid = -1;
    this._requests = {};
    this._maxInPktLen = OPENSSH_MAX_PKT_LEN;
    this._maxOutPktLen = 34e3;
    this._maxReadLen = (this._isOpenSSH ? OPENSSH_MAX_PKT_LEN : 34e3) - PKT_RW_OVERHEAD;
    this._maxWriteLen = (this._isOpenSSH ? OPENSSH_MAX_PKT_LEN : 34e3) - PKT_RW_OVERHEAD;
    this.maxOpenHandles = void 0;
    this._client = client2;
    this._protocol = client2._protocol;
    this._callbacks = [];
    this._hasX11 = false;
    this._exit = {
      code: void 0,
      signal: void 0,
      dump: void 0,
      desc: void 0
    };
    this._waitWindow = false;
    this._chunkcb = void 0;
    this._buffer = [];
    this.type = chanInfo.type;
    this.subtype = void 0;
    this.incoming = chanInfo.incoming;
    this.outgoing = chanInfo.outgoing;
    this.stderr = fakeStderr;
    this.readable = true;
  }
  // This handles incoming data to parse
  push(data) {
    if (data === null) {
      cleanupRequests(this);
      if (!this.readable)
        return;
      this.readable = false;
      this.emit("end");
      return;
    }
    let p = 0;
    while (p < data.length) {
      if (this._pktLenBytes < 4) {
        let nb = Math.min(4 - this._pktLenBytes, data.length - p);
        this._pktLenBytes += nb;
        while (nb--)
          this._pktLen = (this._pktLen << 8) + data[p++];
        if (this._pktLenBytes < 4)
          return;
        if (this._pktLen === 0)
          return doFatalSFTPError(this, "Invalid packet length");
        if (this._pktLen > this._maxInPktLen) {
          const max = this._maxInPktLen;
          return doFatalSFTPError(
            this,
            `Packet length ${this._pktLen} exceeds max length of ${max}`
          );
        }
        if (p >= data.length)
          return;
      }
      if (this._pktPos < this._pktLen) {
        const nb = Math.min(this._pktLen - this._pktPos, data.length - p);
        if (p !== 0 || nb !== data.length) {
          if (nb === this._pktLen) {
            this._pkt = new FastBuffer(data.buffer, data.byteOffset + p, nb);
          } else {
            if (!this._pkt)
              this._pkt = Buffer.allocUnsafe(this._pktLen);
            this._pkt.set(
              new Uint8Array(data.buffer, data.byteOffset + p, nb),
              this._pktPos
            );
          }
        } else if (nb === this._pktLen) {
          this._pkt = data;
        } else {
          if (!this._pkt)
            this._pkt = Buffer.allocUnsafe(this._pktLen);
          this._pkt.set(data, this._pktPos);
        }
        p += nb;
        this._pktPos += nb;
        if (this._pktPos < this._pktLen)
          return;
      }
      const type2 = this._pkt[0];
      const payload = this._pkt;
      this._pktLen = 0;
      this._pktLenBytes = 0;
      this._pkt = void 0;
      this._pktPos = 0;
      const handler = this.server ? SERVER_HANDLERS[type2] : CLIENT_HANDLERS[type2];
      if (!handler)
        return doFatalSFTPError(this, `Unknown packet type ${type2}`);
      if (this._version === -1) {
        if (this.server) {
          if (type2 !== REQUEST.INIT)
            return doFatalSFTPError(this, `Expected INIT packet, got ${type2}`);
        } else if (type2 !== RESPONSE.VERSION) {
          return doFatalSFTPError(this, `Expected VERSION packet, got ${type2}`);
        }
      }
      if (handler(this, payload) === false)
        return;
    }
  }
  end() {
    this.destroy();
  }
  destroy() {
    if (this.outgoing.state === "open" || this.outgoing.state === "eof") {
      this.outgoing.state = "closing";
      this._protocol.channelClose(this.outgoing.id);
    }
  }
  _init() {
    this._init = noop$2;
    if (!this.server)
      sendOrBuffer(this, CLIENT_VERSION_BUFFER);
  }
  // ===========================================================================
  // Client-specific ===========================================================
  // ===========================================================================
  createReadStream(path2, options) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    return new ReadStream(this, path2, options);
  }
  createWriteStream(path2, options) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    return new WriteStream(this, path2, options);
  }
  open(path2, flags_, attrs, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (typeof attrs === "function") {
      cb = attrs;
      attrs = void 0;
    }
    const flags = typeof flags_ === "number" ? flags_ : stringToFlags$1(flags_);
    if (flags === null)
      throw new Error(`Unknown flags string: ${flags_}`);
    let attrsFlags = 0;
    let attrsLen = 0;
    if (typeof attrs === "string" || typeof attrs === "number")
      attrs = { mode: attrs };
    if (typeof attrs === "object" && attrs !== null) {
      attrs = attrsToBytes(attrs);
      attrsFlags = attrs.flags;
      attrsLen = attrs.nb;
    }
    const pathLen = Buffer.byteLength(path2);
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + 4 + attrsLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = REQUEST.OPEN;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, pathLen, p);
    buf.utf8Write(path2, p += 4, pathLen);
    writeUInt32BE$2(buf, flags, p += pathLen);
    writeUInt32BE$2(buf, attrsFlags, p += 4);
    if (attrsLen) {
      p += 4;
      if (attrsLen === ATTRS_BUF.length)
        buf.set(ATTRS_BUF, p);
      else
        bufferCopy$1(ATTRS_BUF, buf, 0, attrsLen, p);
      p += attrsLen;
    }
    this._requests[reqid] = { cb };
    const isBuffered = sendOrBuffer(this, buf);
    this._debug && this._debug(
      `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} OPEN`
    );
  }
  close(handle, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (!Buffer.isBuffer(handle))
      throw new Error("handle is not a Buffer");
    const handleLen = handle.length;
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = REQUEST.CLOSE;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, handleLen, p);
    buf.set(handle, p += 4);
    this._requests[reqid] = { cb };
    const isBuffered = sendOrBuffer(this, buf);
    this._debug && this._debug(
      `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} CLOSE`
    );
  }
  read(handle, buf, off, len, position, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (!Buffer.isBuffer(handle))
      throw new Error("handle is not a Buffer");
    if (!Buffer.isBuffer(buf))
      throw new Error("buffer is not a Buffer");
    if (off >= buf.length)
      throw new Error("offset is out of bounds");
    if (off + len > buf.length)
      throw new Error("length extends beyond buffer");
    if (position === null)
      throw new Error("null position currently unsupported");
    read_(this, handle, buf, off, len, position, cb);
  }
  readData(handle, buf, off, len, position, cb) {
    this.read(handle, buf, off, len, position, cb);
  }
  write(handle, buf, off, len, position, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (!Buffer.isBuffer(handle))
      throw new Error("handle is not a Buffer");
    if (!Buffer.isBuffer(buf))
      throw new Error("buffer is not a Buffer");
    if (off > buf.length)
      throw new Error("offset is out of bounds");
    if (off + len > buf.length)
      throw new Error("length extends beyond buffer");
    if (position === null)
      throw new Error("null position currently unsupported");
    if (!len) {
      cb && process.nextTick(cb, void 0, 0);
      return;
    }
    const maxDataLen = this._maxWriteLen;
    const overflow = Math.max(len - maxDataLen, 0);
    const origPosition = position;
    if (overflow)
      len = maxDataLen;
    const handleLen = handle.length;
    let p = 9;
    const out = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 8 + 4 + len);
    writeUInt32BE$2(out, out.length - 4, 0);
    out[4] = REQUEST.WRITE;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(out, reqid, 5);
    writeUInt32BE$2(out, handleLen, p);
    out.set(handle, p += 4);
    p += handleLen;
    for (let i = 7; i >= 0; --i) {
      out[p + i] = position & 255;
      position /= 256;
    }
    writeUInt32BE$2(out, len, p += 8);
    bufferCopy$1(buf, out, off, off + len, p += 4);
    this._requests[reqid] = {
      cb: (err) => {
        if (err) {
          if (typeof cb === "function")
            cb(err);
        } else if (overflow) {
          this.write(
            handle,
            buf,
            off + len,
            overflow,
            origPosition + len,
            cb
          );
        } else if (typeof cb === "function") {
          cb(void 0, off + len);
        }
      }
    };
    const isSent = sendOrBuffer(this, out);
    if (this._debug) {
      const how = isSent ? "Sent" : "Buffered";
      this._debug(`SFTP: Outbound: ${how} WRITE (id:${reqid})`);
    }
  }
  writeData(handle, buf, off, len, position, cb) {
    this.write(handle, buf, off, len, position, cb);
  }
  fastGet(remotePath, localPath, opts, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    fastXfer(this, fs$1, remotePath, localPath, opts, cb);
  }
  fastPut(localPath, remotePath, opts, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    fastXfer(fs$1, this, localPath, remotePath, opts, cb);
  }
  readFile(path2, options, callback_) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    let callback;
    if (typeof callback_ === "function") {
      callback = callback_;
    } else if (typeof options === "function") {
      callback = options;
      options = void 0;
    }
    if (typeof options === "string")
      options = { encoding: options, flag: "r" };
    else if (!options)
      options = { encoding: null, flag: "r" };
    else if (typeof options !== "object")
      throw new TypeError("Bad arguments");
    const encoding = options.encoding;
    if (encoding && !Buffer.isEncoding(encoding))
      throw new Error(`Unknown encoding: ${encoding}`);
    let size;
    let buffer2;
    let buffers;
    let pos = 0;
    let handle;
    let bytesRead = 0;
    const flag = options.flag || "r";
    const read = () => {
      if (size === 0) {
        buffer2 = Buffer.allocUnsafe(8192);
        this.read(handle, buffer2, 0, 8192, bytesRead, afterRead);
      } else {
        this.read(handle, buffer2, pos, size - pos, bytesRead, afterRead);
      }
    };
    const afterRead = (er, nbytes) => {
      let eof;
      if (er) {
        eof = er.code === STATUS_CODE$1.EOF;
        if (!eof) {
          return this.close(handle, () => {
            return callback && callback(er);
          });
        }
      } else {
        eof = false;
      }
      if (eof || size === 0 && nbytes === 0)
        return close();
      bytesRead += nbytes;
      pos += nbytes;
      if (size !== 0) {
        if (pos === size)
          close();
        else
          read();
      } else {
        buffers.push(bufferSlice$1(buffer2, 0, nbytes));
        read();
      }
    };
    afterRead._wantEOFError = true;
    const close = () => {
      this.close(handle, (er) => {
        if (size === 0) {
          buffer2 = Buffer.concat(buffers, pos);
        } else if (pos < size) {
          buffer2 = bufferSlice$1(buffer2, 0, pos);
        }
        if (encoding)
          buffer2 = buffer2.toString(encoding);
        return callback && callback(er, buffer2);
      });
    };
    this.open(path2, flag, 438, (er, handle_) => {
      if (er)
        return callback && callback(er);
      handle = handle_;
      const tryStat = (er2, st) => {
        if (er2) {
          this.stat(path2, (er_, st_) => {
            if (er_) {
              return this.close(handle, () => {
                callback && callback(er2);
              });
            }
            tryStat(null, st_);
          });
          return;
        }
        size = st.size || 0;
        if (size === 0) {
          buffers = [];
          return read();
        }
        buffer2 = Buffer.allocUnsafe(size);
        read();
      };
      this.fstat(handle, tryStat);
    });
  }
  writeFile(path2, data, options, callback_) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    let callback;
    if (typeof callback_ === "function") {
      callback = callback_;
    } else if (typeof options === "function") {
      callback = options;
      options = void 0;
    }
    if (typeof options === "string")
      options = { encoding: options, mode: 438, flag: "w" };
    else if (!options)
      options = { encoding: "utf8", mode: 438, flag: "w" };
    else if (typeof options !== "object")
      throw new TypeError("Bad arguments");
    if (options.encoding && !Buffer.isEncoding(options.encoding))
      throw new Error(`Unknown encoding: ${options.encoding}`);
    const flag = options.flag || "w";
    this.open(path2, flag, options.mode, (openErr, handle) => {
      if (openErr) {
        callback && callback(openErr);
      } else {
        const buffer2 = Buffer.isBuffer(data) ? data : Buffer.from("" + data, options.encoding || "utf8");
        const position = /a/.test(flag) ? null : 0;
        if (position === null) {
          const tryStat = (er, st) => {
            if (er) {
              this.stat(path2, (er_, st_) => {
                if (er_) {
                  return this.close(handle, () => {
                    callback && callback(er);
                  });
                }
                tryStat(null, st_);
              });
              return;
            }
            writeAll(this, handle, buffer2, 0, buffer2.length, st.size, callback);
          };
          this.fstat(handle, tryStat);
          return;
        }
        writeAll(this, handle, buffer2, 0, buffer2.length, position, callback);
      }
    });
  }
  appendFile(path2, data, options, callback_) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    let callback;
    if (typeof callback_ === "function") {
      callback = callback_;
    } else if (typeof options === "function") {
      callback = options;
      options = void 0;
    }
    if (typeof options === "string")
      options = { encoding: options, mode: 438, flag: "a" };
    else if (!options)
      options = { encoding: "utf8", mode: 438, flag: "a" };
    else if (typeof options !== "object")
      throw new TypeError("Bad arguments");
    if (!options.flag)
      options = Object.assign({ flag: "a" }, options);
    this.writeFile(path2, data, options, callback);
  }
  exists(path2, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    this.stat(path2, (err) => {
      cb && cb(err ? false : true);
    });
  }
  unlink(filename, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const fnameLen = Buffer.byteLength(filename);
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + fnameLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = REQUEST.REMOVE;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, fnameLen, p);
    buf.utf8Write(filename, p += 4, fnameLen);
    this._requests[reqid] = { cb };
    const isBuffered = sendOrBuffer(this, buf);
    this._debug && this._debug(
      `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} REMOVE`
    );
  }
  rename(oldPath, newPath, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const oldLen = Buffer.byteLength(oldPath);
    const newLen = Buffer.byteLength(newPath);
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + oldLen + 4 + newLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = REQUEST.RENAME;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, oldLen, p);
    buf.utf8Write(oldPath, p += 4, oldLen);
    writeUInt32BE$2(buf, newLen, p += oldLen);
    buf.utf8Write(newPath, p += 4, newLen);
    this._requests[reqid] = { cb };
    const isBuffered = sendOrBuffer(this, buf);
    this._debug && this._debug(
      `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} RENAME`
    );
  }
  mkdir(path2, attrs, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    let flags = 0;
    let attrsLen = 0;
    if (typeof attrs === "function") {
      cb = attrs;
      attrs = void 0;
    }
    if (typeof attrs === "object" && attrs !== null) {
      attrs = attrsToBytes(attrs);
      flags = attrs.flags;
      attrsLen = attrs.nb;
    }
    const pathLen = Buffer.byteLength(path2);
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + attrsLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = REQUEST.MKDIR;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, pathLen, p);
    buf.utf8Write(path2, p += 4, pathLen);
    writeUInt32BE$2(buf, flags, p += pathLen);
    if (attrsLen) {
      p += 4;
      if (attrsLen === ATTRS_BUF.length)
        buf.set(ATTRS_BUF, p);
      else
        bufferCopy$1(ATTRS_BUF, buf, 0, attrsLen, p);
      p += attrsLen;
    }
    this._requests[reqid] = { cb };
    const isBuffered = sendOrBuffer(this, buf);
    this._debug && this._debug(
      `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} MKDIR`
    );
  }
  rmdir(path2, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const pathLen = Buffer.byteLength(path2);
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = REQUEST.RMDIR;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, pathLen, p);
    buf.utf8Write(path2, p += 4, pathLen);
    this._requests[reqid] = { cb };
    const isBuffered = sendOrBuffer(this, buf);
    this._debug && this._debug(
      `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} RMDIR`
    );
  }
  readdir(where, opts, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (typeof opts === "function") {
      cb = opts;
      opts = {};
    }
    if (typeof opts !== "object" || opts === null)
      opts = {};
    const doFilter = opts && opts.full ? false : true;
    if (!Buffer.isBuffer(where) && typeof where !== "string")
      throw new Error("missing directory handle or path");
    if (typeof where === "string") {
      const entries = [];
      let e = 0;
      const reread = (err, handle) => {
        if (err)
          return cb(err);
        this.readdir(handle, opts, (err2, list) => {
          const eof = err2 && err2.code === STATUS_CODE$1.EOF;
          if (err2 && !eof)
            return this.close(handle, () => cb(err2));
          if (eof) {
            return this.close(handle, (err3) => {
              if (err3)
                return cb(err3);
              cb(void 0, entries);
            });
          }
          for (let i = 0; i < list.length; ++i, ++e)
            entries[e] = list[i];
          reread(void 0, handle);
        });
      };
      return this.opendir(where, reread);
    }
    const handleLen = where.length;
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = REQUEST.READDIR;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, handleLen, p);
    buf.set(where, p += 4);
    this._requests[reqid] = {
      cb: doFilter ? (err, list) => {
        if (typeof cb !== "function")
          return;
        if (err)
          return cb(err);
        for (let i = list.length - 1; i >= 0; --i) {
          if (list[i].filename === "." || list[i].filename === "..")
            list.splice(i, 1);
        }
        cb(void 0, list);
      } : cb
    };
    const isBuffered = sendOrBuffer(this, buf);
    this._debug && this._debug(
      `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} READDIR`
    );
  }
  fstat(handle, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (!Buffer.isBuffer(handle))
      throw new Error("handle is not a Buffer");
    const handleLen = handle.length;
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = REQUEST.FSTAT;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, handleLen, p);
    buf.set(handle, p += 4);
    this._requests[reqid] = { cb };
    const isBuffered = sendOrBuffer(this, buf);
    this._debug && this._debug(
      `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} FSTAT`
    );
  }
  stat(path2, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const pathLen = Buffer.byteLength(path2);
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = REQUEST.STAT;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, pathLen, p);
    buf.utf8Write(path2, p += 4, pathLen);
    this._requests[reqid] = { cb };
    const isBuffered = sendOrBuffer(this, buf);
    this._debug && this._debug(
      `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} STAT`
    );
  }
  lstat(path2, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const pathLen = Buffer.byteLength(path2);
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = REQUEST.LSTAT;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, pathLen, p);
    buf.utf8Write(path2, p += 4, pathLen);
    this._requests[reqid] = { cb };
    const isBuffered = sendOrBuffer(this, buf);
    this._debug && this._debug(
      `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} LSTAT`
    );
  }
  opendir(path2, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const pathLen = Buffer.byteLength(path2);
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = REQUEST.OPENDIR;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, pathLen, p);
    buf.utf8Write(path2, p += 4, pathLen);
    this._requests[reqid] = { cb };
    const isBuffered = sendOrBuffer(this, buf);
    this._debug && this._debug(
      `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} OPENDIR`
    );
  }
  setstat(path2, attrs, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    let flags = 0;
    let attrsLen = 0;
    if (typeof attrs === "object" && attrs !== null) {
      attrs = attrsToBytes(attrs);
      flags = attrs.flags;
      attrsLen = attrs.nb;
    } else if (typeof attrs === "function") {
      cb = attrs;
    }
    const pathLen = Buffer.byteLength(path2);
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + attrsLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = REQUEST.SETSTAT;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, pathLen, p);
    buf.utf8Write(path2, p += 4, pathLen);
    writeUInt32BE$2(buf, flags, p += pathLen);
    if (attrsLen) {
      p += 4;
      if (attrsLen === ATTRS_BUF.length)
        buf.set(ATTRS_BUF, p);
      else
        bufferCopy$1(ATTRS_BUF, buf, 0, attrsLen, p);
      p += attrsLen;
    }
    this._requests[reqid] = { cb };
    const isBuffered = sendOrBuffer(this, buf);
    this._debug && this._debug(
      `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} SETSTAT`
    );
  }
  fsetstat(handle, attrs, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (!Buffer.isBuffer(handle))
      throw new Error("handle is not a Buffer");
    let flags = 0;
    let attrsLen = 0;
    if (typeof attrs === "object" && attrs !== null) {
      attrs = attrsToBytes(attrs);
      flags = attrs.flags;
      attrsLen = attrs.nb;
    } else if (typeof attrs === "function") {
      cb = attrs;
    }
    const handleLen = handle.length;
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 4 + attrsLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = REQUEST.FSETSTAT;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, handleLen, p);
    buf.set(handle, p += 4);
    writeUInt32BE$2(buf, flags, p += handleLen);
    if (attrsLen) {
      p += 4;
      if (attrsLen === ATTRS_BUF.length)
        buf.set(ATTRS_BUF, p);
      else
        bufferCopy$1(ATTRS_BUF, buf, 0, attrsLen, p);
      p += attrsLen;
    }
    this._requests[reqid] = { cb };
    const isBuffered = sendOrBuffer(this, buf);
    this._debug && this._debug(
      `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} FSETSTAT`
    );
  }
  futimes(handle, atime, mtime, cb) {
    return this.fsetstat(handle, {
      atime: toUnixTimestamp(atime),
      mtime: toUnixTimestamp(mtime)
    }, cb);
  }
  utimes(path2, atime, mtime, cb) {
    return this.setstat(path2, {
      atime: toUnixTimestamp(atime),
      mtime: toUnixTimestamp(mtime)
    }, cb);
  }
  fchown(handle, uid, gid, cb) {
    return this.fsetstat(handle, {
      uid,
      gid
    }, cb);
  }
  chown(path2, uid, gid, cb) {
    return this.setstat(path2, {
      uid,
      gid
    }, cb);
  }
  fchmod(handle, mode, cb) {
    return this.fsetstat(handle, {
      mode
    }, cb);
  }
  chmod(path2, mode, cb) {
    return this.setstat(path2, {
      mode
    }, cb);
  }
  readlink(path2, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const pathLen = Buffer.byteLength(path2);
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = REQUEST.READLINK;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, pathLen, p);
    buf.utf8Write(path2, p += 4, pathLen);
    this._requests[reqid] = {
      cb: (err, names2) => {
        if (typeof cb !== "function")
          return;
        if (err)
          return cb(err);
        if (!names2 || !names2.length)
          return cb(new Error("Response missing link info"));
        cb(void 0, names2[0].filename);
      }
    };
    const isBuffered = sendOrBuffer(this, buf);
    this._debug && this._debug(
      `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} READLINK`
    );
  }
  symlink(targetPath, linkPath, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const linkLen = Buffer.byteLength(linkPath);
    const targetLen = Buffer.byteLength(targetPath);
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + linkLen + 4 + targetLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = REQUEST.SYMLINK;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(buf, reqid, 5);
    if (this._isOpenSSH) {
      writeUInt32BE$2(buf, targetLen, p);
      buf.utf8Write(targetPath, p += 4, targetLen);
      writeUInt32BE$2(buf, linkLen, p += targetLen);
      buf.utf8Write(linkPath, p += 4, linkLen);
    } else {
      writeUInt32BE$2(buf, linkLen, p);
      buf.utf8Write(linkPath, p += 4, linkLen);
      writeUInt32BE$2(buf, targetLen, p += linkLen);
      buf.utf8Write(targetPath, p += 4, targetLen);
    }
    this._requests[reqid] = { cb };
    const isBuffered = sendOrBuffer(this, buf);
    this._debug && this._debug(
      `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} SYMLINK`
    );
  }
  realpath(path2, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const pathLen = Buffer.byteLength(path2);
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = REQUEST.REALPATH;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, pathLen, p);
    buf.utf8Write(path2, p += 4, pathLen);
    this._requests[reqid] = {
      cb: (err, names2) => {
        if (typeof cb !== "function")
          return;
        if (err)
          return cb(err);
        if (!names2 || !names2.length)
          return cb(new Error("Response missing path info"));
        cb(void 0, names2[0].filename);
      }
    };
    const isBuffered = sendOrBuffer(this, buf);
    this._debug && this._debug(
      `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} REALPATH`
    );
  }
  // extended requests
  ext_openssh_rename(oldPath, newPath, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const ext = this._extensions["posix-rename@openssh.com"];
    if (!ext || ext !== "1")
      throw new Error("Server does not support this extended request");
    const oldLen = Buffer.byteLength(oldPath);
    const newLen = Buffer.byteLength(newPath);
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 24 + 4 + oldLen + 4 + newLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = REQUEST.EXTENDED;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, 24, p);
    buf.utf8Write("posix-rename@openssh.com", p += 4, 24);
    writeUInt32BE$2(buf, oldLen, p += 24);
    buf.utf8Write(oldPath, p += 4, oldLen);
    writeUInt32BE$2(buf, newLen, p += oldLen);
    buf.utf8Write(newPath, p += 4, newLen);
    this._requests[reqid] = { cb };
    const isBuffered = sendOrBuffer(this, buf);
    if (this._debug) {
      const which = isBuffered ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${which} posix-rename@openssh.com`);
    }
  }
  ext_openssh_statvfs(path2, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const ext = this._extensions["statvfs@openssh.com"];
    if (!ext || ext !== "2")
      throw new Error("Server does not support this extended request");
    const pathLen = Buffer.byteLength(path2);
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 19 + 4 + pathLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = REQUEST.EXTENDED;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, 19, p);
    buf.utf8Write("statvfs@openssh.com", p += 4, 19);
    writeUInt32BE$2(buf, pathLen, p += 19);
    buf.utf8Write(path2, p += 4, pathLen);
    this._requests[reqid] = { extended: "statvfs@openssh.com", cb };
    const isBuffered = sendOrBuffer(this, buf);
    if (this._debug) {
      const which = isBuffered ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${which} statvfs@openssh.com`);
    }
  }
  ext_openssh_fstatvfs(handle, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const ext = this._extensions["fstatvfs@openssh.com"];
    if (!ext || ext !== "2")
      throw new Error("Server does not support this extended request");
    if (!Buffer.isBuffer(handle))
      throw new Error("handle is not a Buffer");
    const handleLen = handle.length;
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + handleLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = REQUEST.EXTENDED;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, 20, p);
    buf.utf8Write("fstatvfs@openssh.com", p += 4, 20);
    writeUInt32BE$2(buf, handleLen, p += 20);
    buf.set(handle, p += 4);
    this._requests[reqid] = { extended: "fstatvfs@openssh.com", cb };
    const isBuffered = sendOrBuffer(this, buf);
    if (this._debug) {
      const which = isBuffered ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${which} fstatvfs@openssh.com`);
    }
  }
  ext_openssh_hardlink(oldPath, newPath, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const ext = this._extensions["hardlink@openssh.com"];
    if (ext !== "1")
      throw new Error("Server does not support this extended request");
    const oldLen = Buffer.byteLength(oldPath);
    const newLen = Buffer.byteLength(newPath);
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + oldLen + 4 + newLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = REQUEST.EXTENDED;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, 20, p);
    buf.utf8Write("hardlink@openssh.com", p += 4, 20);
    writeUInt32BE$2(buf, oldLen, p += 20);
    buf.utf8Write(oldPath, p += 4, oldLen);
    writeUInt32BE$2(buf, newLen, p += oldLen);
    buf.utf8Write(newPath, p += 4, newLen);
    this._requests[reqid] = { cb };
    const isBuffered = sendOrBuffer(this, buf);
    if (this._debug) {
      const which = isBuffered ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${which} hardlink@openssh.com`);
    }
  }
  ext_openssh_fsync(handle, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const ext = this._extensions["fsync@openssh.com"];
    if (ext !== "1")
      throw new Error("Server does not support this extended request");
    if (!Buffer.isBuffer(handle))
      throw new Error("handle is not a Buffer");
    const handleLen = handle.length;
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 17 + 4 + handleLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = REQUEST.EXTENDED;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, 17, p);
    buf.utf8Write("fsync@openssh.com", p += 4, 17);
    writeUInt32BE$2(buf, handleLen, p += 17);
    buf.set(handle, p += 4);
    this._requests[reqid] = { cb };
    const isBuffered = sendOrBuffer(this, buf);
    this._debug && this._debug(
      `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} fsync@openssh.com`
    );
  }
  ext_openssh_lsetstat(path2, attrs, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const ext = this._extensions["lsetstat@openssh.com"];
    if (ext !== "1")
      throw new Error("Server does not support this extended request");
    let flags = 0;
    let attrsLen = 0;
    if (typeof attrs === "object" && attrs !== null) {
      attrs = attrsToBytes(attrs);
      flags = attrs.flags;
      attrsLen = attrs.nb;
    } else if (typeof attrs === "function") {
      cb = attrs;
    }
    const pathLen = Buffer.byteLength(path2);
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + pathLen + 4 + attrsLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = REQUEST.EXTENDED;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, 20, p);
    buf.utf8Write("lsetstat@openssh.com", p += 4, 20);
    writeUInt32BE$2(buf, pathLen, p += 20);
    buf.utf8Write(path2, p += 4, pathLen);
    writeUInt32BE$2(buf, flags, p += pathLen);
    if (attrsLen) {
      p += 4;
      if (attrsLen === ATTRS_BUF.length)
        buf.set(ATTRS_BUF, p);
      else
        bufferCopy$1(ATTRS_BUF, buf, 0, attrsLen, p);
      p += attrsLen;
    }
    this._requests[reqid] = { cb };
    const isBuffered = sendOrBuffer(this, buf);
    if (this._debug) {
      const status = isBuffered ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${status} lsetstat@openssh.com`);
    }
  }
  ext_openssh_expandPath(path2, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const ext = this._extensions["expand-path@openssh.com"];
    if (ext !== "1")
      throw new Error("Server does not support this extended request");
    const pathLen = Buffer.byteLength(path2);
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 23 + 4 + pathLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = REQUEST.EXTENDED;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, 23, p);
    buf.utf8Write("expand-path@openssh.com", p += 4, 23);
    writeUInt32BE$2(buf, pathLen, p += 20);
    buf.utf8Write(path2, p += 4, pathLen);
    this._requests[reqid] = {
      cb: (err, names2) => {
        if (typeof cb !== "function")
          return;
        if (err)
          return cb(err);
        if (!names2 || !names2.length)
          return cb(new Error("Response missing expanded path"));
        cb(void 0, names2[0].filename);
      }
    };
    const isBuffered = sendOrBuffer(this, buf);
    if (this._debug) {
      const status = isBuffered ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${status} expand-path@openssh.com`);
    }
  }
  ext_copy_data(srcHandle, srcOffset, len, dstHandle, dstOffset, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const ext = this._extensions["copy-data"];
    if (ext !== "1")
      throw new Error("Server does not support this extended request");
    if (!Buffer.isBuffer(srcHandle))
      throw new Error("Source handle is not a Buffer");
    if (!Buffer.isBuffer(dstHandle))
      throw new Error("Destination handle is not a Buffer");
    let p = 0;
    const buf = Buffer.allocUnsafe(
      4 + 1 + 4 + 4 + 9 + 4 + srcHandle.length + 8 + 8 + 4 + dstHandle.length + 8
    );
    writeUInt32BE$2(buf, buf.length - 4, p);
    p += 4;
    buf[p] = REQUEST.EXTENDED;
    ++p;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(buf, reqid, p);
    p += 4;
    writeUInt32BE$2(buf, 9, p);
    p += 4;
    buf.utf8Write("copy-data", p, 9);
    p += 9;
    writeUInt32BE$2(buf, srcHandle.length, p);
    p += 4;
    buf.set(srcHandle, p);
    p += srcHandle.length;
    for (let i = 7; i >= 0; --i) {
      buf[p + i] = srcOffset & 255;
      srcOffset /= 256;
    }
    p += 8;
    for (let i = 7; i >= 0; --i) {
      buf[p + i] = len & 255;
      len /= 256;
    }
    p += 8;
    writeUInt32BE$2(buf, dstHandle.length, p);
    p += 4;
    buf.set(dstHandle, p);
    p += dstHandle.length;
    for (let i = 7; i >= 0; --i) {
      buf[p + i] = dstOffset & 255;
      dstOffset /= 256;
    }
    this._requests[reqid] = { cb };
    const isBuffered = sendOrBuffer(this, buf);
    if (this._debug) {
      const status = isBuffered ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${status} copy-data`);
    }
  }
  ext_home_dir(username, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const ext = this._extensions["home-directory"];
    if (ext !== "1")
      throw new Error("Server does not support this extended request");
    if (typeof username !== "string")
      throw new TypeError("username is not a string");
    let p = 0;
    const usernameLen = Buffer.byteLength(username);
    const buf = Buffer.allocUnsafe(
      4 + 1 + 4 + 4 + 14 + 4 + usernameLen
    );
    writeUInt32BE$2(buf, buf.length - 4, p);
    p += 4;
    buf[p] = REQUEST.EXTENDED;
    ++p;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(buf, reqid, p);
    p += 4;
    writeUInt32BE$2(buf, 14, p);
    p += 4;
    buf.utf8Write("home-directory", p, 14);
    p += 14;
    writeUInt32BE$2(buf, usernameLen, p);
    p += 4;
    buf.utf8Write(username, p, usernameLen);
    p += usernameLen;
    this._requests[reqid] = {
      cb: (err, names2) => {
        if (typeof cb !== "function")
          return;
        if (err)
          return cb(err);
        if (!names2 || !names2.length)
          return cb(new Error("Response missing home directory"));
        cb(void 0, names2[0].filename);
      }
    };
    const isBuffered = sendOrBuffer(this, buf);
    if (this._debug) {
      const status = isBuffered ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${status} home-directory`);
    }
  }
  ext_users_groups(uids, gids, cb) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const ext = this._extensions["users-groups-by-id@openssh.com"];
    if (ext !== "1")
      throw new Error("Server does not support this extended request");
    if (!Array.isArray(uids))
      throw new TypeError("uids is not an array");
    for (const val of uids) {
      if (!Number.isInteger(val) || val < 0 || val > 2 ** 32 - 1)
        throw new Error("uid values must all be 32-bit unsigned integers");
    }
    if (!Array.isArray(gids))
      throw new TypeError("gids is not an array");
    for (const val of gids) {
      if (!Number.isInteger(val) || val < 0 || val > 2 ** 32 - 1)
        throw new Error("gid values must all be 32-bit unsigned integers");
    }
    let p = 0;
    const buf = Buffer.allocUnsafe(
      4 + 1 + 4 + 4 + 30 + 4 + 4 * uids.length + 4 + 4 * gids.length
    );
    writeUInt32BE$2(buf, buf.length - 4, p);
    p += 4;
    buf[p] = REQUEST.EXTENDED;
    ++p;
    const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
    writeUInt32BE$2(buf, reqid, p);
    p += 4;
    writeUInt32BE$2(buf, 30, p);
    p += 4;
    buf.utf8Write("users-groups-by-id@openssh.com", p, 30);
    p += 30;
    writeUInt32BE$2(buf, 4 * uids.length, p);
    p += 4;
    for (const val of uids) {
      writeUInt32BE$2(buf, val, p);
      p += 4;
    }
    writeUInt32BE$2(buf, 4 * gids.length, p);
    p += 4;
    for (const val of gids) {
      writeUInt32BE$2(buf, val, p);
      p += 4;
    }
    this._requests[reqid] = { extended: "users-groups-by-id@openssh.com", cb };
    const isBuffered = sendOrBuffer(this, buf);
    if (this._debug) {
      const status = isBuffered ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${status} users-groups-by-id@openssh.com`);
    }
  }
  // ===========================================================================
  // Server-specific ===========================================================
  // ===========================================================================
  handle(reqid, handle) {
    if (!this.server)
      throw new Error("Server-only method called in client mode");
    if (!Buffer.isBuffer(handle))
      throw new Error("handle is not a Buffer");
    const handleLen = handle.length;
    if (handleLen > 256)
      throw new Error("handle too large (> 256 bytes)");
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = RESPONSE.HANDLE;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, handleLen, p);
    if (handleLen)
      buf.set(handle, p += 4);
    const isBuffered = sendOrBuffer(this, buf);
    this._debug && this._debug(
      `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} HANDLE`
    );
  }
  status(reqid, code2, message) {
    if (!this.server)
      throw new Error("Server-only method called in client mode");
    if (!VALID_STATUS_CODES.has(code2))
      throw new Error(`Bad status code: ${code2}`);
    message || (message = "");
    const msgLen = Buffer.byteLength(message);
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 4 + msgLen + 4);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = RESPONSE.STATUS;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, code2, p);
    writeUInt32BE$2(buf, msgLen, p += 4);
    p += 4;
    if (msgLen) {
      buf.utf8Write(message, p, msgLen);
      p += msgLen;
    }
    writeUInt32BE$2(buf, 0, p);
    const isBuffered = sendOrBuffer(this, buf);
    this._debug && this._debug(
      `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} STATUS`
    );
  }
  data(reqid, data, encoding) {
    if (!this.server)
      throw new Error("Server-only method called in client mode");
    const isBuffer = Buffer.isBuffer(data);
    if (!isBuffer && typeof data !== "string")
      throw new Error("data is not a Buffer or string");
    let isUTF8;
    if (!isBuffer && !encoding) {
      encoding = void 0;
      isUTF8 = true;
    }
    const dataLen = isBuffer ? data.length : Buffer.byteLength(data, encoding);
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + dataLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = RESPONSE.DATA;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, dataLen, p);
    if (dataLen) {
      if (isBuffer)
        buf.set(data, p += 4);
      else if (isUTF8)
        buf.utf8Write(data, p += 4, dataLen);
      else
        buf.write(data, p += 4, dataLen, encoding);
    }
    const isBuffered = sendOrBuffer(this, buf);
    this._debug && this._debug(
      `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} DATA`
    );
  }
  name(reqid, names2) {
    if (!this.server)
      throw new Error("Server-only method called in client mode");
    if (!Array.isArray(names2)) {
      if (typeof names2 !== "object" || names2 === null)
        throw new Error("names is not an object or array");
      names2 = [names2];
    }
    const count = names2.length;
    let namesLen = 0;
    let nameAttrs;
    const attrs = [];
    for (let i = 0; i < count; ++i) {
      const name = names2[i];
      const filename = !name || !name.filename || typeof name.filename !== "string" ? "" : name.filename;
      namesLen += 4 + Buffer.byteLength(filename);
      const longname = !name || !name.longname || typeof name.longname !== "string" ? "" : name.longname;
      namesLen += 4 + Buffer.byteLength(longname);
      if (typeof name.attrs === "object" && name.attrs !== null) {
        nameAttrs = attrsToBytes(name.attrs);
        namesLen += 4 + nameAttrs.nb;
        if (nameAttrs.nb) {
          let bytes;
          if (nameAttrs.nb === ATTRS_BUF.length) {
            bytes = new Uint8Array(ATTRS_BUF);
          } else {
            bytes = new Uint8Array(nameAttrs.nb);
            bufferCopy$1(ATTRS_BUF, bytes, 0, nameAttrs.nb, 0);
          }
          nameAttrs.bytes = bytes;
        }
        attrs.push(nameAttrs);
      } else {
        namesLen += 4;
        attrs.push(null);
      }
    }
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + namesLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = RESPONSE.NAME;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, count, p);
    p += 4;
    for (let i = 0; i < count; ++i) {
      const name = names2[i];
      {
        const filename = !name || !name.filename || typeof name.filename !== "string" ? "" : name.filename;
        const len = Buffer.byteLength(filename);
        writeUInt32BE$2(buf, len, p);
        p += 4;
        if (len) {
          buf.utf8Write(filename, p, len);
          p += len;
        }
      }
      {
        const longname = !name || !name.longname || typeof name.longname !== "string" ? "" : name.longname;
        const len = Buffer.byteLength(longname);
        writeUInt32BE$2(buf, len, p);
        p += 4;
        if (len) {
          buf.utf8Write(longname, p, len);
          p += len;
        }
      }
      const attr = attrs[i];
      if (attr) {
        writeUInt32BE$2(buf, attr.flags, p);
        p += 4;
        if (attr.flags && attr.bytes) {
          buf.set(attr.bytes, p);
          p += attr.nb;
        }
      } else {
        writeUInt32BE$2(buf, 0, p);
        p += 4;
      }
    }
    const isBuffered = sendOrBuffer(this, buf);
    this._debug && this._debug(
      `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} NAME`
    );
  }
  attrs(reqid, attrs) {
    if (!this.server)
      throw new Error("Server-only method called in client mode");
    if (typeof attrs !== "object" || attrs === null)
      throw new Error("attrs is not an object");
    attrs = attrsToBytes(attrs);
    const flags = attrs.flags;
    const attrsLen = attrs.nb;
    let p = 9;
    const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + attrsLen);
    writeUInt32BE$2(buf, buf.length - 4, 0);
    buf[4] = RESPONSE.ATTRS;
    writeUInt32BE$2(buf, reqid, 5);
    writeUInt32BE$2(buf, flags, p);
    if (attrsLen) {
      p += 4;
      if (attrsLen === ATTRS_BUF.length)
        buf.set(ATTRS_BUF, p);
      else
        bufferCopy$1(ATTRS_BUF, buf, 0, attrsLen, p);
      p += attrsLen;
    }
    const isBuffered = sendOrBuffer(this, buf);
    this._debug && this._debug(
      `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} ATTRS`
    );
  }
};
function tryCreateBuffer(size) {
  try {
    return Buffer.allocUnsafe(size);
  } catch (ex) {
    return ex;
  }
}
function read_(self2, handle, buf, off, len, position, cb, req_) {
  const maxDataLen = self2._maxReadLen;
  const overflow = Math.max(len - maxDataLen, 0);
  if (overflow)
    len = maxDataLen;
  const handleLen = handle.length;
  let p = 9;
  let pos = position;
  const out = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 8 + 4);
  writeUInt32BE$2(out, out.length - 4, 0);
  out[4] = REQUEST.READ;
  const reqid = self2._writeReqid = self2._writeReqid + 1 & MAX_REQID;
  writeUInt32BE$2(out, reqid, 5);
  writeUInt32BE$2(out, handleLen, p);
  out.set(handle, p += 4);
  p += handleLen;
  for (let i = 7; i >= 0; --i) {
    out[p + i] = pos & 255;
    pos /= 256;
  }
  writeUInt32BE$2(out, len, p += 8);
  if (typeof cb !== "function")
    cb = noop$2;
  const req = req_ || {
    nb: 0,
    position,
    off,
    origOff: off,
    len: void 0,
    overflow: void 0,
    cb: (err, data, nb) => {
      const len2 = req.len;
      const overflow2 = req.overflow;
      if (err) {
        if (cb._wantEOFError || err.code !== STATUS_CODE$1.EOF)
          return cb(err);
      } else if (nb > len2) {
        return cb(new Error("Received more data than requested"));
      } else if (nb === len2 && overflow2) {
        req.nb += nb;
        req.position += nb;
        req.off += nb;
        read_(self2, handle, buf, req.off, overflow2, req.position, cb, req);
        return;
      }
      nb = nb || 0;
      if (req.origOff === 0 && buf.length === req.nb)
        data = buf;
      else
        data = bufferSlice$1(buf, req.origOff, req.origOff + req.nb + nb);
      cb(void 0, req.nb + nb, data, req.position);
    },
    buffer: void 0
  };
  req.len = len;
  req.overflow = overflow;
  req.buffer = bufferSlice$1(buf, off, off + len);
  self2._requests[reqid] = req;
  const isBuffered = sendOrBuffer(self2, out);
  self2._debug && self2._debug(
    `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} READ`
  );
}
function fastXfer(src, dst, srcPath, dstPath, opts, cb) {
  let concurrency = 64;
  let chunkSize = 32768;
  let onstep;
  let mode;
  let fileSize;
  if (typeof opts === "function") {
    cb = opts;
  } else if (typeof opts === "object" && opts !== null) {
    if (typeof opts.concurrency === "number" && opts.concurrency > 0 && !isNaN(opts.concurrency)) {
      concurrency = opts.concurrency;
    }
    if (typeof opts.chunkSize === "number" && opts.chunkSize > 0 && !isNaN(opts.chunkSize)) {
      chunkSize = opts.chunkSize;
    }
    if (typeof opts.fileSize === "number" && opts.fileSize > 0 && !isNaN(opts.fileSize)) {
      fileSize = opts.fileSize;
    }
    if (typeof opts.step === "function")
      onstep = opts.step;
    if (typeof opts.mode === "string" || typeof opts.mode === "number")
      mode = modeNum(opts.mode);
  }
  let fsize;
  let pdst = 0;
  let total = 0;
  let hadError = false;
  let srcHandle;
  let dstHandle;
  let readbuf;
  let bufsize = chunkSize * concurrency;
  function onerror(err) {
    if (hadError)
      return;
    hadError = true;
    let left = 0;
    let cbfinal;
    if (srcHandle || dstHandle) {
      cbfinal = () => {
        if (--left === 0)
          cb(err);
      };
      if (srcHandle && (src === fs$1 || src.outgoing.state === "open"))
        ++left;
      if (dstHandle && (dst === fs$1 || dst.outgoing.state === "open"))
        ++left;
      if (srcHandle && (src === fs$1 || src.outgoing.state === "open"))
        src.close(srcHandle, cbfinal);
      if (dstHandle && (dst === fs$1 || dst.outgoing.state === "open"))
        dst.close(dstHandle, cbfinal);
    } else {
      cb(err);
    }
  }
  src.open(srcPath, "r", (err, sourceHandle) => {
    if (err)
      return onerror(err);
    srcHandle = sourceHandle;
    if (fileSize === void 0)
      src.fstat(srcHandle, tryStat);
    else
      tryStat(null, { size: fileSize });
    function tryStat(err2, attrs) {
      if (err2) {
        if (src !== fs$1) {
          src.stat(srcPath, (err_, attrs_) => {
            if (err_)
              return onerror(err2);
            tryStat(null, attrs_);
          });
          return;
        }
        return onerror(err2);
      }
      fsize = attrs.size;
      dst.open(dstPath, "w", (err3, destHandle) => {
        if (err3)
          return onerror(err3);
        dstHandle = destHandle;
        if (fsize <= 0)
          return onerror();
        while (bufsize > fsize) {
          if (concurrency === 1) {
            bufsize = fsize;
            break;
          }
          bufsize -= chunkSize;
          --concurrency;
        }
        readbuf = tryCreateBuffer(bufsize);
        if (readbuf instanceof Error)
          return onerror(readbuf);
        if (mode !== void 0) {
          dst.fchmod(dstHandle, mode, function tryAgain(err4) {
            if (err4) {
              dst.chmod(dstPath, mode, (err_) => tryAgain());
              return;
            }
            startReads();
          });
        } else {
          startReads();
        }
        function onread(err4, nb, data, dstpos, datapos, origChunkLen) {
          if (err4)
            return onerror(err4);
          datapos = datapos || 0;
          dst.write(dstHandle, readbuf, datapos, nb, dstpos, writeCb);
          function writeCb(err5) {
            if (err5)
              return onerror(err5);
            total += nb;
            onstep && onstep(total, nb, fsize);
            if (nb < origChunkLen)
              return singleRead(datapos, dstpos + nb, origChunkLen - nb);
            if (total === fsize) {
              dst.close(dstHandle, (err6) => {
                dstHandle = void 0;
                if (err6)
                  return onerror(err6);
                src.close(srcHandle, (err7) => {
                  srcHandle = void 0;
                  if (err7)
                    return onerror(err7);
                  cb();
                });
              });
              return;
            }
            if (pdst >= fsize)
              return;
            const chunk = pdst + chunkSize > fsize ? fsize - pdst : chunkSize;
            singleRead(datapos, pdst, chunk);
            pdst += chunk;
          }
        }
        function makeCb(psrc, pdst2, chunk) {
          return (err4, nb, data) => {
            onread(err4, nb, data, pdst2, psrc, chunk);
          };
        }
        function singleRead(psrc, pdst2, chunk) {
          src.read(
            srcHandle,
            readbuf,
            psrc,
            chunk,
            pdst2,
            makeCb(psrc, pdst2, chunk)
          );
        }
        function startReads() {
          let reads = 0;
          let psrc = 0;
          while (pdst < fsize && reads < concurrency) {
            const chunk = pdst + chunkSize > fsize ? fsize - pdst : chunkSize;
            singleRead(psrc, pdst, chunk);
            psrc += chunk;
            pdst += chunk;
            ++reads;
          }
        }
      });
    }
  });
}
function writeAll(sftp, handle, buffer2, offset, length, position, callback_) {
  const callback = typeof callback_ === "function" ? callback_ : void 0;
  sftp.write(
    handle,
    buffer2,
    offset,
    length,
    position,
    (writeErr, written) => {
      if (writeErr) {
        return sftp.close(handle, () => {
          callback && callback(writeErr);
        });
      }
      if (written === length) {
        sftp.close(handle, callback);
      } else {
        offset += written;
        length -= written;
        position += written;
        writeAll(sftp, handle, buffer2, offset, length, position, callback);
      }
    }
  );
}
class Stats {
  constructor(initial) {
    this.mode = initial && initial.mode;
    this.uid = initial && initial.uid;
    this.gid = initial && initial.gid;
    this.size = initial && initial.size;
    this.atime = initial && initial.atime;
    this.mtime = initial && initial.mtime;
    this.extended = initial && initial.extended;
  }
  isDirectory() {
    return (this.mode & constants.S_IFMT) === constants.S_IFDIR;
  }
  isFile() {
    return (this.mode & constants.S_IFMT) === constants.S_IFREG;
  }
  isBlockDevice() {
    return (this.mode & constants.S_IFMT) === constants.S_IFBLK;
  }
  isCharacterDevice() {
    return (this.mode & constants.S_IFMT) === constants.S_IFCHR;
  }
  isSymbolicLink() {
    return (this.mode & constants.S_IFMT) === constants.S_IFLNK;
  }
  isFIFO() {
    return (this.mode & constants.S_IFMT) === constants.S_IFIFO;
  }
  isSocket() {
    return (this.mode & constants.S_IFMT) === constants.S_IFSOCK;
  }
}
function attrsToBytes(attrs) {
  let flags = 0;
  let nb = 0;
  if (typeof attrs === "object" && attrs !== null) {
    if (typeof attrs.size === "number") {
      flags |= ATTR.SIZE;
      const val = attrs.size;
      ATTRS_BUF[nb++] = val / 72057594037927940;
      ATTRS_BUF[nb++] = val / 281474976710656;
      ATTRS_BUF[nb++] = val / 1099511627776;
      ATTRS_BUF[nb++] = val / 4294967296;
      ATTRS_BUF[nb++] = val / 16777216;
      ATTRS_BUF[nb++] = val / 65536;
      ATTRS_BUF[nb++] = val / 256;
      ATTRS_BUF[nb++] = val;
    }
    if (typeof attrs.uid === "number" && typeof attrs.gid === "number") {
      flags |= ATTR.UIDGID;
      const uid = attrs.uid;
      const gid = attrs.gid;
      ATTRS_BUF[nb++] = uid >>> 24;
      ATTRS_BUF[nb++] = uid >>> 16;
      ATTRS_BUF[nb++] = uid >>> 8;
      ATTRS_BUF[nb++] = uid;
      ATTRS_BUF[nb++] = gid >>> 24;
      ATTRS_BUF[nb++] = gid >>> 16;
      ATTRS_BUF[nb++] = gid >>> 8;
      ATTRS_BUF[nb++] = gid;
    }
    if (typeof attrs.mode === "number" || typeof attrs.mode === "string") {
      const mode = modeNum(attrs.mode);
      flags |= ATTR.PERMISSIONS;
      ATTRS_BUF[nb++] = mode >>> 24;
      ATTRS_BUF[nb++] = mode >>> 16;
      ATTRS_BUF[nb++] = mode >>> 8;
      ATTRS_BUF[nb++] = mode;
    }
    if ((typeof attrs.atime === "number" || isDate(attrs.atime)) && (typeof attrs.mtime === "number" || isDate(attrs.mtime))) {
      const atime = toUnixTimestamp(attrs.atime);
      const mtime = toUnixTimestamp(attrs.mtime);
      flags |= ATTR.ACMODTIME;
      ATTRS_BUF[nb++] = atime >>> 24;
      ATTRS_BUF[nb++] = atime >>> 16;
      ATTRS_BUF[nb++] = atime >>> 8;
      ATTRS_BUF[nb++] = atime;
      ATTRS_BUF[nb++] = mtime >>> 24;
      ATTRS_BUF[nb++] = mtime >>> 16;
      ATTRS_BUF[nb++] = mtime >>> 8;
      ATTRS_BUF[nb++] = mtime;
    }
  }
  return { flags, nb };
}
function toUnixTimestamp(time) {
  if (typeof time === "number" && time === time)
    return time;
  if (isDate(time))
    return parseInt(time.getTime() / 1e3, 10);
  throw new Error(`Cannot parse time: ${time}`);
}
function modeNum(mode) {
  if (typeof mode === "number" && mode === mode)
    return mode;
  if (typeof mode === "string")
    return modeNum(parseInt(mode, 8));
  throw new Error(`Cannot parse mode: ${mode}`);
}
const stringFlagMap = {
  "r": OPEN_MODE$1.READ,
  "r+": OPEN_MODE$1.READ | OPEN_MODE$1.WRITE,
  "w": OPEN_MODE$1.TRUNC | OPEN_MODE$1.CREAT | OPEN_MODE$1.WRITE,
  "wx": OPEN_MODE$1.TRUNC | OPEN_MODE$1.CREAT | OPEN_MODE$1.WRITE | OPEN_MODE$1.EXCL,
  "xw": OPEN_MODE$1.TRUNC | OPEN_MODE$1.CREAT | OPEN_MODE$1.WRITE | OPEN_MODE$1.EXCL,
  "w+": OPEN_MODE$1.TRUNC | OPEN_MODE$1.CREAT | OPEN_MODE$1.READ | OPEN_MODE$1.WRITE,
  "wx+": OPEN_MODE$1.TRUNC | OPEN_MODE$1.CREAT | OPEN_MODE$1.READ | OPEN_MODE$1.WRITE | OPEN_MODE$1.EXCL,
  "xw+": OPEN_MODE$1.TRUNC | OPEN_MODE$1.CREAT | OPEN_MODE$1.READ | OPEN_MODE$1.WRITE | OPEN_MODE$1.EXCL,
  "a": OPEN_MODE$1.APPEND | OPEN_MODE$1.CREAT | OPEN_MODE$1.WRITE,
  "ax": OPEN_MODE$1.APPEND | OPEN_MODE$1.CREAT | OPEN_MODE$1.WRITE | OPEN_MODE$1.EXCL,
  "xa": OPEN_MODE$1.APPEND | OPEN_MODE$1.CREAT | OPEN_MODE$1.WRITE | OPEN_MODE$1.EXCL,
  "a+": OPEN_MODE$1.APPEND | OPEN_MODE$1.CREAT | OPEN_MODE$1.READ | OPEN_MODE$1.WRITE,
  "ax+": OPEN_MODE$1.APPEND | OPEN_MODE$1.CREAT | OPEN_MODE$1.READ | OPEN_MODE$1.WRITE | OPEN_MODE$1.EXCL,
  "xa+": OPEN_MODE$1.APPEND | OPEN_MODE$1.CREAT | OPEN_MODE$1.READ | OPEN_MODE$1.WRITE | OPEN_MODE$1.EXCL
};
function stringToFlags$1(str) {
  const flags = stringFlagMap[str];
  return flags !== void 0 ? flags : null;
}
const flagsToString$1 = (() => {
  const stringFlagMapKeys = Object.keys(stringFlagMap);
  return (flags) => {
    for (let i = 0; i < stringFlagMapKeys.length; ++i) {
      const key2 = stringFlagMapKeys[i];
      if (stringFlagMap[key2] === flags)
        return key2;
    }
    return null;
  };
})();
function readAttrs(biOpt) {
  const flags = bufferParser$1.readUInt32BE();
  if (flags === void 0)
    return;
  const attrs = new Stats();
  if (flags & ATTR.SIZE) {
    const size = bufferParser$1.readUInt64BE(biOpt);
    if (size === void 0)
      return;
    attrs.size = size;
  }
  if (flags & ATTR.UIDGID) {
    const uid = bufferParser$1.readUInt32BE();
    const gid = bufferParser$1.readUInt32BE();
    if (gid === void 0)
      return;
    attrs.uid = uid;
    attrs.gid = gid;
  }
  if (flags & ATTR.PERMISSIONS) {
    const mode = bufferParser$1.readUInt32BE();
    if (mode === void 0)
      return;
    attrs.mode = mode;
  }
  if (flags & ATTR.ACMODTIME) {
    const atime = bufferParser$1.readUInt32BE();
    const mtime = bufferParser$1.readUInt32BE();
    if (mtime === void 0)
      return;
    attrs.atime = atime;
    attrs.mtime = mtime;
  }
  if (flags & ATTR.EXTENDED) {
    const count = bufferParser$1.readUInt32BE();
    if (count === void 0)
      return;
    const extended = {};
    for (let i = 0; i < count; ++i) {
      const type2 = bufferParser$1.readString(true);
      const data = bufferParser$1.readString();
      if (data === void 0)
        return;
      extended[type2] = data;
    }
    attrs.extended = extended;
  }
  return attrs;
}
function sendOrBuffer(sftp, payload) {
  const ret = tryWritePayload(sftp, payload);
  if (ret !== void 0) {
    sftp._buffer.push(ret);
    return false;
  }
  return true;
}
function tryWritePayload(sftp, payload) {
  const outgoing = sftp.outgoing;
  if (outgoing.state !== "open")
    return;
  if (outgoing.window === 0) {
    sftp._waitWindow = true;
    sftp._chunkcb = drainBuffer;
    return payload;
  }
  let ret;
  const len = payload.length;
  let p = 0;
  while (len - p > 0 && outgoing.window > 0) {
    const actualLen = Math.min(len - p, outgoing.window, outgoing.packetSize);
    outgoing.window -= actualLen;
    if (outgoing.window === 0) {
      sftp._waitWindow = true;
      sftp._chunkcb = drainBuffer;
    }
    if (p === 0 && actualLen === len) {
      sftp._protocol.channelData(sftp.outgoing.id, payload);
    } else {
      sftp._protocol.channelData(
        sftp.outgoing.id,
        bufferSlice$1(payload, p, p + actualLen)
      );
    }
    p += actualLen;
  }
  if (len - p > 0) {
    if (p > 0)
      ret = bufferSlice$1(payload, p, len);
    else
      ret = payload;
  }
  return ret;
}
function drainBuffer() {
  this._chunkcb = void 0;
  const buffer2 = this._buffer;
  let i = 0;
  while (i < buffer2.length) {
    const payload = buffer2[i];
    const ret = tryWritePayload(this, payload);
    if (ret !== void 0) {
      if (ret !== payload)
        buffer2[i] = ret;
      if (i > 0)
        this._buffer = buffer2.slice(i);
      return;
    }
    ++i;
  }
  if (i > 0)
    this._buffer = [];
}
function doFatalSFTPError(sftp, msg, noDebug) {
  const err = new Error(msg);
  err.level = "sftp-protocol";
  if (sftp._debug)
    sftp._debug(`SFTP: Inbound: ${msg}`);
  sftp.emit("error", err);
  sftp.destroy();
  cleanupRequests(sftp);
  return false;
}
function cleanupRequests(sftp) {
  const keys = Object.keys(sftp._requests);
  if (keys.length === 0)
    return;
  const reqs = sftp._requests;
  sftp._requests = {};
  const err = new Error("No response from server");
  for (let i = 0; i < keys.length; ++i) {
    const req = reqs[keys[i]];
    if (typeof req.cb === "function")
      req.cb(err);
  }
}
function requestLimits(sftp, cb) {
  let p = 9;
  const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 18);
  writeUInt32BE$2(buf, buf.length - 4, 0);
  buf[4] = REQUEST.EXTENDED;
  const reqid = sftp._writeReqid = sftp._writeReqid + 1 & MAX_REQID;
  writeUInt32BE$2(buf, reqid, 5);
  writeUInt32BE$2(buf, 18, p);
  buf.utf8Write("limits@openssh.com", p += 4, 18);
  sftp._requests[reqid] = { extended: "limits@openssh.com", cb };
  const isBuffered = sendOrBuffer(sftp, buf);
  if (sftp._debug) {
    const which = isBuffered ? "Buffered" : "Sending";
    sftp._debug(`SFTP: Outbound: ${which} limits@openssh.com`);
  }
}
const CLIENT_HANDLERS = {
  [RESPONSE.VERSION]: (sftp, payload) => {
    if (sftp._version !== -1)
      return doFatalSFTPError(sftp, "Duplicate VERSION packet");
    const extensions = {};
    bufferParser$1.init(payload, 1);
    let version2 = bufferParser$1.readUInt32BE();
    while (bufferParser$1.avail()) {
      const extName = bufferParser$1.readString(true);
      const extData = bufferParser$1.readString(true);
      if (extData === void 0) {
        version2 = void 0;
        break;
      }
      extensions[extName] = extData;
    }
    bufferParser$1.clear();
    if (version2 === void 0)
      return doFatalSFTPError(sftp, "Malformed VERSION packet");
    if (sftp._debug) {
      const names2 = Object.keys(extensions);
      if (names2.length) {
        sftp._debug(
          `SFTP: Inbound: Received VERSION (v${version2}, exts:${names2})`
        );
      } else {
        sftp._debug(`SFTP: Inbound: Received VERSION (v${version2})`);
      }
    }
    sftp._version = version2;
    sftp._extensions = extensions;
    if (extensions["limits@openssh.com"] === "1") {
      return requestLimits(sftp, (err, limits) => {
        if (!err) {
          if (limits.maxPktLen > 0)
            sftp._maxOutPktLen = limits.maxPktLen;
          if (limits.maxReadLen > 0)
            sftp._maxReadLen = limits.maxReadLen;
          if (limits.maxWriteLen > 0)
            sftp._maxWriteLen = limits.maxWriteLen;
          sftp.maxOpenHandles = limits.maxOpenHandles > 0 ? limits.maxOpenHandles : Infinity;
        }
        sftp.emit("ready");
      });
    }
    sftp.emit("ready");
  },
  [RESPONSE.STATUS]: (sftp, payload) => {
    bufferParser$1.init(payload, 1);
    const reqID = bufferParser$1.readUInt32BE();
    const errorCode = bufferParser$1.readUInt32BE();
    const errorMsg = bufferParser$1.readString(true);
    bufferParser$1.clear();
    if (sftp._debug) {
      const jsonMsg = JSON.stringify(errorMsg);
      sftp._debug(
        `SFTP: Inbound: Received STATUS (id:${reqID}, ${errorCode}, ${jsonMsg})`
      );
    }
    const req = sftp._requests[reqID];
    delete sftp._requests[reqID];
    if (req && typeof req.cb === "function") {
      if (errorCode === STATUS_CODE$1.OK) {
        req.cb();
        return;
      }
      const err = new Error(errorMsg || STATUS_CODE_STR[errorCode] || "Unknown status");
      err.code = errorCode;
      req.cb(err);
    }
  },
  [RESPONSE.HANDLE]: (sftp, payload) => {
    bufferParser$1.init(payload, 1);
    const reqID = bufferParser$1.readUInt32BE();
    const handle = bufferParser$1.readString();
    bufferParser$1.clear();
    if (handle === void 0) {
      if (reqID !== void 0)
        delete sftp._requests[reqID];
      return doFatalSFTPError(sftp, "Malformed HANDLE packet");
    }
    sftp._debug && sftp._debug(`SFTP: Inbound: Received HANDLE (id:${reqID})`);
    const req = sftp._requests[reqID];
    delete sftp._requests[reqID];
    if (req && typeof req.cb === "function")
      req.cb(void 0, handle);
  },
  [RESPONSE.DATA]: (sftp, payload) => {
    bufferParser$1.init(payload, 1);
    const reqID = bufferParser$1.readUInt32BE();
    let req;
    if (reqID !== void 0) {
      req = sftp._requests[reqID];
      delete sftp._requests[reqID];
    }
    if (req && typeof req.cb === "function") {
      if (req.buffer) {
        const nb = bufferParser$1.readString(req.buffer);
        bufferParser$1.clear();
        if (nb !== void 0) {
          sftp._debug && sftp._debug(
            `SFTP: Inbound: Received DATA (id:${reqID}, ${nb})`
          );
          req.cb(void 0, req.buffer, nb);
          return;
        }
      } else {
        const data = bufferParser$1.readString();
        bufferParser$1.clear();
        if (data !== void 0) {
          sftp._debug && sftp._debug(
            `SFTP: Inbound: Received DATA (id:${reqID}, ${data.length})`
          );
          req.cb(void 0, data);
          return;
        }
      }
    } else {
      const nb = bufferParser$1.skipString();
      bufferParser$1.clear();
      if (nb !== void 0) {
        sftp._debug && sftp._debug(
          `SFTP: Inbound: Received DATA (id:${reqID}, ${nb})`
        );
        return;
      }
    }
    return doFatalSFTPError(sftp, "Malformed DATA packet");
  },
  [RESPONSE.NAME]: (sftp, payload) => {
    bufferParser$1.init(payload, 1);
    const reqID = bufferParser$1.readUInt32BE();
    let req;
    if (reqID !== void 0) {
      req = sftp._requests[reqID];
      delete sftp._requests[reqID];
    }
    const count = bufferParser$1.readUInt32BE();
    if (count !== void 0) {
      let names2 = [];
      for (let i = 0; i < count; ++i) {
        const filename = bufferParser$1.readString(true);
        const longname = bufferParser$1.readString(true);
        const attrs = readAttrs(sftp._biOpt);
        if (attrs === void 0) {
          names2 = void 0;
          break;
        }
        names2.push({ filename, longname, attrs });
      }
      if (names2 !== void 0) {
        sftp._debug && sftp._debug(
          `SFTP: Inbound: Received NAME (id:${reqID}, ${names2.length})`
        );
        bufferParser$1.clear();
        if (req && typeof req.cb === "function")
          req.cb(void 0, names2);
        return;
      }
    }
    bufferParser$1.clear();
    return doFatalSFTPError(sftp, "Malformed NAME packet");
  },
  [RESPONSE.ATTRS]: (sftp, payload) => {
    bufferParser$1.init(payload, 1);
    const reqID = bufferParser$1.readUInt32BE();
    let req;
    if (reqID !== void 0) {
      req = sftp._requests[reqID];
      delete sftp._requests[reqID];
    }
    const attrs = readAttrs(sftp._biOpt);
    bufferParser$1.clear();
    if (attrs !== void 0) {
      sftp._debug && sftp._debug(`SFTP: Inbound: Received ATTRS (id:${reqID})`);
      if (req && typeof req.cb === "function")
        req.cb(void 0, attrs);
      return;
    }
    return doFatalSFTPError(sftp, "Malformed ATTRS packet");
  },
  [RESPONSE.EXTENDED]: (sftp, payload) => {
    bufferParser$1.init(payload, 1);
    const reqID = bufferParser$1.readUInt32BE();
    if (reqID !== void 0) {
      const req = sftp._requests[reqID];
      if (req) {
        delete sftp._requests[reqID];
        switch (req.extended) {
          case "statvfs@openssh.com":
          case "fstatvfs@openssh.com": {
            const biOpt = sftp._biOpt;
            const stats = {
              f_bsize: bufferParser$1.readUInt64BE(biOpt),
              f_frsize: bufferParser$1.readUInt64BE(biOpt),
              f_blocks: bufferParser$1.readUInt64BE(biOpt),
              f_bfree: bufferParser$1.readUInt64BE(biOpt),
              f_bavail: bufferParser$1.readUInt64BE(biOpt),
              f_files: bufferParser$1.readUInt64BE(biOpt),
              f_ffree: bufferParser$1.readUInt64BE(biOpt),
              f_favail: bufferParser$1.readUInt64BE(biOpt),
              f_sid: bufferParser$1.readUInt64BE(biOpt),
              f_flag: bufferParser$1.readUInt64BE(biOpt),
              f_namemax: bufferParser$1.readUInt64BE(biOpt)
            };
            if (stats.f_namemax === void 0)
              break;
            if (sftp._debug) {
              sftp._debug(
                `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ${req.extended})`
              );
            }
            bufferParser$1.clear();
            if (typeof req.cb === "function")
              req.cb(void 0, stats);
            return;
          }
          case "limits@openssh.com": {
            const limits = {
              maxPktLen: bufferParser$1.readUInt64BE(),
              maxReadLen: bufferParser$1.readUInt64BE(),
              maxWriteLen: bufferParser$1.readUInt64BE(),
              maxOpenHandles: bufferParser$1.readUInt64BE()
            };
            if (limits.maxOpenHandles === void 0)
              break;
            if (sftp._debug) {
              sftp._debug(
                `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ${req.extended})`
              );
            }
            bufferParser$1.clear();
            if (typeof req.cb === "function")
              req.cb(void 0, limits);
            return;
          }
          case "users-groups-by-id@openssh.com": {
            const usernameCount = bufferParser$1.readUInt32BE();
            if (usernameCount === void 0)
              break;
            const usernames = new Array(usernameCount);
            for (let i = 0; i < usernames.length; ++i)
              usernames[i] = bufferParser$1.readString(true);
            const groupnameCount = bufferParser$1.readUInt32BE();
            if (groupnameCount === void 0)
              break;
            const groupnames = new Array(groupnameCount);
            for (let i = 0; i < groupnames.length; ++i)
              groupnames[i] = bufferParser$1.readString(true);
            if (groupnames.length > 0 && groupnames[groupnames.length - 1] === void 0) {
              break;
            }
            if (sftp._debug) {
              sftp._debug(
                `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ${req.extended})`
              );
            }
            bufferParser$1.clear();
            if (typeof req.cb === "function")
              req.cb(void 0, usernames, groupnames);
            return;
          }
          default:
            sftp._debug && sftp._debug(
              `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ???)`
            );
            bufferParser$1.clear();
            if (typeof req.cb === "function")
              req.cb();
            return;
        }
      } else {
        sftp._debug && sftp._debug(
          `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ???)`
        );
        bufferParser$1.clear();
        return;
      }
    }
    bufferParser$1.clear();
    return doFatalSFTPError(sftp, "Malformed EXTENDED_REPLY packet");
  }
};
const SERVER_HANDLERS = {
  [REQUEST.INIT]: (sftp, payload) => {
    if (sftp._version !== -1)
      return doFatalSFTPError(sftp, "Duplicate INIT packet");
    const extensions = {};
    bufferParser$1.init(payload, 1);
    let version2 = bufferParser$1.readUInt32BE();
    while (bufferParser$1.avail()) {
      const extName = bufferParser$1.readString(true);
      const extData = bufferParser$1.readString(true);
      if (extData === void 0) {
        version2 = void 0;
        break;
      }
      extensions[extName] = extData;
    }
    bufferParser$1.clear();
    if (version2 === void 0)
      return doFatalSFTPError(sftp, "Malformed INIT packet");
    if (sftp._debug) {
      const names2 = Object.keys(extensions);
      if (names2.length) {
        sftp._debug(
          `SFTP: Inbound: Received INIT (v${version2}, exts:${names2})`
        );
      } else {
        sftp._debug(`SFTP: Inbound: Received INIT (v${version2})`);
      }
    }
    sendOrBuffer(sftp, SERVER_VERSION_BUFFER);
    sftp._version = version2;
    sftp._extensions = extensions;
    sftp.emit("ready");
  },
  [REQUEST.OPEN]: (sftp, payload) => {
    bufferParser$1.init(payload, 1);
    const reqID = bufferParser$1.readUInt32BE();
    const filename = bufferParser$1.readString(true);
    const pflags = bufferParser$1.readUInt32BE();
    const attrs = readAttrs(sftp._biOpt);
    bufferParser$1.clear();
    if (attrs === void 0)
      return doFatalSFTPError(sftp, "Malformed OPEN packet");
    sftp._debug && sftp._debug(`SFTP: Inbound: Received OPEN (id:${reqID})`);
    if (!sftp.emit("OPEN", reqID, filename, pflags, attrs)) {
      sftp.status(reqID, STATUS_CODE$1.OP_UNSUPPORTED);
    }
  },
  [REQUEST.CLOSE]: (sftp, payload) => {
    bufferParser$1.init(payload, 1);
    const reqID = bufferParser$1.readUInt32BE();
    const handle = bufferParser$1.readString();
    bufferParser$1.clear();
    if (handle === void 0 || handle.length > 256)
      return doFatalSFTPError(sftp, "Malformed CLOSE packet");
    sftp._debug && sftp._debug(`SFTP: Inbound: Received CLOSE (id:${reqID})`);
    if (!sftp.emit("CLOSE", reqID, handle)) {
      sftp.status(reqID, STATUS_CODE$1.OP_UNSUPPORTED);
    }
  },
  [REQUEST.READ]: (sftp, payload) => {
    bufferParser$1.init(payload, 1);
    const reqID = bufferParser$1.readUInt32BE();
    const handle = bufferParser$1.readString();
    const offset = bufferParser$1.readUInt64BE(sftp._biOpt);
    const len = bufferParser$1.readUInt32BE();
    bufferParser$1.clear();
    if (len === void 0 || handle.length > 256)
      return doFatalSFTPError(sftp, "Malformed READ packet");
    sftp._debug && sftp._debug(`SFTP: Inbound: Received READ (id:${reqID})`);
    if (!sftp.emit("READ", reqID, handle, offset, len)) {
      sftp.status(reqID, STATUS_CODE$1.OP_UNSUPPORTED);
    }
  },
  [REQUEST.WRITE]: (sftp, payload) => {
    bufferParser$1.init(payload, 1);
    const reqID = bufferParser$1.readUInt32BE();
    const handle = bufferParser$1.readString();
    const offset = bufferParser$1.readUInt64BE(sftp._biOpt);
    const data = bufferParser$1.readString();
    bufferParser$1.clear();
    if (data === void 0 || handle.length > 256)
      return doFatalSFTPError(sftp, "Malformed WRITE packet");
    sftp._debug && sftp._debug(`SFTP: Inbound: Received WRITE (id:${reqID})`);
    if (!sftp.emit("WRITE", reqID, handle, offset, data)) {
      sftp.status(reqID, STATUS_CODE$1.OP_UNSUPPORTED);
    }
  },
  [REQUEST.LSTAT]: (sftp, payload) => {
    bufferParser$1.init(payload, 1);
    const reqID = bufferParser$1.readUInt32BE();
    const path2 = bufferParser$1.readString(true);
    bufferParser$1.clear();
    if (path2 === void 0)
      return doFatalSFTPError(sftp, "Malformed LSTAT packet");
    sftp._debug && sftp._debug(`SFTP: Inbound: Received LSTAT (id:${reqID})`);
    if (!sftp.emit("LSTAT", reqID, path2)) {
      sftp.status(reqID, STATUS_CODE$1.OP_UNSUPPORTED);
    }
  },
  [REQUEST.FSTAT]: (sftp, payload) => {
    bufferParser$1.init(payload, 1);
    const reqID = bufferParser$1.readUInt32BE();
    const handle = bufferParser$1.readString();
    bufferParser$1.clear();
    if (handle === void 0 || handle.length > 256)
      return doFatalSFTPError(sftp, "Malformed FSTAT packet");
    sftp._debug && sftp._debug(`SFTP: Inbound: Received FSTAT (id:${reqID})`);
    if (!sftp.emit("FSTAT", reqID, handle)) {
      sftp.status(reqID, STATUS_CODE$1.OP_UNSUPPORTED);
    }
  },
  [REQUEST.SETSTAT]: (sftp, payload) => {
    bufferParser$1.init(payload, 1);
    const reqID = bufferParser$1.readUInt32BE();
    const path2 = bufferParser$1.readString(true);
    const attrs = readAttrs(sftp._biOpt);
    bufferParser$1.clear();
    if (attrs === void 0)
      return doFatalSFTPError(sftp, "Malformed SETSTAT packet");
    sftp._debug && sftp._debug(`SFTP: Inbound: Received SETSTAT (id:${reqID})`);
    if (!sftp.emit("SETSTAT", reqID, path2, attrs)) {
      sftp.status(reqID, STATUS_CODE$1.OP_UNSUPPORTED);
    }
  },
  [REQUEST.FSETSTAT]: (sftp, payload) => {
    bufferParser$1.init(payload, 1);
    const reqID = bufferParser$1.readUInt32BE();
    const handle = bufferParser$1.readString();
    const attrs = readAttrs(sftp._biOpt);
    bufferParser$1.clear();
    if (attrs === void 0 || handle.length > 256)
      return doFatalSFTPError(sftp, "Malformed FSETSTAT packet");
    sftp._debug && sftp._debug(
      `SFTP: Inbound: Received FSETSTAT (id:${reqID})`
    );
    if (!sftp.emit("FSETSTAT", reqID, handle, attrs)) {
      sftp.status(reqID, STATUS_CODE$1.OP_UNSUPPORTED);
    }
  },
  [REQUEST.OPENDIR]: (sftp, payload) => {
    bufferParser$1.init(payload, 1);
    const reqID = bufferParser$1.readUInt32BE();
    const path2 = bufferParser$1.readString(true);
    bufferParser$1.clear();
    if (path2 === void 0)
      return doFatalSFTPError(sftp, "Malformed OPENDIR packet");
    sftp._debug && sftp._debug(`SFTP: Inbound: Received OPENDIR (id:${reqID})`);
    if (!sftp.emit("OPENDIR", reqID, path2)) {
      sftp.status(reqID, STATUS_CODE$1.OP_UNSUPPORTED);
    }
  },
  [REQUEST.READDIR]: (sftp, payload) => {
    bufferParser$1.init(payload, 1);
    const reqID = bufferParser$1.readUInt32BE();
    const handle = bufferParser$1.readString();
    bufferParser$1.clear();
    if (handle === void 0 || handle.length > 256)
      return doFatalSFTPError(sftp, "Malformed READDIR packet");
    sftp._debug && sftp._debug(`SFTP: Inbound: Received READDIR (id:${reqID})`);
    if (!sftp.emit("READDIR", reqID, handle)) {
      sftp.status(reqID, STATUS_CODE$1.OP_UNSUPPORTED);
    }
  },
  [REQUEST.REMOVE]: (sftp, payload) => {
    bufferParser$1.init(payload, 1);
    const reqID = bufferParser$1.readUInt32BE();
    const path2 = bufferParser$1.readString(true);
    bufferParser$1.clear();
    if (path2 === void 0)
      return doFatalSFTPError(sftp, "Malformed REMOVE packet");
    sftp._debug && sftp._debug(`SFTP: Inbound: Received REMOVE (id:${reqID})`);
    if (!sftp.emit("REMOVE", reqID, path2)) {
      sftp.status(reqID, STATUS_CODE$1.OP_UNSUPPORTED);
    }
  },
  [REQUEST.MKDIR]: (sftp, payload) => {
    bufferParser$1.init(payload, 1);
    const reqID = bufferParser$1.readUInt32BE();
    const path2 = bufferParser$1.readString(true);
    const attrs = readAttrs(sftp._biOpt);
    bufferParser$1.clear();
    if (attrs === void 0)
      return doFatalSFTPError(sftp, "Malformed MKDIR packet");
    sftp._debug && sftp._debug(`SFTP: Inbound: Received MKDIR (id:${reqID})`);
    if (!sftp.emit("MKDIR", reqID, path2, attrs)) {
      sftp.status(reqID, STATUS_CODE$1.OP_UNSUPPORTED);
    }
  },
  [REQUEST.RMDIR]: (sftp, payload) => {
    bufferParser$1.init(payload, 1);
    const reqID = bufferParser$1.readUInt32BE();
    const path2 = bufferParser$1.readString(true);
    bufferParser$1.clear();
    if (path2 === void 0)
      return doFatalSFTPError(sftp, "Malformed RMDIR packet");
    sftp._debug && sftp._debug(`SFTP: Inbound: Received RMDIR (id:${reqID})`);
    if (!sftp.emit("RMDIR", reqID, path2)) {
      sftp.status(reqID, STATUS_CODE$1.OP_UNSUPPORTED);
    }
  },
  [REQUEST.REALPATH]: (sftp, payload) => {
    bufferParser$1.init(payload, 1);
    const reqID = bufferParser$1.readUInt32BE();
    const path2 = bufferParser$1.readString(true);
    bufferParser$1.clear();
    if (path2 === void 0)
      return doFatalSFTPError(sftp, "Malformed REALPATH packet");
    sftp._debug && sftp._debug(
      `SFTP: Inbound: Received REALPATH (id:${reqID})`
    );
    if (!sftp.emit("REALPATH", reqID, path2)) {
      sftp.status(reqID, STATUS_CODE$1.OP_UNSUPPORTED);
    }
  },
  [REQUEST.STAT]: (sftp, payload) => {
    bufferParser$1.init(payload, 1);
    const reqID = bufferParser$1.readUInt32BE();
    const path2 = bufferParser$1.readString(true);
    bufferParser$1.clear();
    if (path2 === void 0)
      return doFatalSFTPError(sftp, "Malformed STAT packet");
    sftp._debug && sftp._debug(`SFTP: Inbound: Received STAT (id:${reqID})`);
    if (!sftp.emit("STAT", reqID, path2)) {
      sftp.status(reqID, STATUS_CODE$1.OP_UNSUPPORTED);
    }
  },
  [REQUEST.RENAME]: (sftp, payload) => {
    bufferParser$1.init(payload, 1);
    const reqID = bufferParser$1.readUInt32BE();
    const oldPath = bufferParser$1.readString(true);
    const newPath = bufferParser$1.readString(true);
    bufferParser$1.clear();
    if (newPath === void 0)
      return doFatalSFTPError(sftp, "Malformed RENAME packet");
    sftp._debug && sftp._debug(`SFTP: Inbound: Received RENAME (id:${reqID})`);
    if (!sftp.emit("RENAME", reqID, oldPath, newPath)) {
      sftp.status(reqID, STATUS_CODE$1.OP_UNSUPPORTED);
    }
  },
  [REQUEST.READLINK]: (sftp, payload) => {
    bufferParser$1.init(payload, 1);
    const reqID = bufferParser$1.readUInt32BE();
    const path2 = bufferParser$1.readString(true);
    bufferParser$1.clear();
    if (path2 === void 0)
      return doFatalSFTPError(sftp, "Malformed READLINK packet");
    sftp._debug && sftp._debug(
      `SFTP: Inbound: Received READLINK (id:${reqID})`
    );
    if (!sftp.emit("READLINK", reqID, path2)) {
      sftp.status(reqID, STATUS_CODE$1.OP_UNSUPPORTED);
    }
  },
  [REQUEST.SYMLINK]: (sftp, payload) => {
    bufferParser$1.init(payload, 1);
    const reqID = bufferParser$1.readUInt32BE();
    const linkPath = bufferParser$1.readString(true);
    const targetPath = bufferParser$1.readString(true);
    bufferParser$1.clear();
    if (targetPath === void 0)
      return doFatalSFTPError(sftp, "Malformed SYMLINK packet");
    sftp._debug && sftp._debug(`SFTP: Inbound: Received SYMLINK (id:${reqID})`);
    let handled;
    if (sftp._isOpenSSH) {
      handled = sftp.emit("SYMLINK", reqID, targetPath, linkPath);
    } else {
      handled = sftp.emit("SYMLINK", reqID, linkPath, targetPath);
    }
    if (!handled) {
      sftp.status(reqID, STATUS_CODE$1.OP_UNSUPPORTED);
    }
  },
  [REQUEST.EXTENDED]: (sftp, payload) => {
    bufferParser$1.init(payload, 1);
    const reqID = bufferParser$1.readUInt32BE();
    const extName = bufferParser$1.readString(true);
    if (extName === void 0) {
      bufferParser$1.clear();
      return doFatalSFTPError(sftp, "Malformed EXTENDED packet");
    }
    let extData;
    if (bufferParser$1.avail())
      extData = bufferParser$1.readRaw();
    bufferParser$1.clear();
    sftp._debug && sftp._debug(
      `SFTP: Inbound: Received EXTENDED (id:${reqID})`
    );
    if (!sftp.emit("EXTENDED", reqID, extName, extData)) {
      sftp.status(reqID, STATUS_CODE$1.OP_UNSUPPORTED);
    }
  }
};
const {
  ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
  ERR_OUT_OF_RANGE: ERR_OUT_OF_RANGE2,
  validateNumber: validateNumber2
} = nodeFsCompat;
const kMinPoolSpace = 128;
let pool;
const poolFragments = [];
function allocNewPool(poolSize) {
  if (poolFragments.length > 0)
    pool = poolFragments.pop();
  else
    pool = Buffer.allocUnsafe(poolSize);
  pool.used = 0;
}
function checkPosition(pos, name) {
  if (!Number.isSafeInteger(pos)) {
    validateNumber2(pos, name);
    if (!Number.isInteger(pos))
      throw new ERR_OUT_OF_RANGE2(name, "an integer", pos);
    throw new ERR_OUT_OF_RANGE2(name, ">= 0 and <= 2 ** 53 - 1", pos);
  }
  if (pos < 0)
    throw new ERR_OUT_OF_RANGE2(name, ">= 0 and <= 2 ** 53 - 1", pos);
}
function roundUpToMultipleOf8(n) {
  return n + 7 & -8;
}
function ReadStream(sftp, path2, options) {
  if (options === void 0)
    options = {};
  else if (typeof options === "string")
    options = { encoding: options };
  else if (options === null || typeof options !== "object")
    throw new TypeError('"options" argument must be a string or an object');
  else
    options = Object.create(options);
  if (options.highWaterMark === void 0)
    options.highWaterMark = 64 * 1024;
  options.emitClose = false;
  options.autoDestroy = false;
  ReadableStream$1.call(this, options);
  this.path = path2;
  this.flags = options.flags === void 0 ? "r" : options.flags;
  this.mode = options.mode === void 0 ? 438 : options.mode;
  this.start = options.start;
  this.end = options.end;
  this.autoClose = options.autoClose === void 0 ? true : options.autoClose;
  this.pos = 0;
  this.bytesRead = 0;
  this.isClosed = false;
  this.handle = options.handle === void 0 ? null : options.handle;
  this.sftp = sftp;
  this._opening = false;
  if (this.start !== void 0) {
    checkPosition(this.start, "start");
    this.pos = this.start;
  }
  if (this.end === void 0) {
    this.end = Infinity;
  } else if (this.end !== Infinity) {
    checkPosition(this.end, "end");
    if (this.start !== void 0 && this.start > this.end) {
      throw new ERR_OUT_OF_RANGE2(
        "start",
        `<= "end" (here: ${this.end})`,
        this.start
      );
    }
  }
  this.on("end", function() {
    if (this.autoClose)
      this.destroy();
  });
  if (!Buffer.isBuffer(this.handle))
    this.open();
}
inherits(ReadStream, ReadableStream$1);
ReadStream.prototype.open = function() {
  if (this._opening)
    return;
  this._opening = true;
  this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {
    this._opening = false;
    if (er) {
      this.emit("error", er);
      if (this.autoClose)
        this.destroy();
      return;
    }
    this.handle = handle;
    this.emit("open", handle);
    this.emit("ready");
    this.read();
  });
};
ReadStream.prototype._read = function(n) {
  if (!Buffer.isBuffer(this.handle))
    return this.once("open", () => this._read(n));
  if (this.destroyed)
    return;
  if (!pool || pool.length - pool.used < kMinPoolSpace) {
    allocNewPool(this.readableHighWaterMark || this._readableState.highWaterMark);
  }
  const thisPool = pool;
  let toRead = Math.min(pool.length - pool.used, n);
  const start = pool.used;
  if (this.end !== void 0)
    toRead = Math.min(this.end - this.pos + 1, toRead);
  if (toRead <= 0)
    return this.push(null);
  this.sftp.read(
    this.handle,
    pool,
    pool.used,
    toRead,
    this.pos,
    (er, bytesRead) => {
      if (er) {
        this.emit("error", er);
        if (this.autoClose)
          this.destroy();
        return;
      }
      let b = null;
      if (start + toRead === thisPool.used && thisPool === pool) {
        thisPool.used = roundUpToMultipleOf8(thisPool.used + bytesRead - toRead);
      } else {
        const alignedEnd = start + toRead & -8;
        const alignedStart = roundUpToMultipleOf8(start + bytesRead);
        if (alignedEnd - alignedStart >= kMinPoolSpace)
          poolFragments.push(thisPool.slice(alignedStart, alignedEnd));
      }
      if (bytesRead > 0) {
        this.bytesRead += bytesRead;
        b = thisPool.slice(start, start + bytesRead);
      }
      this.pos += bytesRead;
      this.push(b);
    }
  );
  pool.used = roundUpToMultipleOf8(pool.used + toRead);
};
ReadStream.prototype._destroy = function(err, cb) {
  if (this._opening && !Buffer.isBuffer(this.handle)) {
    this.once("open", closeStream.bind(null, this, cb, err));
    return;
  }
  closeStream(this, cb, err);
  this.handle = null;
  this._opening = false;
};
function closeStream(stream, cb, err) {
  if (!stream.handle)
    return onclose();
  stream.sftp.close(stream.handle, onclose);
  function onclose(er) {
    er = er || err;
    cb(er);
    stream.isClosed = true;
    if (!er)
      stream.emit("close");
  }
}
ReadStream.prototype.close = function(cb) {
  this.destroy(null, cb);
};
Object.defineProperty(ReadStream.prototype, "pending", {
  get() {
    return this.handle === null;
  },
  configurable: true
});
function WriteStream(sftp, path2, options) {
  if (options === void 0)
    options = {};
  else if (typeof options === "string")
    options = { encoding: options };
  else if (options === null || typeof options !== "object")
    throw new TypeError('"options" argument must be a string or an object');
  else
    options = Object.create(options);
  options.emitClose = false;
  options.autoDestroy = false;
  WritableStream$1.call(this, options);
  this.path = path2;
  this.flags = options.flags === void 0 ? "w" : options.flags;
  this.mode = options.mode === void 0 ? 438 : options.mode;
  this.start = options.start;
  this.autoClose = options.autoClose === void 0 ? true : options.autoClose;
  this.pos = 0;
  this.bytesWritten = 0;
  this.isClosed = false;
  this.handle = options.handle === void 0 ? null : options.handle;
  this.sftp = sftp;
  this._opening = false;
  if (this.start !== void 0) {
    checkPosition(this.start, "start");
    this.pos = this.start;
  }
  if (options.encoding)
    this.setDefaultEncoding(options.encoding);
  this.on("finish", function() {
    if (this._writableState.finalCalled)
      return;
    if (this.autoClose)
      this.destroy();
  });
  if (!Buffer.isBuffer(this.handle))
    this.open();
}
inherits(WriteStream, WritableStream$1);
WriteStream.prototype._final = function(cb) {
  if (this.autoClose)
    this.destroy();
  cb();
};
WriteStream.prototype.open = function() {
  if (this._opening)
    return;
  this._opening = true;
  this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {
    this._opening = false;
    if (er) {
      this.emit("error", er);
      if (this.autoClose)
        this.destroy();
      return;
    }
    this.handle = handle;
    const tryAgain = (err) => {
      if (err) {
        this.sftp.chmod(this.path, this.mode, (err_) => tryAgain());
        return;
      }
      if (this.flags[0] === "a") {
        const tryStat = (err2, st) => {
          if (err2) {
            this.sftp.stat(this.path, (err_, st_) => {
              if (err_) {
                this.destroy();
                this.emit("error", err2);
                return;
              }
              tryStat(null, st_);
            });
            return;
          }
          this.pos = st.size;
          this.emit("open", handle);
          this.emit("ready");
        };
        this.sftp.fstat(handle, tryStat);
        return;
      }
      this.emit("open", handle);
      this.emit("ready");
    };
    this.sftp.fchmod(handle, this.mode, tryAgain);
  });
};
WriteStream.prototype._write = function(data, encoding, cb) {
  if (!Buffer.isBuffer(data)) {
    const err = new ERR_INVALID_ARG_TYPE2("data", "Buffer", data);
    return this.emit("error", err);
  }
  if (!Buffer.isBuffer(this.handle)) {
    return this.once("open", function() {
      this._write(data, encoding, cb);
    });
  }
  this.sftp.write(
    this.handle,
    data,
    0,
    data.length,
    this.pos,
    (er, bytes) => {
      if (er) {
        if (this.autoClose)
          this.destroy();
        return cb(er);
      }
      this.bytesWritten += bytes;
      cb();
    }
  );
  this.pos += data.length;
};
WriteStream.prototype._writev = function(data, cb) {
  if (!Buffer.isBuffer(this.handle)) {
    return this.once("open", function() {
      this._writev(data, cb);
    });
  }
  const sftp = this.sftp;
  const handle = this.handle;
  let writesLeft = data.length;
  const onwrite = (er, bytes) => {
    if (er) {
      this.destroy();
      return cb(er);
    }
    this.bytesWritten += bytes;
    if (--writesLeft === 0)
      cb();
  };
  for (let i = 0; i < data.length; ++i) {
    const chunk = data[i].chunk;
    sftp.write(handle, chunk, 0, chunk.length, this.pos, onwrite);
    this.pos += chunk.length;
  }
};
if (typeof WritableStream$1.prototype.destroy !== "function")
  WriteStream.prototype.destroy = ReadStream.prototype.destroy;
WriteStream.prototype._destroy = ReadStream.prototype._destroy;
WriteStream.prototype.close = function(cb) {
  if (cb) {
    if (this.isClosed) {
      process.nextTick(cb);
      return;
    }
    this.on("close", cb);
  }
  if (!this.autoClose)
    this.on("finish", this.destroy.bind(this));
  this.end();
};
WriteStream.prototype.destroySoon = WriteStream.prototype.end;
Object.defineProperty(WriteStream.prototype, "pending", {
  get() {
    return this.handle === null;
  },
  configurable: true
});
var SFTP_1 = {
  flagsToString: flagsToString$1,
  OPEN_MODE: OPEN_MODE$1,
  SFTP: SFTP$3,
  STATUS_CODE: STATUS_CODE$1,
  stringToFlags: stringToFlags$1
};
const {
  Duplex: DuplexStream,
  Readable: ReadableStream,
  Writable: WritableStream
} = require$$1$3;
const {
  CHANNEL_EXTENDED_DATATYPE: { STDERR: STDERR$1 }
} = requireConstants();
const { bufferSlice } = requireUtils();
const PACKET_SIZE$2 = 32 * 1024;
const MAX_WINDOW$2 = 2 * 1024 * 1024;
const WINDOW_THRESHOLD$2 = MAX_WINDOW$2 / 2;
class ClientStderr extends ReadableStream {
  constructor(channel, streamOpts) {
    super(streamOpts);
    this._channel = channel;
  }
  _read(n) {
    if (this._channel._waitChanDrain) {
      this._channel._waitChanDrain = false;
      if (this._channel.incoming.window <= WINDOW_THRESHOLD$2)
        windowAdjust$2(this._channel);
    }
  }
}
class ServerStderr extends WritableStream {
  constructor(channel) {
    super({ highWaterMark: MAX_WINDOW$2 });
    this._channel = channel;
  }
  _write(data, encoding, cb) {
    const channel = this._channel;
    const protocol = channel._client._protocol;
    const outgoing = channel.outgoing;
    const packetSize = outgoing.packetSize;
    const id2 = outgoing.id;
    let window2 = outgoing.window;
    const len = data.length;
    let p = 0;
    if (outgoing.state !== "open")
      return;
    while (len - p > 0 && window2 > 0) {
      let sliceLen = len - p;
      if (sliceLen > window2)
        sliceLen = window2;
      if (sliceLen > packetSize)
        sliceLen = packetSize;
      if (p === 0 && sliceLen === len)
        protocol.channelExtData(id2, data, STDERR$1);
      else
        protocol.channelExtData(id2, bufferSlice(data, p, p + sliceLen), STDERR$1);
      p += sliceLen;
      window2 -= sliceLen;
    }
    outgoing.window = window2;
    if (len - p > 0) {
      if (window2 === 0)
        channel._waitWindow = true;
      if (p > 0)
        channel._chunkErr = bufferSlice(data, p, len);
      else
        channel._chunkErr = data;
      channel._chunkcbErr = cb;
      return;
    }
    cb();
  }
}
let Channel$2 = class Channel extends DuplexStream {
  constructor(client2, info, opts) {
    const streamOpts = {
      highWaterMark: MAX_WINDOW$2,
      allowHalfOpen: !opts || opts && opts.allowHalfOpen !== false,
      emitClose: false
    };
    super(streamOpts);
    this.allowHalfOpen = streamOpts.allowHalfOpen;
    const server2 = !!(opts && opts.server);
    this.server = server2;
    this.type = info.type;
    this.subtype = void 0;
    this.incoming = info.incoming;
    this.outgoing = info.outgoing;
    this._callbacks = [];
    this._client = client2;
    this._hasX11 = false;
    this._exit = {
      code: void 0,
      signal: void 0,
      dump: void 0,
      desc: void 0
    };
    this.stdin = this.stdout = this;
    if (server2)
      this.stderr = new ServerStderr(this);
    else
      this.stderr = new ClientStderr(this, streamOpts);
    this._waitWindow = false;
    this._waitChanDrain = false;
    this._chunk = void 0;
    this._chunkcb = void 0;
    this._chunkErr = void 0;
    this._chunkcbErr = void 0;
    this.on("finish", onFinish).on("prefinish", onFinish);
    this.on("end", onEnd).on("close", onEnd);
  }
  _read(n) {
    if (this._waitChanDrain) {
      this._waitChanDrain = false;
      if (this.incoming.window <= WINDOW_THRESHOLD$2)
        windowAdjust$2(this);
    }
  }
  _write(data, encoding, cb) {
    const protocol = this._client._protocol;
    const outgoing = this.outgoing;
    const packetSize = outgoing.packetSize;
    const id2 = outgoing.id;
    let window2 = outgoing.window;
    const len = data.length;
    let p = 0;
    if (outgoing.state !== "open")
      return;
    while (len - p > 0 && window2 > 0) {
      let sliceLen = len - p;
      if (sliceLen > window2)
        sliceLen = window2;
      if (sliceLen > packetSize)
        sliceLen = packetSize;
      if (p === 0 && sliceLen === len)
        protocol.channelData(id2, data);
      else
        protocol.channelData(id2, bufferSlice(data, p, p + sliceLen));
      p += sliceLen;
      window2 -= sliceLen;
    }
    outgoing.window = window2;
    if (len - p > 0) {
      if (window2 === 0)
        this._waitWindow = true;
      if (p > 0)
        this._chunk = bufferSlice(data, p, len);
      else
        this._chunk = data;
      this._chunkcb = cb;
      return;
    }
    cb();
  }
  eof() {
    if (this.outgoing.state === "open") {
      this.outgoing.state = "eof";
      this._client._protocol.channelEOF(this.outgoing.id);
    }
  }
  close() {
    if (this.outgoing.state === "open" || this.outgoing.state === "eof") {
      this.outgoing.state = "closing";
      this._client._protocol.channelClose(this.outgoing.id);
    }
  }
  destroy() {
    this.end();
    this.close();
    return this;
  }
  // Session type-specific methods =============================================
  setWindow(rows, cols, height, width) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (this.type === "session" && (this.subtype === "shell" || this.subtype === "exec") && this.writable && this.outgoing.state === "open") {
      this._client._protocol.windowChange(
        this.outgoing.id,
        rows,
        cols,
        height,
        width
      );
    }
  }
  signal(signalName) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (this.type === "session" && this.writable && this.outgoing.state === "open") {
      this._client._protocol.signal(this.outgoing.id, signalName);
    }
  }
  exit(statusOrSignal, coreDumped, msg) {
    if (!this.server)
      throw new Error("Server-only method called in client mode");
    if (this.type === "session" && this.writable && this.outgoing.state === "open") {
      if (typeof statusOrSignal === "number") {
        this._client._protocol.exitStatus(this.outgoing.id, statusOrSignal);
      } else {
        this._client._protocol.exitSignal(
          this.outgoing.id,
          statusOrSignal,
          coreDumped,
          msg
        );
      }
    }
  }
};
function onFinish() {
  this.eof();
  if (this.server || !this.allowHalfOpen)
    this.close();
  this.writable = false;
}
function onEnd() {
  this.readable = false;
}
function windowAdjust$2(self2) {
  if (self2.outgoing.state === "closed")
    return;
  const amt = MAX_WINDOW$2 - self2.incoming.window;
  if (amt <= 0)
    return;
  self2.incoming.window += amt;
  self2._client._protocol.channelWindowAdjust(self2.outgoing.id, amt);
}
var Channel_1 = {
  Channel: Channel$2,
  MAX_WINDOW: MAX_WINDOW$2,
  PACKET_SIZE: PACKET_SIZE$2,
  windowAdjust: windowAdjust$2,
  WINDOW_THRESHOLD: WINDOW_THRESHOLD$2
};
const { SFTP: SFTP$2 } = SFTP_1;
const MAX_CHANNEL = 2 ** 32 - 1;
function onChannelOpenFailure$2(self2, recipient, info, cb) {
  self2._chanMgr.remove(recipient);
  if (typeof cb !== "function")
    return;
  let err;
  if (info instanceof Error) {
    err = info;
  } else if (typeof info === "object" && info !== null) {
    err = new Error(`(SSH) Channel open failure: ${info.description}`);
    err.reason = info.reason;
  } else {
    err = new Error(
      "(SSH) Channel open failure: server closed channel unexpectedly"
    );
    err.reason = "";
  }
  cb(err);
}
function onCHANNEL_CLOSE$2(self2, recipient, channel, err, dead) {
  if (typeof channel === "function") {
    onChannelOpenFailure$2(self2, recipient, err, channel);
    return;
  }
  if (typeof channel !== "object" || channel === null)
    return;
  if (channel.incoming && channel.incoming.state === "closed")
    return;
  self2._chanMgr.remove(recipient);
  if (channel.server && channel.constructor.name === "Session")
    return;
  channel.incoming.state = "closed";
  if (channel.readable)
    channel.push(null);
  if (channel.server) {
    if (channel.stderr.writable)
      channel.stderr.end();
  } else if (channel.stderr.readable) {
    channel.stderr.push(null);
  }
  if (channel.constructor !== SFTP$2 && (channel.outgoing.state === "open" || channel.outgoing.state === "eof") && !dead) {
    channel.close();
  }
  if (channel.outgoing.state === "closing")
    channel.outgoing.state = "closed";
  const readState = channel._readableState;
  const writeState = channel._writableState;
  if (writeState && !writeState.ending && !writeState.finished && !dead)
    channel.end();
  const chanCallbacks = channel._callbacks;
  channel._callbacks = [];
  for (let i = 0; i < chanCallbacks.length; ++i)
    chanCallbacks[i](true);
  if (channel.server) {
    if (!channel.readable || channel.destroyed || readState && readState.endEmitted) {
      channel.emit("close");
    } else {
      channel.once("end", () => channel.emit("close"));
    }
  } else {
    let doClose;
    switch (channel.type) {
      case "direct-streamlocal@openssh.com":
      case "direct-tcpip":
        doClose = () => channel.emit("close");
        break;
      default: {
        const exit = channel._exit;
        doClose = () => {
          if (exit.code === null)
            channel.emit("close", exit.code, exit.signal, exit.dump, exit.desc);
          else
            channel.emit("close", exit.code);
        };
      }
    }
    if (!channel.readable || channel.destroyed || readState && readState.endEmitted) {
      doClose();
    } else {
      channel.once("end", doClose);
    }
    const errReadState = channel.stderr._readableState;
    if (!channel.stderr.readable || channel.stderr.destroyed || errReadState && errReadState.endEmitted) {
      channel.stderr.emit("close");
    } else {
      channel.stderr.once("end", () => channel.stderr.emit("close"));
    }
  }
}
let ChannelManager$2 = class ChannelManager {
  constructor(client2) {
    this._client = client2;
    this._channels = {};
    this._cur = -1;
    this._count = 0;
  }
  add(val) {
    let id2;
    if (this._cur < MAX_CHANNEL) {
      id2 = ++this._cur;
    } else if (this._count === 0) {
      this._cur = 0;
      id2 = 0;
    } else {
      const channels = this._channels;
      for (let i = 0; i < MAX_CHANNEL; ++i) {
        if (channels[i] === void 0) {
          id2 = i;
          break;
        }
      }
    }
    if (id2 === void 0)
      return -1;
    this._channels[id2] = val || true;
    ++this._count;
    return id2;
  }
  update(id2, val) {
    if (typeof id2 !== "number" || id2 < 0 || id2 >= MAX_CHANNEL || !isFinite(id2))
      throw new Error(`Invalid channel id: ${id2}`);
    if (val && this._channels[id2])
      this._channels[id2] = val;
  }
  get(id2) {
    if (typeof id2 !== "number" || id2 < 0 || id2 >= MAX_CHANNEL || !isFinite(id2))
      throw new Error(`Invalid channel id: ${id2}`);
    return this._channels[id2];
  }
  remove(id2) {
    if (typeof id2 !== "number" || id2 < 0 || id2 >= MAX_CHANNEL || !isFinite(id2))
      throw new Error(`Invalid channel id: ${id2}`);
    if (this._channels[id2]) {
      delete this._channels[id2];
      if (this._count)
        --this._count;
    }
  }
  cleanup(err) {
    const channels = this._channels;
    this._channels = {};
    this._cur = -1;
    this._count = 0;
    const chanIDs = Object.keys(channels);
    const client2 = this._client;
    for (let i = 0; i < chanIDs.length; ++i) {
      const id2 = +chanIDs[i];
      const channel = channels[id2];
      onCHANNEL_CLOSE$2(client2, id2, channel._channel || channel, err, true);
    }
  }
};
const isRegExp = /* @__PURE__ */ (() => {
  const toString = Object.prototype.toString;
  return (val) => toString.call(val) === "[object RegExp]";
})();
function generateAlgorithmList$2(algoList, defaultList, supportedList) {
  if (Array.isArray(algoList) && algoList.length > 0) {
    for (let i = 0; i < algoList.length; ++i) {
      if (supportedList.indexOf(algoList[i]) === -1)
        throw new Error(`Unsupported algorithm: ${algoList[i]}`);
    }
    return algoList;
  }
  if (typeof algoList === "object" && algoList !== null) {
    const keys = Object.keys(algoList);
    let list = defaultList;
    for (let i = 0; i < keys.length; ++i) {
      const key2 = keys[i];
      let val = algoList[key2];
      switch (key2) {
        case "append":
          if (!Array.isArray(val))
            val = [val];
          if (Array.isArray(val)) {
            for (let j = 0; j < val.length; ++j) {
              const append = val[j];
              if (typeof append === "string") {
                if (!append || list.indexOf(append) !== -1)
                  continue;
                if (supportedList.indexOf(append) === -1)
                  throw new Error(`Unsupported algorithm: ${append}`);
                if (list === defaultList)
                  list = list.slice();
                list.push(append);
              } else if (isRegExp(append)) {
                for (let k = 0; k < supportedList.length; ++k) {
                  const algo = supportedList[k];
                  if (append.test(algo)) {
                    if (list.indexOf(algo) !== -1)
                      continue;
                    if (list === defaultList)
                      list = list.slice();
                    list.push(algo);
                  }
                }
              }
            }
          }
          break;
        case "prepend":
          if (!Array.isArray(val))
            val = [val];
          if (Array.isArray(val)) {
            for (let j = val.length; j >= 0; --j) {
              const prepend = val[j];
              if (typeof prepend === "string") {
                if (!prepend || list.indexOf(prepend) !== -1)
                  continue;
                if (supportedList.indexOf(prepend) === -1)
                  throw new Error(`Unsupported algorithm: ${prepend}`);
                if (list === defaultList)
                  list = list.slice();
                list.unshift(prepend);
              } else if (isRegExp(prepend)) {
                for (let k = supportedList.length; k >= 0; --k) {
                  const algo = supportedList[k];
                  if (prepend.test(algo)) {
                    if (list.indexOf(algo) !== -1)
                      continue;
                    if (list === defaultList)
                      list = list.slice();
                    list.unshift(algo);
                  }
                }
              }
            }
          }
          break;
        case "remove":
          if (!Array.isArray(val))
            val = [val];
          if (Array.isArray(val)) {
            for (let j = 0; j < val.length; ++j) {
              const search = val[j];
              if (typeof search === "string") {
                if (!search)
                  continue;
                const idx = list.indexOf(search);
                if (idx === -1)
                  continue;
                if (list === defaultList)
                  list = list.slice();
                list.splice(idx, 1);
              } else if (isRegExp(search)) {
                for (let k = 0; k < list.length; ++k) {
                  if (search.test(list[k])) {
                    if (list === defaultList)
                      list = list.slice();
                    list.splice(k, 1);
                    --k;
                  }
                }
              }
            }
          }
          break;
      }
    }
    return list;
  }
  return defaultList;
}
var utils = {
  ChannelManager: ChannelManager$2,
  generateAlgorithmList: generateAlgorithmList$2,
  onChannelOpenFailure: onChannelOpenFailure$2,
  onCHANNEL_CLOSE: onCHANNEL_CLOSE$2,
  isWritable: (stream) => {
    return stream && stream.writable && stream._readableState && stream._readableState.ended === false;
  }
};
const {
  createHash,
  getHashes,
  randomFillSync
} = require$$0$3;
const { Socket } = require$$0$5;
const { lookup: dnsLookup } = require$$2;
const EventEmitter$1 = require$$5;
const HASHES = getHashes();
const {
  COMPAT,
  CHANNEL_EXTENDED_DATATYPE: { STDERR },
  CHANNEL_OPEN_FAILURE: CHANNEL_OPEN_FAILURE$1,
  DEFAULT_CIPHER: DEFAULT_CIPHER$1,
  DEFAULT_COMPRESSION: DEFAULT_COMPRESSION$1,
  DEFAULT_KEX: DEFAULT_KEX$1,
  DEFAULT_MAC: DEFAULT_MAC$1,
  DEFAULT_SERVER_HOST_KEY: DEFAULT_SERVER_HOST_KEY$1,
  DISCONNECT_REASON: DISCONNECT_REASON$1,
  DISCONNECT_REASON_BY_VALUE: DISCONNECT_REASON_BY_VALUE$1,
  SUPPORTED_CIPHER: SUPPORTED_CIPHER$1,
  SUPPORTED_COMPRESSION: SUPPORTED_COMPRESSION$1,
  SUPPORTED_KEX: SUPPORTED_KEX$1,
  SUPPORTED_MAC: SUPPORTED_MAC$1,
  SUPPORTED_SERVER_HOST_KEY: SUPPORTED_SERVER_HOST_KEY$1
} = requireConstants();
const { init: cryptoInit$1 } = requireCrypto();
const Protocol$1 = Protocol_1;
const { parseKey: parseKey$2 } = keyParser;
const { SFTP: SFTP$1 } = SFTP_1;
const {
  bufferCopy,
  makeBufferParser,
  makeError,
  readUInt32BE,
  sigSSHToASN1,
  writeUInt32BE: writeUInt32BE$1
} = requireUtils();
const { AgentContext: AgentContext2, createAgent: createAgent$1, isAgent } = agent;
const {
  Channel: Channel$1,
  MAX_WINDOW: MAX_WINDOW$1,
  PACKET_SIZE: PACKET_SIZE$1,
  windowAdjust: windowAdjust$1,
  WINDOW_THRESHOLD: WINDOW_THRESHOLD$1
} = Channel_1;
const {
  ChannelManager: ChannelManager$1,
  generateAlgorithmList: generateAlgorithmList$1,
  isWritable: isWritable$1,
  onChannelOpenFailure: onChannelOpenFailure$1,
  onCHANNEL_CLOSE: onCHANNEL_CLOSE$1
} = utils;
const bufferParser = makeBufferParser();
const sigParser = makeBufferParser();
const RE_OPENSSH = /^OpenSSH_(?:(?![0-4])\d)|(?:\d{2,})/;
const noop$1 = (err) => {
};
let Client$1 = class Client extends EventEmitter$1 {
  constructor() {
    super();
    this.config = {
      host: void 0,
      port: void 0,
      localAddress: void 0,
      localPort: void 0,
      forceIPv4: void 0,
      forceIPv6: void 0,
      keepaliveCountMax: void 0,
      keepaliveInterval: void 0,
      readyTimeout: void 0,
      ident: void 0,
      username: void 0,
      password: void 0,
      privateKey: void 0,
      tryKeyboard: void 0,
      agent: void 0,
      allowAgentFwd: void 0,
      authHandler: void 0,
      hostHashAlgo: void 0,
      hostHashCb: void 0,
      strictVendor: void 0,
      debug: void 0
    };
    this._agent = void 0;
    this._readyTimeout = void 0;
    this._chanMgr = void 0;
    this._callbacks = void 0;
    this._forwarding = void 0;
    this._forwardingUnix = void 0;
    this._acceptX11 = void 0;
    this._agentFwdEnabled = void 0;
    this._remoteVer = void 0;
    this._protocol = void 0;
    this._sock = void 0;
    this._resetKA = void 0;
  }
  connect(cfg) {
    if (this._sock && isWritable$1(this._sock)) {
      this.once("close", () => {
        this.connect(cfg);
      });
      this.end();
      return this;
    }
    this.config.host = cfg.hostname || cfg.host || "localhost";
    this.config.port = cfg.port || 22;
    this.config.localAddress = typeof cfg.localAddress === "string" ? cfg.localAddress : void 0;
    this.config.localPort = typeof cfg.localPort === "string" || typeof cfg.localPort === "number" ? cfg.localPort : void 0;
    this.config.forceIPv4 = cfg.forceIPv4 || false;
    this.config.forceIPv6 = cfg.forceIPv6 || false;
    this.config.keepaliveCountMax = typeof cfg.keepaliveCountMax === "number" && cfg.keepaliveCountMax >= 0 ? cfg.keepaliveCountMax : 3;
    this.config.keepaliveInterval = typeof cfg.keepaliveInterval === "number" && cfg.keepaliveInterval > 0 ? cfg.keepaliveInterval : 0;
    this.config.readyTimeout = typeof cfg.readyTimeout === "number" && cfg.readyTimeout >= 0 ? cfg.readyTimeout : 2e4;
    this.config.ident = typeof cfg.ident === "string" || Buffer.isBuffer(cfg.ident) ? cfg.ident : void 0;
    const algorithms = {
      kex: void 0,
      serverHostKey: void 0,
      cs: {
        cipher: void 0,
        mac: void 0,
        compress: void 0,
        lang: []
      },
      sc: void 0
    };
    let allOfferDefaults = true;
    if (typeof cfg.algorithms === "object" && cfg.algorithms !== null) {
      algorithms.kex = generateAlgorithmList$1(
        cfg.algorithms.kex,
        DEFAULT_KEX$1,
        SUPPORTED_KEX$1
      );
      if (algorithms.kex !== DEFAULT_KEX$1)
        allOfferDefaults = false;
      algorithms.serverHostKey = generateAlgorithmList$1(
        cfg.algorithms.serverHostKey,
        DEFAULT_SERVER_HOST_KEY$1,
        SUPPORTED_SERVER_HOST_KEY$1
      );
      if (algorithms.serverHostKey !== DEFAULT_SERVER_HOST_KEY$1)
        allOfferDefaults = false;
      algorithms.cs.cipher = generateAlgorithmList$1(
        cfg.algorithms.cipher,
        DEFAULT_CIPHER$1,
        SUPPORTED_CIPHER$1
      );
      if (algorithms.cs.cipher !== DEFAULT_CIPHER$1)
        allOfferDefaults = false;
      algorithms.cs.mac = generateAlgorithmList$1(
        cfg.algorithms.hmac,
        DEFAULT_MAC$1,
        SUPPORTED_MAC$1
      );
      if (algorithms.cs.mac !== DEFAULT_MAC$1)
        allOfferDefaults = false;
      algorithms.cs.compress = generateAlgorithmList$1(
        cfg.algorithms.compress,
        DEFAULT_COMPRESSION$1,
        SUPPORTED_COMPRESSION$1
      );
      if (algorithms.cs.compress !== DEFAULT_COMPRESSION$1)
        allOfferDefaults = false;
      if (!allOfferDefaults)
        algorithms.sc = algorithms.cs;
    }
    if (typeof cfg.username === "string")
      this.config.username = cfg.username;
    else if (typeof cfg.user === "string")
      this.config.username = cfg.user;
    else
      throw new Error("Invalid username");
    this.config.password = typeof cfg.password === "string" ? cfg.password : void 0;
    this.config.privateKey = typeof cfg.privateKey === "string" || Buffer.isBuffer(cfg.privateKey) ? cfg.privateKey : void 0;
    this.config.localHostname = typeof cfg.localHostname === "string" ? cfg.localHostname : void 0;
    this.config.localUsername = typeof cfg.localUsername === "string" ? cfg.localUsername : void 0;
    this.config.tryKeyboard = cfg.tryKeyboard === true;
    if (typeof cfg.agent === "string" && cfg.agent.length)
      this.config.agent = createAgent$1(cfg.agent);
    else if (isAgent(cfg.agent))
      this.config.agent = cfg.agent;
    else
      this.config.agent = void 0;
    this.config.allowAgentFwd = cfg.agentForward === true && this.config.agent !== void 0;
    let authHandler = this.config.authHandler = typeof cfg.authHandler === "function" || Array.isArray(cfg.authHandler) ? cfg.authHandler : void 0;
    this.config.strictVendor = typeof cfg.strictVendor === "boolean" ? cfg.strictVendor : true;
    const debug2 = this.config.debug = typeof cfg.debug === "function" ? cfg.debug : void 0;
    if (cfg.agentForward === true && !this.config.allowAgentFwd) {
      throw new Error(
        "You must set a valid agent path to allow agent forwarding"
      );
    }
    let callbacks = this._callbacks = [];
    this._chanMgr = new ChannelManager$1(this);
    this._forwarding = {};
    this._forwardingUnix = {};
    this._acceptX11 = 0;
    this._agentFwdEnabled = false;
    this._agent = this.config.agent ? this.config.agent : void 0;
    this._remoteVer = void 0;
    let privateKey;
    if (this.config.privateKey) {
      privateKey = parseKey$2(this.config.privateKey, cfg.passphrase);
      if (privateKey instanceof Error)
        throw new Error(`Cannot parse privateKey: ${privateKey.message}`);
      if (Array.isArray(privateKey)) {
        privateKey = privateKey[0];
      }
      if (privateKey.getPrivatePEM() === null) {
        throw new Error(
          "privateKey value does not contain a (valid) private key"
        );
      }
    }
    let hostVerifier;
    if (typeof cfg.hostVerifier === "function") {
      const hashCb = cfg.hostVerifier;
      let hashAlgo;
      if (HASHES.indexOf(cfg.hostHash) !== -1) {
        hashAlgo = cfg.hostHash;
      }
      hostVerifier = (key2, verify) => {
        if (hashAlgo)
          key2 = createHash(hashAlgo).update(key2).digest("hex");
        const ret = hashCb(key2, verify);
        if (ret !== void 0)
          verify(ret);
      };
    }
    const sock = this._sock = cfg.sock || new Socket();
    let ready = false;
    let sawHeader = false;
    if (this._protocol)
      this._protocol.cleanup();
    const DEBUG_HANDLER = !debug2 ? void 0 : (p, display, msg) => {
      debug2(`Debug output from server: ${JSON.stringify(msg)}`);
    };
    let serverSigAlgs;
    const proto = this._protocol = new Protocol$1({
      ident: this.config.ident,
      offer: allOfferDefaults ? void 0 : algorithms,
      onWrite: (data) => {
        if (isWritable$1(sock))
          sock.write(data);
      },
      onError: (err) => {
        if (err.level === "handshake")
          clearTimeout(this._readyTimeout);
        if (!proto._destruct)
          sock.removeAllListeners("data");
        this.emit("error", err);
        try {
          sock.end();
        } catch {
        }
      },
      onHeader: (header) => {
        sawHeader = true;
        this._remoteVer = header.versions.software;
        if (header.greeting)
          this.emit("greeting", header.greeting);
      },
      onHandshakeComplete: (negotiated) => {
        this.emit("handshake", negotiated);
        if (!ready) {
          ready = true;
          proto.service("ssh-userauth");
        }
      },
      debug: debug2,
      hostVerifier,
      messageHandlers: {
        DEBUG: DEBUG_HANDLER,
        DISCONNECT: (p, reason, desc) => {
          if (reason !== DISCONNECT_REASON$1.BY_APPLICATION) {
            if (!desc) {
              desc = DISCONNECT_REASON_BY_VALUE$1[reason];
              if (desc === void 0)
                desc = `Unexpected disconnection reason: ${reason}`;
            }
            const err = new Error(desc);
            err.code = reason;
            this.emit("error", err);
          }
          sock.end();
        },
        SERVICE_ACCEPT: (p, name) => {
          if (name === "ssh-userauth")
            tryNextAuth();
        },
        EXT_INFO: (p, exts) => {
          if (serverSigAlgs === void 0) {
            for (const ext of exts) {
              if (ext.name === "server-sig-algs") {
                serverSigAlgs = ext.algs;
                return;
              }
            }
            serverSigAlgs = null;
          }
        },
        USERAUTH_BANNER: (p, msg) => {
          this.emit("banner", msg);
        },
        USERAUTH_SUCCESS: (p) => {
          resetKA();
          clearTimeout(this._readyTimeout);
          this.emit("ready");
        },
        USERAUTH_FAILURE: (p, authMethods, partialSuccess) => {
          if (curAuth.keyAlgos) {
            const oldKeyAlgo = curAuth.keyAlgos[0][0];
            if (debug2)
              debug2(`Client: ${curAuth.type} (${oldKeyAlgo}) auth failed`);
            curAuth.keyAlgos.shift();
            if (curAuth.keyAlgos.length) {
              const [keyAlgo, hashAlgo] = curAuth.keyAlgos[0];
              switch (curAuth.type) {
                case "agent":
                  proto.authPK(
                    curAuth.username,
                    curAuth.agentCtx.currentKey(),
                    keyAlgo
                  );
                  return;
                case "publickey":
                  proto.authPK(curAuth.username, curAuth.key, keyAlgo);
                  return;
                case "hostbased":
                  proto.authHostbased(
                    curAuth.username,
                    curAuth.key,
                    curAuth.localHostname,
                    curAuth.localUsername,
                    keyAlgo,
                    (buf, cb) => {
                      const signature = curAuth.key.sign(buf, hashAlgo);
                      if (signature instanceof Error) {
                        signature.message = `Error while signing with key: ${signature.message}`;
                        signature.level = "client-authentication";
                        this.emit("error", signature);
                        return tryNextAuth();
                      }
                      cb(signature);
                    }
                  );
                  return;
              }
            } else {
              curAuth.keyAlgos = void 0;
            }
          }
          if (curAuth.type === "agent") {
            const pos = curAuth.agentCtx.pos();
            debug2 && debug2(`Client: Agent key #${pos + 1} failed`);
            return tryNextAgentKey();
          }
          debug2 && debug2(`Client: ${curAuth.type} auth failed`);
          curPartial = partialSuccess;
          curAuthsLeft = authMethods;
          tryNextAuth();
        },
        USERAUTH_PASSWD_CHANGEREQ: (p, prompt) => {
          if (curAuth.type === "password") {
            this.emit("change password", prompt, (newPassword) => {
              proto.authPassword(
                this.config.username,
                this.config.password,
                newPassword
              );
            });
          }
        },
        USERAUTH_PK_OK: (p) => {
          let keyAlgo;
          let hashAlgo;
          if (curAuth.keyAlgos)
            [keyAlgo, hashAlgo] = curAuth.keyAlgos[0];
          if (curAuth.type === "agent") {
            const key2 = curAuth.agentCtx.currentKey();
            proto.authPK(curAuth.username, key2, keyAlgo, (buf, cb) => {
              const opts = { hash: hashAlgo };
              curAuth.agentCtx.sign(key2, buf, opts, (err, signed) => {
                if (err) {
                  err.level = "agent";
                  this.emit("error", err);
                } else {
                  return cb(signed);
                }
                tryNextAgentKey();
              });
            });
          } else if (curAuth.type === "publickey") {
            proto.authPK(curAuth.username, curAuth.key, keyAlgo, (buf, cb) => {
              const signature = curAuth.key.sign(buf, hashAlgo);
              if (signature instanceof Error) {
                signature.message = `Error signing data with key: ${signature.message}`;
                signature.level = "client-authentication";
                this.emit("error", signature);
                return tryNextAuth();
              }
              cb(signature);
            });
          }
        },
        USERAUTH_INFO_REQUEST: (p, name, instructions, prompts) => {
          if (curAuth.type === "keyboard-interactive") {
            const nprompts = Array.isArray(prompts) ? prompts.length : 0;
            if (nprompts === 0) {
              debug2 && debug2(
                "Client: Sending automatic USERAUTH_INFO_RESPONSE"
              );
              proto.authInfoRes();
              return;
            }
            curAuth.prompt(
              name,
              instructions,
              "",
              prompts,
              (answers) => {
                proto.authInfoRes(answers);
              }
            );
          }
        },
        REQUEST_SUCCESS: (p, data) => {
          if (callbacks.length)
            callbacks.shift()(false, data);
        },
        REQUEST_FAILURE: (p) => {
          if (callbacks.length)
            callbacks.shift()(true);
        },
        GLOBAL_REQUEST: (p, name, wantReply, data) => {
          switch (name) {
            case "hostkeys-00@openssh.com":
              hostKeysProve(this, data, (err, keys) => {
                if (err)
                  return;
                this.emit("hostkeys", keys);
              });
              if (wantReply)
                proto.requestSuccess();
              break;
            default:
              if (wantReply)
                proto.requestFailure();
          }
        },
        CHANNEL_OPEN: (p, info) => {
          onCHANNEL_OPEN(this, info);
        },
        CHANNEL_OPEN_CONFIRMATION: (p, info) => {
          const channel = this._chanMgr.get(info.recipient);
          if (typeof channel !== "function")
            return;
          const isSFTP = channel.type === "sftp";
          const type2 = isSFTP ? "session" : channel.type;
          const chanInfo = {
            type: type2,
            incoming: {
              id: info.recipient,
              window: MAX_WINDOW$1,
              packetSize: PACKET_SIZE$1,
              state: "open"
            },
            outgoing: {
              id: info.sender,
              window: info.window,
              packetSize: info.packetSize,
              state: "open"
            }
          };
          const instance = isSFTP ? new SFTP$1(this, chanInfo, { debug: debug2 }) : new Channel$1(this, chanInfo);
          this._chanMgr.update(info.recipient, instance);
          channel(void 0, instance);
        },
        CHANNEL_OPEN_FAILURE: (p, recipient, reason, description2) => {
          const channel = this._chanMgr.get(recipient);
          if (typeof channel !== "function")
            return;
          const info = { reason, description: description2 };
          onChannelOpenFailure$1(this, recipient, info, channel);
        },
        CHANNEL_DATA: (p, recipient, data) => {
          const channel = this._chanMgr.get(recipient);
          if (typeof channel !== "object" || channel === null)
            return;
          if (channel.incoming.window === 0)
            return;
          channel.incoming.window -= data.length;
          if (channel.push(data) === false) {
            channel._waitChanDrain = true;
            return;
          }
          if (channel.incoming.window <= WINDOW_THRESHOLD$1)
            windowAdjust$1(channel);
        },
        CHANNEL_EXTENDED_DATA: (p, recipient, data, type2) => {
          if (type2 !== STDERR)
            return;
          const channel = this._chanMgr.get(recipient);
          if (typeof channel !== "object" || channel === null)
            return;
          if (channel.incoming.window === 0)
            return;
          channel.incoming.window -= data.length;
          if (!channel.stderr.push(data)) {
            channel._waitChanDrain = true;
            return;
          }
          if (channel.incoming.window <= WINDOW_THRESHOLD$1)
            windowAdjust$1(channel);
        },
        CHANNEL_WINDOW_ADJUST: (p, recipient, amount) => {
          const channel = this._chanMgr.get(recipient);
          if (typeof channel !== "object" || channel === null)
            return;
          channel.outgoing.window += amount;
          if (channel._waitWindow) {
            channel._waitWindow = false;
            if (channel._chunk) {
              channel._write(channel._chunk, null, channel._chunkcb);
            } else if (channel._chunkcb) {
              channel._chunkcb();
            } else if (channel._chunkErr) {
              channel.stderr._write(
                channel._chunkErr,
                null,
                channel._chunkcbErr
              );
            } else if (channel._chunkcbErr) {
              channel._chunkcbErr();
            }
          }
        },
        CHANNEL_SUCCESS: (p, recipient) => {
          const channel = this._chanMgr.get(recipient);
          if (typeof channel !== "object" || channel === null)
            return;
          this._resetKA();
          if (channel._callbacks.length)
            channel._callbacks.shift()(false);
        },
        CHANNEL_FAILURE: (p, recipient) => {
          const channel = this._chanMgr.get(recipient);
          if (typeof channel !== "object" || channel === null)
            return;
          this._resetKA();
          if (channel._callbacks.length)
            channel._callbacks.shift()(true);
        },
        CHANNEL_REQUEST: (p, recipient, type2, wantReply, data) => {
          const channel = this._chanMgr.get(recipient);
          if (typeof channel !== "object" || channel === null)
            return;
          const exit = channel._exit;
          if (exit.code !== void 0)
            return;
          switch (type2) {
            case "exit-status":
              channel.emit("exit", exit.code = data);
              return;
            case "exit-signal":
              channel.emit(
                "exit",
                exit.code = null,
                exit.signal = `SIG${data.signal}`,
                exit.dump = data.coreDumped,
                exit.desc = data.errorMessage
              );
              return;
          }
          if (wantReply)
            p.channelFailure(channel.outgoing.id);
        },
        CHANNEL_EOF: (p, recipient) => {
          const channel = this._chanMgr.get(recipient);
          if (typeof channel !== "object" || channel === null)
            return;
          if (channel.incoming.state !== "open")
            return;
          channel.incoming.state = "eof";
          if (channel.readable)
            channel.push(null);
          if (channel.stderr.readable)
            channel.stderr.push(null);
        },
        CHANNEL_CLOSE: (p, recipient) => {
          onCHANNEL_CLOSE$1(this, recipient, this._chanMgr.get(recipient));
        }
      }
    });
    sock.pause();
    const kainterval = this.config.keepaliveInterval;
    const kacountmax = this.config.keepaliveCountMax;
    let kacount = 0;
    let katimer;
    const sendKA = () => {
      if (++kacount > kacountmax) {
        clearInterval(katimer);
        if (sock.readable) {
          const err = new Error("Keepalive timeout");
          err.level = "client-timeout";
          this.emit("error", err);
          sock.destroy();
        }
        return;
      }
      if (isWritable$1(sock)) {
        callbacks.push(resetKA);
        proto.ping();
      } else {
        clearInterval(katimer);
      }
    };
    function resetKA() {
      if (kainterval > 0) {
        kacount = 0;
        clearInterval(katimer);
        if (isWritable$1(sock))
          katimer = setInterval(sendKA, kainterval);
      }
    }
    this._resetKA = resetKA;
    const onDone = /* @__PURE__ */ (() => {
      let called = false;
      return () => {
        if (called)
          return;
        called = true;
        if (wasConnected && !sawHeader) {
          const err = makeError("Connection lost before handshake", "protocol", true);
          this.emit("error", err);
        }
      };
    })();
    const onConnect = /* @__PURE__ */ (() => {
      let called = false;
      return () => {
        if (called)
          return;
        called = true;
        wasConnected = true;
        debug2 && debug2("Socket connected");
        this.emit("connect");
        cryptoInit$1.then(() => {
          proto.start();
          sock.on("data", (data) => {
            try {
              proto.parse(data, 0, data.length);
            } catch (ex) {
              this.emit("error", ex);
              try {
                if (isWritable$1(sock))
                  sock.end();
              } catch {
              }
            }
          });
          if (sock.stderr && typeof sock.stderr.resume === "function")
            sock.stderr.resume();
          sock.resume();
        }).catch((err) => {
          this.emit("error", err);
          try {
            if (isWritable$1(sock))
              sock.end();
          } catch {
          }
        });
      };
    })();
    let wasConnected = false;
    sock.on("connect", onConnect).on("timeout", () => {
      this.emit("timeout");
    }).on("error", (err) => {
      debug2 && debug2(`Socket error: ${err.message}`);
      clearTimeout(this._readyTimeout);
      err.level = "client-socket";
      this.emit("error", err);
    }).on("end", () => {
      debug2 && debug2("Socket ended");
      onDone();
      proto.cleanup();
      clearTimeout(this._readyTimeout);
      clearInterval(katimer);
      this.emit("end");
    }).on("close", () => {
      debug2 && debug2("Socket closed");
      onDone();
      proto.cleanup();
      clearTimeout(this._readyTimeout);
      clearInterval(katimer);
      this.emit("close");
      const callbacks_ = callbacks;
      callbacks = this._callbacks = [];
      const err = new Error("No response from server");
      for (let i = 0; i < callbacks_.length; ++i)
        callbacks_[i](err);
      this._chanMgr.cleanup(err);
    });
    let curAuth;
    let curPartial = null;
    let curAuthsLeft = null;
    const authsAllowed = ["none"];
    if (this.config.password !== void 0)
      authsAllowed.push("password");
    if (privateKey !== void 0)
      authsAllowed.push("publickey");
    if (this._agent !== void 0)
      authsAllowed.push("agent");
    if (this.config.tryKeyboard)
      authsAllowed.push("keyboard-interactive");
    if (privateKey !== void 0 && this.config.localHostname !== void 0 && this.config.localUsername !== void 0) {
      authsAllowed.push("hostbased");
    }
    if (Array.isArray(authHandler))
      authHandler = makeSimpleAuthHandler(authHandler);
    else if (typeof authHandler !== "function")
      authHandler = makeSimpleAuthHandler(authsAllowed);
    let hasSentAuth = false;
    const doNextAuth = (nextAuth) => {
      if (hasSentAuth)
        return;
      hasSentAuth = true;
      if (nextAuth === false) {
        const err = new Error("All configured authentication methods failed");
        err.level = "client-authentication";
        this.emit("error", err);
        this.end();
        return;
      }
      if (typeof nextAuth === "string") {
        const type2 = nextAuth;
        if (authsAllowed.indexOf(type2) === -1)
          return skipAuth(`Authentication method not allowed: ${type2}`);
        const username = this.config.username;
        switch (type2) {
          case "password":
            nextAuth = { type: type2, username, password: this.config.password };
            break;
          case "publickey":
            nextAuth = { type: type2, username, key: privateKey };
            break;
          case "hostbased":
            nextAuth = {
              type: type2,
              username,
              key: privateKey,
              localHostname: this.config.localHostname,
              localUsername: this.config.localUsername
            };
            break;
          case "agent":
            nextAuth = {
              type: type2,
              username,
              agentCtx: new AgentContext2(this._agent)
            };
            break;
          case "keyboard-interactive":
            nextAuth = {
              type: type2,
              username,
              prompt: (...args) => this.emit("keyboard-interactive", ...args)
            };
            break;
          case "none":
            nextAuth = { type: type2, username };
            break;
          default:
            return skipAuth(
              `Skipping unsupported authentication method: ${nextAuth}`
            );
        }
      } else if (typeof nextAuth !== "object" || nextAuth === null) {
        return skipAuth(
          `Skipping invalid authentication attempt: ${nextAuth}`
        );
      } else {
        const username = nextAuth.username;
        if (typeof username !== "string") {
          return skipAuth(
            `Skipping invalid authentication attempt: ${nextAuth}`
          );
        }
        const type2 = nextAuth.type;
        switch (type2) {
          case "password": {
            const { password } = nextAuth;
            if (typeof password !== "string" && !Buffer.isBuffer(password))
              return skipAuth("Skipping invalid password auth attempt");
            nextAuth = { type: type2, username, password };
            break;
          }
          case "publickey": {
            const key2 = parseKey$2(nextAuth.key, nextAuth.passphrase);
            if (key2 instanceof Error)
              return skipAuth("Skipping invalid key auth attempt");
            if (!key2.isPrivateKey())
              return skipAuth("Skipping non-private key");
            nextAuth = { type: type2, username, key: key2 };
            break;
          }
          case "hostbased": {
            const { localHostname, localUsername } = nextAuth;
            const key2 = parseKey$2(nextAuth.key, nextAuth.passphrase);
            if (key2 instanceof Error || typeof localHostname !== "string" || typeof localUsername !== "string") {
              return skipAuth("Skipping invalid hostbased auth attempt");
            }
            if (!key2.isPrivateKey())
              return skipAuth("Skipping non-private key");
            nextAuth = { type: type2, username, key: key2, localHostname, localUsername };
            break;
          }
          case "agent": {
            let agent2 = nextAuth.agent;
            if (typeof agent2 === "string" && agent2.length) {
              agent2 = createAgent$1(agent2);
            } else if (!isAgent(agent2)) {
              return skipAuth(
                `Skipping invalid agent: ${nextAuth.agent}`
              );
            }
            nextAuth = { type: type2, username, agentCtx: new AgentContext2(agent2) };
            break;
          }
          case "keyboard-interactive": {
            const { prompt } = nextAuth;
            if (typeof prompt !== "function") {
              return skipAuth(
                "Skipping invalid keyboard-interactive auth attempt"
              );
            }
            nextAuth = { type: type2, username, prompt };
            break;
          }
          case "none":
            nextAuth = { type: type2, username };
            break;
          default:
            return skipAuth(
              `Skipping unsupported authentication method: ${nextAuth}`
            );
        }
      }
      curAuth = nextAuth;
      try {
        const username = curAuth.username;
        switch (curAuth.type) {
          case "password":
            proto.authPassword(username, curAuth.password);
            break;
          case "publickey": {
            let keyAlgo;
            curAuth.keyAlgos = getKeyAlgos(this, curAuth.key, serverSigAlgs);
            if (curAuth.keyAlgos) {
              if (curAuth.keyAlgos.length) {
                keyAlgo = curAuth.keyAlgos[0][0];
              } else {
                return skipAuth(
                  "Skipping key authentication (no mutual hash algorithm)"
                );
              }
            }
            proto.authPK(username, curAuth.key, keyAlgo);
            break;
          }
          case "hostbased": {
            let keyAlgo;
            let hashAlgo;
            curAuth.keyAlgos = getKeyAlgos(this, curAuth.key, serverSigAlgs);
            if (curAuth.keyAlgos) {
              if (curAuth.keyAlgos.length) {
                [keyAlgo, hashAlgo] = curAuth.keyAlgos[0];
              } else {
                return skipAuth(
                  "Skipping hostbased authentication (no mutual hash algorithm)"
                );
              }
            }
            proto.authHostbased(
              username,
              curAuth.key,
              curAuth.localHostname,
              curAuth.localUsername,
              keyAlgo,
              (buf, cb) => {
                const signature = curAuth.key.sign(buf, hashAlgo);
                if (signature instanceof Error) {
                  signature.message = `Error while signing with key: ${signature.message}`;
                  signature.level = "client-authentication";
                  this.emit("error", signature);
                  return tryNextAuth();
                }
                cb(signature);
              }
            );
            break;
          }
          case "agent":
            curAuth.agentCtx.init((err) => {
              if (err) {
                err.level = "agent";
                this.emit("error", err);
                return tryNextAuth();
              }
              tryNextAgentKey();
            });
            break;
          case "keyboard-interactive":
            proto.authKeyboard(username);
            break;
          case "none":
            proto.authNone(username);
            break;
        }
      } finally {
        hasSentAuth = false;
      }
    };
    function skipAuth(msg) {
      debug2 && debug2(msg);
      process.nextTick(tryNextAuth);
    }
    function tryNextAuth() {
      hasSentAuth = false;
      const auth = authHandler(curAuthsLeft, curPartial, doNextAuth);
      if (hasSentAuth || auth === void 0)
        return;
      doNextAuth(auth);
    }
    const tryNextAgentKey = () => {
      if (curAuth.type === "agent") {
        const key2 = curAuth.agentCtx.nextKey();
        if (key2 === false) {
          debug2 && debug2("Agent: No more keys left to try");
          debug2 && debug2("Client: agent auth failed");
          tryNextAuth();
        } else {
          const pos = curAuth.agentCtx.pos();
          let keyAlgo;
          curAuth.keyAlgos = getKeyAlgos(this, key2, serverSigAlgs);
          if (curAuth.keyAlgos) {
            if (curAuth.keyAlgos.length) {
              keyAlgo = curAuth.keyAlgos[0][0];
            } else {
              debug2 && debug2(
                `Agent: Skipping key #${pos + 1} (no mutual hash algorithm)`
              );
              tryNextAgentKey();
              return;
            }
          }
          debug2 && debug2(`Agent: Trying key #${pos + 1}`);
          proto.authPK(curAuth.username, key2, keyAlgo);
        }
      }
    };
    const startTimeout = () => {
      if (this.config.readyTimeout > 0) {
        this._readyTimeout = setTimeout(() => {
          const err = new Error("Timed out while waiting for handshake");
          err.level = "client-timeout";
          this.emit("error", err);
          sock.destroy();
        }, this.config.readyTimeout);
      }
    };
    if (!cfg.sock) {
      let host = this.config.host;
      const forceIPv4 = this.config.forceIPv4;
      const forceIPv6 = this.config.forceIPv6;
      debug2 && debug2(`Client: Trying ${host} on port ${this.config.port} ...`);
      const doConnect = () => {
        startTimeout();
        sock.connect({
          host,
          port: this.config.port,
          localAddress: this.config.localAddress,
          localPort: this.config.localPort
        });
        sock.setMaxListeners(0);
        sock.setTimeout(typeof cfg.timeout === "number" ? cfg.timeout : 0);
      };
      if (!forceIPv4 && !forceIPv6 || forceIPv4 && forceIPv6) {
        doConnect();
      } else {
        dnsLookup(host, forceIPv4 ? 4 : 6, (err, address, family) => {
          if (err) {
            const type2 = forceIPv4 ? "IPv4" : "IPv6";
            const error2 = new Error(
              `Error while looking up ${type2} address for '${host}': ${err}`
            );
            clearTimeout(this._readyTimeout);
            error2.level = "client-dns";
            this.emit("error", error2);
            this.emit("close");
            return;
          }
          host = address;
          doConnect();
        });
      }
    } else {
      startTimeout();
      if (typeof sock.connecting === "boolean") {
        if (!sock.connecting) {
          onConnect();
        }
      } else {
        onConnect();
      }
    }
    return this;
  }
  end() {
    if (this._sock && isWritable$1(this._sock)) {
      this._protocol.disconnect(DISCONNECT_REASON$1.BY_APPLICATION);
      this._sock.end();
    }
    return this;
  }
  destroy() {
    this._sock && isWritable$1(this._sock) && this._sock.destroy();
    return this;
  }
  exec(cmd, opts, cb) {
    if (!this._sock || !isWritable$1(this._sock))
      throw new Error("Not connected");
    if (typeof opts === "function") {
      cb = opts;
      opts = {};
    }
    const extraOpts = { allowHalfOpen: opts.allowHalfOpen !== false };
    openChannel$1(this, "session", extraOpts, (err, chan) => {
      if (err) {
        cb(err);
        return;
      }
      const todo = [];
      function reqCb(err2) {
        if (err2) {
          chan.close();
          cb(err2);
          return;
        }
        if (todo.length)
          todo.shift()();
      }
      if (this.config.allowAgentFwd === true || opts && opts.agentForward === true && this._agent !== void 0) {
        todo.push(() => reqAgentFwd(chan, reqCb));
      }
      if (typeof opts === "object" && opts !== null) {
        if (typeof opts.env === "object" && opts.env !== null)
          reqEnv(chan, opts.env);
        if (typeof opts.pty === "object" && opts.pty !== null || opts.pty === true) {
          todo.push(() => reqPty(chan, opts.pty, reqCb));
        }
        if (typeof opts.x11 === "object" && opts.x11 !== null || opts.x11 === "number" || opts.x11 === true) {
          todo.push(() => reqX11(chan, opts.x11, reqCb));
        }
      }
      todo.push(() => reqExec(chan, cmd, opts, cb));
      todo.shift()();
    });
    return this;
  }
  shell(wndopts, opts, cb) {
    if (!this._sock || !isWritable$1(this._sock))
      throw new Error("Not connected");
    if (typeof wndopts === "function") {
      cb = wndopts;
      wndopts = opts = void 0;
    } else if (typeof opts === "function") {
      cb = opts;
      opts = void 0;
    }
    if (wndopts && (wndopts.x11 !== void 0 || wndopts.env !== void 0)) {
      opts = wndopts;
      wndopts = void 0;
    }
    openChannel$1(this, "session", (err, chan) => {
      if (err) {
        cb(err);
        return;
      }
      const todo = [];
      function reqCb(err2) {
        if (err2) {
          chan.close();
          cb(err2);
          return;
        }
        if (todo.length)
          todo.shift()();
      }
      if (this.config.allowAgentFwd === true || opts && opts.agentForward === true && this._agent !== void 0) {
        todo.push(() => reqAgentFwd(chan, reqCb));
      }
      if (wndopts !== false)
        todo.push(() => reqPty(chan, wndopts, reqCb));
      if (typeof opts === "object" && opts !== null) {
        if (typeof opts.env === "object" && opts.env !== null)
          reqEnv(chan, opts.env);
        if (typeof opts.x11 === "object" && opts.x11 !== null || opts.x11 === "number" || opts.x11 === true) {
          todo.push(() => reqX11(chan, opts.x11, reqCb));
        }
      }
      todo.push(() => reqShell(chan, cb));
      todo.shift()();
    });
    return this;
  }
  subsys(name, cb) {
    if (!this._sock || !isWritable$1(this._sock))
      throw new Error("Not connected");
    openChannel$1(this, "session", (err, chan) => {
      if (err) {
        cb(err);
        return;
      }
      reqSubsystem(chan, name, (err2, stream) => {
        if (err2) {
          cb(err2);
          return;
        }
        cb(void 0, stream);
      });
    });
    return this;
  }
  forwardIn(bindAddr, bindPort, cb) {
    if (!this._sock || !isWritable$1(this._sock))
      throw new Error("Not connected");
    const wantReply = typeof cb === "function";
    if (wantReply) {
      this._callbacks.push((had_err, data) => {
        if (had_err) {
          cb(had_err !== true ? had_err : new Error(`Unable to bind to ${bindAddr}:${bindPort}`));
          return;
        }
        let realPort = bindPort;
        if (bindPort === 0 && data && data.length >= 4) {
          realPort = readUInt32BE(data, 0);
          if (!(this._protocol._compatFlags & COMPAT.DYN_RPORT_BUG))
            bindPort = realPort;
        }
        this._forwarding[`${bindAddr}:${bindPort}`] = realPort;
        cb(void 0, realPort);
      });
    }
    this._protocol.tcpipForward(bindAddr, bindPort, wantReply);
    return this;
  }
  unforwardIn(bindAddr, bindPort, cb) {
    if (!this._sock || !isWritable$1(this._sock))
      throw new Error("Not connected");
    const wantReply = typeof cb === "function";
    if (wantReply) {
      this._callbacks.push((had_err) => {
        if (had_err) {
          cb(had_err !== true ? had_err : new Error(`Unable to unbind from ${bindAddr}:${bindPort}`));
          return;
        }
        delete this._forwarding[`${bindAddr}:${bindPort}`];
        cb();
      });
    }
    this._protocol.cancelTcpipForward(bindAddr, bindPort, wantReply);
    return this;
  }
  forwardOut(srcIP, srcPort, dstIP, dstPort, cb) {
    if (!this._sock || !isWritable$1(this._sock))
      throw new Error("Not connected");
    const cfg = {
      srcIP,
      srcPort,
      dstIP,
      dstPort
    };
    if (typeof cb !== "function")
      cb = noop$1;
    openChannel$1(this, "direct-tcpip", cfg, cb);
    return this;
  }
  openssh_noMoreSessions(cb) {
    if (!this._sock || !isWritable$1(this._sock))
      throw new Error("Not connected");
    const wantReply = typeof cb === "function";
    if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {
      if (wantReply) {
        this._callbacks.push((had_err) => {
          if (had_err) {
            cb(had_err !== true ? had_err : new Error("Unable to disable future sessions"));
            return;
          }
          cb();
        });
      }
      this._protocol.openssh_noMoreSessions(wantReply);
      return this;
    }
    if (!wantReply)
      return this;
    process.nextTick(
      cb,
      new Error(
        "strictVendor enabled and server is not OpenSSH or compatible version"
      )
    );
    return this;
  }
  openssh_forwardInStreamLocal(socketPath, cb) {
    if (!this._sock || !isWritable$1(this._sock))
      throw new Error("Not connected");
    const wantReply = typeof cb === "function";
    if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {
      if (wantReply) {
        this._callbacks.push((had_err) => {
          if (had_err) {
            cb(had_err !== true ? had_err : new Error(`Unable to bind to ${socketPath}`));
            return;
          }
          this._forwardingUnix[socketPath] = true;
          cb();
        });
      }
      this._protocol.openssh_streamLocalForward(socketPath, wantReply);
      return this;
    }
    if (!wantReply)
      return this;
    process.nextTick(
      cb,
      new Error(
        "strictVendor enabled and server is not OpenSSH or compatible version"
      )
    );
    return this;
  }
  openssh_unforwardInStreamLocal(socketPath, cb) {
    if (!this._sock || !isWritable$1(this._sock))
      throw new Error("Not connected");
    const wantReply = typeof cb === "function";
    if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {
      if (wantReply) {
        this._callbacks.push((had_err) => {
          if (had_err) {
            cb(had_err !== true ? had_err : new Error(`Unable to unbind from ${socketPath}`));
            return;
          }
          delete this._forwardingUnix[socketPath];
          cb();
        });
      }
      this._protocol.openssh_cancelStreamLocalForward(socketPath, wantReply);
      return this;
    }
    if (!wantReply)
      return this;
    process.nextTick(
      cb,
      new Error(
        "strictVendor enabled and server is not OpenSSH or compatible version"
      )
    );
    return this;
  }
  openssh_forwardOutStreamLocal(socketPath, cb) {
    if (!this._sock || !isWritable$1(this._sock))
      throw new Error("Not connected");
    if (typeof cb !== "function")
      cb = noop$1;
    if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {
      openChannel$1(this, "direct-streamlocal@openssh.com", { socketPath }, cb);
      return this;
    }
    process.nextTick(
      cb,
      new Error(
        "strictVendor enabled and server is not OpenSSH or compatible version"
      )
    );
    return this;
  }
  sftp(env2, cb) {
    if (!this._sock || !isWritable$1(this._sock))
      throw new Error("Not connected");
    if (typeof env2 === "function") {
      cb = env2;
      env2 = void 0;
    }
    openChannel$1(this, "sftp", (err, sftp) => {
      if (err) {
        cb(err);
        return;
      }
      const reqSubsystemCb = (err2, sftp_) => {
        if (err2) {
          cb(err2);
          return;
        }
        function removeListeners() {
          sftp.removeListener("ready", onReady);
          sftp.removeListener("error", onError);
          sftp.removeListener("exit", onExit);
          sftp.removeListener("close", onExit);
        }
        function onReady() {
          removeListeners();
          cb(void 0, sftp);
        }
        function onError(err3) {
          removeListeners();
          cb(err3);
        }
        function onExit(code2, signal) {
          removeListeners();
          let msg;
          if (typeof code2 === "number")
            msg = `Received exit code ${code2} while establishing SFTP session`;
          else if (signal !== void 0)
            msg = `Received signal ${signal} while establishing SFTP session`;
          else
            msg = "Received unexpected SFTP session termination";
          const err3 = new Error(msg);
          err3.code = code2;
          err3.signal = signal;
          cb(err3);
        }
        sftp.on("ready", onReady).on("error", onError).on("exit", onExit).on("close", onExit);
        sftp._init();
      };
      if (typeof env2 === "object" && env2 !== null) {
        reqEnv(sftp, env2, (err2) => {
          if (err2) {
            cb(err2);
            return;
          }
          reqSubsystem(sftp, "sftp", reqSubsystemCb);
        });
      } else {
        reqSubsystem(sftp, "sftp", reqSubsystemCb);
      }
    });
    return this;
  }
  setNoDelay(noDelay) {
    if (this._sock && typeof this._sock.setNoDelay === "function")
      this._sock.setNoDelay(noDelay);
    return this;
  }
};
function openChannel$1(self2, type2, opts, cb) {
  const initWindow = MAX_WINDOW$1;
  const maxPacket = PACKET_SIZE$1;
  if (typeof opts === "function") {
    cb = opts;
    opts = {};
  }
  const wrapper = (err, stream) => {
    cb(err, stream);
  };
  wrapper.type = type2;
  const localChan = self2._chanMgr.add(wrapper);
  if (localChan === -1) {
    cb(new Error("No free channels available"));
    return;
  }
  switch (type2) {
    case "session":
    case "sftp":
      self2._protocol.session(localChan, initWindow, maxPacket);
      break;
    case "direct-tcpip":
      self2._protocol.directTcpip(localChan, initWindow, maxPacket, opts);
      break;
    case "direct-streamlocal@openssh.com":
      self2._protocol.openssh_directStreamLocal(
        localChan,
        initWindow,
        maxPacket,
        opts
      );
      break;
    default:
      throw new Error(`Unsupported channel type: ${type2}`);
  }
}
function reqX11(chan, screen, cb) {
  const cfg = {
    single: false,
    protocol: "MIT-MAGIC-COOKIE-1",
    cookie: void 0,
    screen: 0
  };
  if (typeof screen === "function") {
    cb = screen;
  } else if (typeof screen === "object" && screen !== null) {
    if (typeof screen.single === "boolean")
      cfg.single = screen.single;
    if (typeof screen.screen === "number")
      cfg.screen = screen.screen;
    if (typeof screen.protocol === "string")
      cfg.protocol = screen.protocol;
    if (typeof screen.cookie === "string")
      cfg.cookie = screen.cookie;
    else if (Buffer.isBuffer(screen.cookie))
      cfg.cookie = screen.cookie.hexSlice(0, screen.cookie.length);
  }
  if (cfg.cookie === void 0)
    cfg.cookie = randomCookie();
  const wantReply = typeof cb === "function";
  if (chan.outgoing.state !== "open") {
    if (wantReply)
      cb(new Error("Channel is not open"));
    return;
  }
  if (wantReply) {
    chan._callbacks.push((had_err) => {
      if (had_err) {
        cb(had_err !== true ? had_err : new Error("Unable to request X11"));
        return;
      }
      chan._hasX11 = true;
      ++chan._client._acceptX11;
      chan.once("close", () => {
        if (chan._client._acceptX11)
          --chan._client._acceptX11;
      });
      cb();
    });
  }
  chan._client._protocol.x11Forward(chan.outgoing.id, cfg, wantReply);
}
function reqPty(chan, opts, cb) {
  let rows = 24;
  let cols = 80;
  let width = 640;
  let height = 480;
  let term = "vt100";
  let modes = null;
  if (typeof opts === "function") {
    cb = opts;
  } else if (typeof opts === "object" && opts !== null) {
    if (typeof opts.rows === "number")
      rows = opts.rows;
    if (typeof opts.cols === "number")
      cols = opts.cols;
    if (typeof opts.width === "number")
      width = opts.width;
    if (typeof opts.height === "number")
      height = opts.height;
    if (typeof opts.term === "string")
      term = opts.term;
    if (typeof opts.modes === "object")
      modes = opts.modes;
  }
  const wantReply = typeof cb === "function";
  if (chan.outgoing.state !== "open") {
    if (wantReply)
      cb(new Error("Channel is not open"));
    return;
  }
  if (wantReply) {
    chan._callbacks.push((had_err) => {
      if (had_err) {
        cb(had_err !== true ? had_err : new Error("Unable to request a pseudo-terminal"));
        return;
      }
      cb();
    });
  }
  chan._client._protocol.pty(
    chan.outgoing.id,
    rows,
    cols,
    height,
    width,
    term,
    modes,
    wantReply
  );
}
function reqAgentFwd(chan, cb) {
  const wantReply = typeof cb === "function";
  if (chan.outgoing.state !== "open") {
    wantReply && cb(new Error("Channel is not open"));
    return;
  }
  if (chan._client._agentFwdEnabled) {
    wantReply && cb(false);
    return;
  }
  chan._client._agentFwdEnabled = true;
  chan._callbacks.push((had_err) => {
    if (had_err) {
      chan._client._agentFwdEnabled = false;
      if (wantReply) {
        cb(had_err !== true ? had_err : new Error("Unable to request agent forwarding"));
      }
      return;
    }
    if (wantReply)
      cb();
  });
  chan._client._protocol.openssh_agentForward(chan.outgoing.id, true);
}
function reqShell(chan, cb) {
  if (chan.outgoing.state !== "open") {
    cb(new Error("Channel is not open"));
    return;
  }
  chan._callbacks.push((had_err) => {
    if (had_err) {
      cb(had_err !== true ? had_err : new Error("Unable to open shell"));
      return;
    }
    chan.subtype = "shell";
    cb(void 0, chan);
  });
  chan._client._protocol.shell(chan.outgoing.id, true);
}
function reqExec(chan, cmd, opts, cb) {
  if (chan.outgoing.state !== "open") {
    cb(new Error("Channel is not open"));
    return;
  }
  chan._callbacks.push((had_err) => {
    if (had_err) {
      cb(had_err !== true ? had_err : new Error("Unable to exec"));
      return;
    }
    chan.subtype = "exec";
    chan.allowHalfOpen = opts.allowHalfOpen !== false;
    cb(void 0, chan);
  });
  chan._client._protocol.exec(chan.outgoing.id, cmd, true);
}
function reqEnv(chan, env2, cb) {
  const wantReply = typeof cb === "function";
  if (chan.outgoing.state !== "open") {
    if (wantReply)
      cb(new Error("Channel is not open"));
    return;
  }
  if (wantReply) {
    chan._callbacks.push((had_err) => {
      if (had_err) {
        cb(had_err !== true ? had_err : new Error("Unable to set environment"));
        return;
      }
      cb();
    });
  }
  const keys = Object.keys(env2 || {});
  for (let i = 0; i < keys.length; ++i) {
    const key2 = keys[i];
    const val = env2[key2];
    chan._client._protocol.env(chan.outgoing.id, key2, val, wantReply);
  }
}
function reqSubsystem(chan, name, cb) {
  if (chan.outgoing.state !== "open") {
    cb(new Error("Channel is not open"));
    return;
  }
  chan._callbacks.push((had_err) => {
    if (had_err) {
      cb(had_err !== true ? had_err : new Error(`Unable to start subsystem: ${name}`));
      return;
    }
    chan.subtype = "subsystem";
    cb(void 0, chan);
  });
  chan._client._protocol.subsystem(chan.outgoing.id, name, true);
}
function onCHANNEL_OPEN(self2, info) {
  let localChan = -1;
  let reason;
  const accept = () => {
    const chanInfo = {
      type: info.type,
      incoming: {
        id: localChan,
        window: MAX_WINDOW$1,
        packetSize: PACKET_SIZE$1,
        state: "open"
      },
      outgoing: {
        id: info.sender,
        window: info.window,
        packetSize: info.packetSize,
        state: "open"
      }
    };
    const stream = new Channel$1(self2, chanInfo);
    self2._chanMgr.update(localChan, stream);
    self2._protocol.channelOpenConfirm(
      info.sender,
      localChan,
      MAX_WINDOW$1,
      PACKET_SIZE$1
    );
    return stream;
  };
  const reject = () => {
    if (reason === void 0) {
      if (localChan === -1)
        reason = CHANNEL_OPEN_FAILURE$1.RESOURCE_SHORTAGE;
      else
        reason = CHANNEL_OPEN_FAILURE$1.CONNECT_FAILED;
    }
    if (localChan !== -1)
      self2._chanMgr.remove(localChan);
    self2._protocol.channelOpenFail(info.sender, reason, "");
  };
  const reserveChannel = () => {
    localChan = self2._chanMgr.add();
    if (localChan === -1) {
      reason = CHANNEL_OPEN_FAILURE$1.RESOURCE_SHORTAGE;
      if (self2.config.debug) {
        self2.config.debug(
          "Client: Automatic rejection of incoming channel open: no channels available"
        );
      }
    }
    return localChan !== -1;
  };
  const data = info.data;
  switch (info.type) {
    case "forwarded-tcpip": {
      const val = self2._forwarding[`${data.destIP}:${data.destPort}`];
      if (val !== void 0 && reserveChannel()) {
        if (data.destPort === 0)
          data.destPort = val;
        self2.emit("tcp connection", data, accept, reject);
        return;
      }
      break;
    }
    case "forwarded-streamlocal@openssh.com":
      if (self2._forwardingUnix[data.socketPath] !== void 0 && reserveChannel()) {
        self2.emit("unix connection", data, accept, reject);
        return;
      }
      break;
    case "auth-agent@openssh.com":
      if (self2._agentFwdEnabled && typeof self2._agent.getStream === "function" && reserveChannel()) {
        self2._agent.getStream((err, stream) => {
          if (err)
            return reject();
          const upstream = accept();
          upstream.pipe(stream).pipe(upstream);
        });
        return;
      }
      break;
    case "x11":
      if (self2._acceptX11 !== 0 && reserveChannel()) {
        self2.emit("x11", data, accept, reject);
        return;
      }
      break;
    default:
      reason = CHANNEL_OPEN_FAILURE$1.UNKNOWN_CHANNEL_TYPE;
      if (self2.config.debug) {
        self2.config.debug(
          `Client: Automatic rejection of unsupported incoming channel open type: ${info.type}`
        );
      }
  }
  if (reason === void 0) {
    reason = CHANNEL_OPEN_FAILURE$1.ADMINISTRATIVELY_PROHIBITED;
    if (self2.config.debug) {
      self2.config.debug(
        "Client: Automatic rejection of unexpected incoming channel open for: " + info.type
      );
    }
  }
  reject();
}
const randomCookie = (() => {
  const buffer2 = Buffer.allocUnsafe(16);
  return () => {
    randomFillSync(buffer2, 0, 16);
    return buffer2.hexSlice(0, 16);
  };
})();
function makeSimpleAuthHandler(authList) {
  if (!Array.isArray(authList))
    throw new Error("authList must be an array");
  let a = 0;
  return (authsLeft, partialSuccess, cb) => {
    if (a === authList.length)
      return false;
    return authList[a++];
  };
}
function hostKeysProve(client2, keys_, cb) {
  if (!client2._sock || !isWritable$1(client2._sock))
    return;
  if (typeof cb !== "function")
    cb = noop$1;
  if (!Array.isArray(keys_))
    throw new TypeError("Invalid keys argument type");
  const keys = [];
  for (const key2 of keys_) {
    const parsed = parseKey$2(key2);
    if (parsed instanceof Error)
      throw parsed;
    keys.push(parsed);
  }
  if (!client2.config.strictVendor || client2.config.strictVendor && RE_OPENSSH.test(client2._remoteVer)) {
    client2._callbacks.push((had_err, data) => {
      if (had_err) {
        cb(had_err !== true ? had_err : new Error("Server failed to prove supplied keys"));
        return;
      }
      const ret = [];
      let keyIdx = 0;
      bufferParser.init(data, 0);
      while (bufferParser.avail()) {
        if (keyIdx === keys.length)
          break;
        const key2 = keys[keyIdx++];
        const keyPublic = key2.getPublicSSH();
        const sigEntry = bufferParser.readString();
        sigParser.init(sigEntry, 0);
        const type2 = sigParser.readString(true);
        let value = sigParser.readString();
        let algo;
        if (type2 !== key2.type) {
          if (key2.type === "ssh-rsa") {
            switch (type2) {
              case "rsa-sha2-256":
                algo = "sha256";
                break;
              case "rsa-sha2-512":
                algo = "sha512";
                break;
              default:
                continue;
            }
          } else {
            continue;
          }
        }
        const sessionID = client2._protocol._kex.sessionID;
        const verifyData = Buffer.allocUnsafe(
          4 + 29 + 4 + sessionID.length + 4 + keyPublic.length
        );
        let p = 0;
        writeUInt32BE$1(verifyData, 29, p);
        verifyData.utf8Write("hostkeys-prove-00@openssh.com", p += 4, 29);
        writeUInt32BE$1(verifyData, sessionID.length, p += 29);
        bufferCopy(sessionID, verifyData, 0, sessionID.length, p += 4);
        writeUInt32BE$1(verifyData, keyPublic.length, p += sessionID.length);
        bufferCopy(keyPublic, verifyData, 0, keyPublic.length, p += 4);
        if (!(value = sigSSHToASN1(value, type2)))
          continue;
        if (key2.verify(verifyData, value, algo) === true)
          ret.push(key2);
      }
      sigParser.clear();
      bufferParser.clear();
      cb(null, ret);
    });
    client2._protocol.openssh_hostKeysProve(keys);
    return;
  }
  process.nextTick(
    cb,
    new Error(
      "strictVendor enabled and server is not OpenSSH or compatible version"
    )
  );
}
function getKeyAlgos(client2, key2, serverSigAlgs) {
  switch (key2.type) {
    case "ssh-rsa":
      if (client2._protocol._compatFlags & COMPAT.IMPLY_RSA_SHA2_SIGALGS) {
        if (!Array.isArray(serverSigAlgs))
          serverSigAlgs = ["rsa-sha2-256", "rsa-sha2-512"];
        else
          serverSigAlgs = ["rsa-sha2-256", "rsa-sha2-512", ...serverSigAlgs];
      }
      if (Array.isArray(serverSigAlgs)) {
        if (serverSigAlgs.indexOf("rsa-sha2-256") !== -1)
          return [["rsa-sha2-256", "sha256"]];
        if (serverSigAlgs.indexOf("rsa-sha2-512") !== -1)
          return [["rsa-sha2-512", "sha512"]];
        if (serverSigAlgs.indexOf("ssh-rsa") === -1)
          return [];
      }
      return [["ssh-rsa", "sha1"]];
  }
}
var client = Client$1;
(function(exports$1) {
  const { Agent: HttpAgent } = require$$0$6;
  const { Agent: HttpsAgent } = require$$1$5;
  const { connect: tlsConnect } = require$$2$1;
  let Client3;
  for (const ctor of [HttpAgent, HttpsAgent]) {
    class SSHAgent extends ctor {
      constructor(connectCfg, agentOptions) {
        super(agentOptions);
        this._connectCfg = connectCfg;
        this._defaultSrcIP = agentOptions && agentOptions.srcIP || "localhost";
      }
      createConnection(options, cb) {
        const srcIP = options && options.localAddress || this._defaultSrcIP;
        const srcPort = options && options.localPort || 0;
        const dstIP = options.host;
        const dstPort = options.port;
        if (Client3 === void 0)
          Client3 = client;
        const client$1 = new Client3();
        let triedForward = false;
        client$1.on("ready", () => {
          client$1.forwardOut(srcIP, srcPort, dstIP, dstPort, (err, stream) => {
            triedForward = true;
            if (err) {
              client$1.end();
              return cb(err);
            }
            stream.once("close", () => client$1.end());
            cb(null, decorateStream(stream, ctor, options));
          });
        }).on("error", cb).on("close", () => {
          if (!triedForward)
            cb(new Error("Unexpected connection close"));
        }).connect(this._connectCfg);
      }
    }
    exports$1[ctor === HttpAgent ? "SSHTTPAgent" : "SSHTTPSAgent"] = SSHAgent;
  }
  function noop2() {
  }
  function decorateStream(stream, ctor, options) {
    if (ctor === HttpAgent) {
      stream.setKeepAlive = noop2;
      stream.setNoDelay = noop2;
      stream.setTimeout = noop2;
      stream.ref = noop2;
      stream.unref = noop2;
      stream.destroySoon = stream.destroy;
      return stream;
    }
    options.socket = stream;
    const wrapped = tlsConnect(options);
    const onClose = /* @__PURE__ */ (() => {
      let called = false;
      return () => {
        if (called)
          return;
        called = true;
        if (stream.isPaused())
          stream.resume();
      };
    })();
    wrapped.on("end", onClose).on("close", onClose);
    return wrapped;
  }
})(httpAgents);
var server = { exports: {} };
const { Server: netServer } = require$$0$5;
const EventEmitter = require$$5;
const { listenerCount } = EventEmitter;
const {
  CHANNEL_OPEN_FAILURE,
  DEFAULT_CIPHER,
  DEFAULT_COMPRESSION,
  DEFAULT_KEX,
  DEFAULT_MAC,
  DEFAULT_SERVER_HOST_KEY,
  DISCONNECT_REASON,
  DISCONNECT_REASON_BY_VALUE,
  SUPPORTED_CIPHER,
  SUPPORTED_COMPRESSION,
  SUPPORTED_KEX,
  SUPPORTED_MAC,
  SUPPORTED_SERVER_HOST_KEY
} = requireConstants();
const { init: cryptoInit } = requireCrypto();
const { KexInit } = requireKex();
const { parseKey: parseKey$1 } = keyParser;
const Protocol2 = Protocol_1;
const { SFTP: SFTP2 } = SFTP_1;
const { writeUInt32BE } = requireUtils();
const {
  Channel: Channel2,
  MAX_WINDOW,
  PACKET_SIZE,
  windowAdjust,
  WINDOW_THRESHOLD
} = Channel_1;
const {
  ChannelManager: ChannelManager2,
  generateAlgorithmList,
  isWritable,
  onChannelOpenFailure,
  onCHANNEL_CLOSE
} = utils;
const MAX_PENDING_AUTHS = 10;
class AuthContext extends EventEmitter {
  constructor(protocol, username, service, method, cb) {
    super();
    this.username = this.user = username;
    this.service = service;
    this.method = method;
    this._initialResponse = false;
    this._finalResponse = false;
    this._multistep = false;
    this._cbfinal = (allowed, methodsLeft, isPartial) => {
      if (!this._finalResponse) {
        this._finalResponse = true;
        cb(this, allowed, methodsLeft, isPartial);
      }
    };
    this._protocol = protocol;
  }
  accept() {
    this._cleanup && this._cleanup();
    this._initialResponse = true;
    this._cbfinal(true);
  }
  reject(methodsLeft, isPartial) {
    this._cleanup && this._cleanup();
    this._initialResponse = true;
    this._cbfinal(false, methodsLeft, isPartial);
  }
}
class KeyboardAuthContext extends AuthContext {
  constructor(protocol, username, service, method, submethods, cb) {
    super(protocol, username, service, method, cb);
    this._multistep = true;
    this._cb = void 0;
    this._onInfoResponse = (responses) => {
      const callback = this._cb;
      if (callback) {
        this._cb = void 0;
        callback(responses);
      }
    };
    this.submethods = submethods;
    this.on("abort", () => {
      this._cb && this._cb(new Error("Authentication request aborted"));
    });
  }
  prompt(prompts, title2, instructions, cb) {
    if (!Array.isArray(prompts))
      prompts = [prompts];
    if (typeof title2 === "function") {
      cb = title2;
      title2 = instructions = void 0;
    } else if (typeof instructions === "function") {
      cb = instructions;
      instructions = void 0;
    } else if (typeof cb !== "function") {
      cb = void 0;
    }
    for (let i = 0; i < prompts.length; ++i) {
      if (typeof prompts[i] === "string") {
        prompts[i] = {
          prompt: prompts[i],
          echo: true
        };
      }
    }
    this._cb = cb;
    this._initialResponse = true;
    this._protocol.authInfoReq(title2, instructions, prompts);
  }
}
class PKAuthContext extends AuthContext {
  constructor(protocol, username, service, method, pkInfo, cb) {
    super(protocol, username, service, method, cb);
    this.key = { algo: pkInfo.keyAlgo, data: pkInfo.key };
    this.hashAlgo = pkInfo.hashAlgo;
    this.signature = pkInfo.signature;
    this.blob = pkInfo.blob;
  }
  accept() {
    if (!this.signature) {
      this._initialResponse = true;
      this._protocol.authPKOK(this.key.algo, this.key.data);
    } else {
      AuthContext.prototype.accept.call(this);
    }
  }
}
class HostbasedAuthContext extends AuthContext {
  constructor(protocol, username, service, method, pkInfo, cb) {
    super(protocol, username, service, method, cb);
    this.key = { algo: pkInfo.keyAlgo, data: pkInfo.key };
    this.hashAlgo = pkInfo.hashAlgo;
    this.signature = pkInfo.signature;
    this.blob = pkInfo.blob;
    this.localHostname = pkInfo.localHostname;
    this.localUsername = pkInfo.localUsername;
  }
}
class PwdAuthContext extends AuthContext {
  constructor(protocol, username, service, method, password, cb) {
    super(protocol, username, service, method, cb);
    this.password = password;
    this._changeCb = void 0;
  }
  requestChange(prompt, cb) {
    if (this._changeCb)
      throw new Error("Change request already in progress");
    if (typeof prompt !== "string")
      throw new Error("prompt argument must be a string");
    if (typeof cb !== "function")
      throw new Error("Callback argument must be a function");
    this._changeCb = cb;
    this._protocol.authPasswdChg(prompt);
  }
}
class Session extends EventEmitter {
  constructor(client2, info, localChan) {
    super();
    this.type = "session";
    this.subtype = void 0;
    this.server = true;
    this._ending = false;
    this._channel = void 0;
    this._chanInfo = {
      type: "session",
      incoming: {
        id: localChan,
        window: MAX_WINDOW,
        packetSize: PACKET_SIZE,
        state: "open"
      },
      outgoing: {
        id: info.sender,
        window: info.window,
        packetSize: info.packetSize,
        state: "open"
      }
    };
  }
}
class Server extends EventEmitter {
  constructor(cfg, listener) {
    super();
    if (typeof cfg !== "object" || cfg === null)
      throw new Error("Missing configuration object");
    const hostKeys = /* @__PURE__ */ Object.create(null);
    const hostKeyAlgoOrder = [];
    const hostKeys_ = cfg.hostKeys;
    if (!Array.isArray(hostKeys_))
      throw new Error("hostKeys must be an array");
    const cfgAlgos = typeof cfg.algorithms === "object" && cfg.algorithms !== null ? cfg.algorithms : {};
    const hostKeyAlgos = generateAlgorithmList(
      cfgAlgos.serverHostKey,
      DEFAULT_SERVER_HOST_KEY,
      SUPPORTED_SERVER_HOST_KEY
    );
    for (let i = 0; i < hostKeys_.length; ++i) {
      let privateKey;
      if (Buffer.isBuffer(hostKeys_[i]) || typeof hostKeys_[i] === "string")
        privateKey = parseKey$1(hostKeys_[i]);
      else
        privateKey = parseKey$1(hostKeys_[i].key, hostKeys_[i].passphrase);
      if (privateKey instanceof Error)
        throw new Error(`Cannot parse privateKey: ${privateKey.message}`);
      if (Array.isArray(privateKey)) {
        privateKey = privateKey[0];
      }
      if (privateKey.getPrivatePEM() === null)
        throw new Error("privateKey value contains an invalid private key");
      if (hostKeyAlgoOrder.includes(privateKey.type))
        continue;
      if (privateKey.type === "ssh-rsa") {
        let sha1Pos = hostKeyAlgos.indexOf("ssh-rsa");
        const sha256Pos = hostKeyAlgos.indexOf("rsa-sha2-256");
        const sha512Pos = hostKeyAlgos.indexOf("rsa-sha2-512");
        if (sha1Pos === -1) {
          sha1Pos = Infinity;
        }
        [sha1Pos, sha256Pos, sha512Pos].sort(compareNumbers).forEach((pos) => {
          if (pos === -1)
            return;
          let type2;
          switch (pos) {
            case sha1Pos:
              type2 = "ssh-rsa";
              break;
            case sha256Pos:
              type2 = "rsa-sha2-256";
              break;
            case sha512Pos:
              type2 = "rsa-sha2-512";
              break;
            default:
              return;
          }
          hostKeys[type2] = privateKey;
          hostKeyAlgoOrder.push(type2);
        });
      } else {
        hostKeys[privateKey.type] = privateKey;
        hostKeyAlgoOrder.push(privateKey.type);
      }
    }
    const algorithms = {
      kex: generateAlgorithmList(
        cfgAlgos.kex,
        DEFAULT_KEX,
        SUPPORTED_KEX
      ).concat(["kex-strict-s-v00@openssh.com"]),
      serverHostKey: hostKeyAlgoOrder,
      cs: {
        cipher: generateAlgorithmList(
          cfgAlgos.cipher,
          DEFAULT_CIPHER,
          SUPPORTED_CIPHER
        ),
        mac: generateAlgorithmList(cfgAlgos.hmac, DEFAULT_MAC, SUPPORTED_MAC),
        compress: generateAlgorithmList(
          cfgAlgos.compress,
          DEFAULT_COMPRESSION,
          SUPPORTED_COMPRESSION
        ),
        lang: []
      },
      sc: void 0
    };
    algorithms.sc = algorithms.cs;
    if (typeof listener === "function")
      this.on("connection", listener);
    const origDebug = typeof cfg.debug === "function" ? cfg.debug : void 0;
    const ident = cfg.ident ? Buffer.from(cfg.ident) : void 0;
    const offer = new KexInit(algorithms);
    this._srv = new netServer((socket) => {
      if (this._connections >= this.maxConnections) {
        socket.destroy();
        return;
      }
      ++this._connections;
      socket.once("close", () => {
        --this._connections;
      });
      let debug2;
      if (origDebug) {
        const debugPrefix = `[${process.hrtime().join(".")}] `;
        debug2 = (msg) => {
          origDebug(`${debugPrefix}${msg}`);
        };
      }
      new Client2(socket, hostKeys, ident, offer, debug2, this, cfg);
    }).on("error", (err) => {
      this.emit("error", err);
    }).on("listening", () => {
      this.emit("listening");
    }).on("close", () => {
      this.emit("close");
    });
    this._connections = 0;
    this.maxConnections = Infinity;
  }
  injectSocket(socket) {
    this._srv.emit("connection", socket);
  }
  listen(...args) {
    this._srv.listen(...args);
    return this;
  }
  address() {
    return this._srv.address();
  }
  getConnections(cb) {
    this._srv.getConnections(cb);
    return this;
  }
  close(cb) {
    this._srv.close(cb);
    return this;
  }
  ref() {
    this._srv.ref();
    return this;
  }
  unref() {
    this._srv.unref();
    return this;
  }
}
Server.KEEPALIVE_CLIENT_INTERVAL = 15e3;
Server.KEEPALIVE_CLIENT_COUNT_MAX = 3;
class Client2 extends EventEmitter {
  constructor(socket, hostKeys, ident, offer, debug2, server2, srvCfg) {
    super();
    let exchanges = 0;
    let acceptedAuthSvc = false;
    let pendingAuths = [];
    let authCtx;
    let kaTimer;
    let onPacket;
    const unsentGlobalRequestsReplies = [];
    this._sock = socket;
    this._chanMgr = new ChannelManager2(this);
    this._debug = debug2;
    this.noMoreSessions = false;
    this.authenticated = false;
    function onClientPreHeaderError(err) {
    }
    this.on("error", onClientPreHeaderError);
    const DEBUG_HANDLER = !debug2 ? void 0 : (p, display, msg) => {
      debug2(`Debug output from client: ${JSON.stringify(msg)}`);
    };
    const kaIntvl = typeof srvCfg.keepaliveInterval === "number" && isFinite(srvCfg.keepaliveInterval) && srvCfg.keepaliveInterval > 0 ? srvCfg.keepaliveInterval : typeof Server.KEEPALIVE_CLIENT_INTERVAL === "number" && isFinite(Server.KEEPALIVE_CLIENT_INTERVAL) && Server.KEEPALIVE_CLIENT_INTERVAL > 0 ? Server.KEEPALIVE_CLIENT_INTERVAL : -1;
    const kaCountMax = typeof srvCfg.keepaliveCountMax === "number" && isFinite(srvCfg.keepaliveCountMax) && srvCfg.keepaliveCountMax >= 0 ? srvCfg.keepaliveCountMax : typeof Server.KEEPALIVE_CLIENT_COUNT_MAX === "number" && isFinite(Server.KEEPALIVE_CLIENT_COUNT_MAX) && Server.KEEPALIVE_CLIENT_COUNT_MAX >= 0 ? Server.KEEPALIVE_CLIENT_COUNT_MAX : -1;
    let kaCurCount = 0;
    if (kaIntvl !== -1 && kaCountMax !== -1) {
      this.once("ready", () => {
        const onClose = () => {
          clearInterval(kaTimer);
        };
        this.on("close", onClose).on("end", onClose);
        kaTimer = setInterval(() => {
          if (++kaCurCount > kaCountMax) {
            clearInterval(kaTimer);
            const err = new Error("Keepalive timeout");
            err.level = "client-timeout";
            this.emit("error", err);
            this.end();
          } else {
            proto.ping();
          }
        }, kaIntvl);
      });
      onPacket = () => {
        kaTimer && kaTimer.refresh();
        kaCurCount = 0;
      };
    }
    const proto = this._protocol = new Protocol2({
      server: true,
      hostKeys,
      ident,
      offer,
      onPacket,
      greeting: srvCfg.greeting,
      banner: srvCfg.banner,
      onWrite: (data) => {
        if (isWritable(socket))
          socket.write(data);
      },
      onError: (err) => {
        if (!proto._destruct)
          socket.removeAllListeners("data");
        this.emit("error", err);
        try {
          socket.end();
        } catch {
        }
      },
      onHeader: (header) => {
        this.removeListener("error", onClientPreHeaderError);
        const info = {
          ip: socket.remoteAddress,
          family: socket.remoteFamily,
          port: socket.remotePort,
          header
        };
        if (!server2.emit("connection", this, info)) {
          proto.disconnect(DISCONNECT_REASON.BY_APPLICATION);
          socket.end();
          return;
        }
        if (header.greeting)
          this.emit("greeting", header.greeting);
      },
      onHandshakeComplete: (negotiated) => {
        if (++exchanges > 1)
          this.emit("rekey");
        this.emit("handshake", negotiated);
      },
      debug: debug2,
      messageHandlers: {
        DEBUG: DEBUG_HANDLER,
        DISCONNECT: (p, reason, desc) => {
          if (reason !== DISCONNECT_REASON.BY_APPLICATION) {
            if (!desc) {
              desc = DISCONNECT_REASON_BY_VALUE[reason];
              if (desc === void 0)
                desc = `Unexpected disconnection reason: ${reason}`;
            }
            const err = new Error(desc);
            err.code = reason;
            this.emit("error", err);
          }
          socket.end();
        },
        CHANNEL_OPEN: (p, info) => {
          if (info.type === "session" && this.noMoreSessions || !this.authenticated) {
            const reasonCode = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;
            return proto.channelOpenFail(info.sender, reasonCode);
          }
          let localChan = -1;
          let reason;
          let replied = false;
          let accept;
          const reject = () => {
            if (replied)
              return;
            replied = true;
            if (reason === void 0) {
              if (localChan === -1)
                reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;
              else
                reason = CHANNEL_OPEN_FAILURE.CONNECT_FAILED;
            }
            if (localChan !== -1)
              this._chanMgr.remove(localChan);
            proto.channelOpenFail(info.sender, reason, "");
          };
          const reserveChannel = () => {
            localChan = this._chanMgr.add();
            if (localChan === -1) {
              reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;
              if (debug2) {
                debug2("Automatic rejection of incoming channel open: no channels available");
              }
            }
            return localChan !== -1;
          };
          const data = info.data;
          switch (info.type) {
            case "session":
              if (listenerCount(this, "session") && reserveChannel()) {
                accept = () => {
                  if (replied)
                    return;
                  replied = true;
                  const instance = new Session(this, info, localChan);
                  this._chanMgr.update(localChan, instance);
                  proto.channelOpenConfirm(
                    info.sender,
                    localChan,
                    MAX_WINDOW,
                    PACKET_SIZE
                  );
                  return instance;
                };
                this.emit("session", accept, reject);
                return;
              }
              break;
            case "direct-tcpip":
              if (listenerCount(this, "tcpip") && reserveChannel()) {
                accept = () => {
                  if (replied)
                    return;
                  replied = true;
                  const chanInfo = {
                    type: void 0,
                    incoming: {
                      id: localChan,
                      window: MAX_WINDOW,
                      packetSize: PACKET_SIZE,
                      state: "open"
                    },
                    outgoing: {
                      id: info.sender,
                      window: info.window,
                      packetSize: info.packetSize,
                      state: "open"
                    }
                  };
                  const stream = new Channel2(this, chanInfo, { server: true });
                  this._chanMgr.update(localChan, stream);
                  proto.channelOpenConfirm(
                    info.sender,
                    localChan,
                    MAX_WINDOW,
                    PACKET_SIZE
                  );
                  return stream;
                };
                this.emit("tcpip", accept, reject, data);
                return;
              }
              break;
            case "direct-streamlocal@openssh.com":
              if (listenerCount(this, "openssh.streamlocal") && reserveChannel()) {
                accept = () => {
                  if (replied)
                    return;
                  replied = true;
                  const chanInfo = {
                    type: void 0,
                    incoming: {
                      id: localChan,
                      window: MAX_WINDOW,
                      packetSize: PACKET_SIZE,
                      state: "open"
                    },
                    outgoing: {
                      id: info.sender,
                      window: info.window,
                      packetSize: info.packetSize,
                      state: "open"
                    }
                  };
                  const stream = new Channel2(this, chanInfo, { server: true });
                  this._chanMgr.update(localChan, stream);
                  proto.channelOpenConfirm(
                    info.sender,
                    localChan,
                    MAX_WINDOW,
                    PACKET_SIZE
                  );
                  return stream;
                };
                this.emit("openssh.streamlocal", accept, reject, data);
                return;
              }
              break;
            default:
              reason = CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;
              if (debug2) {
                debug2(`Automatic rejection of unsupported incoming channel open type: ${info.type}`);
              }
          }
          if (reason === void 0) {
            reason = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;
            if (debug2) {
              debug2(`Automatic rejection of unexpected incoming channel open for: ${info.type}`);
            }
          }
          reject();
        },
        CHANNEL_OPEN_CONFIRMATION: (p, info) => {
          const channel = this._chanMgr.get(info.recipient);
          if (typeof channel !== "function")
            return;
          const chanInfo = {
            type: channel.type,
            incoming: {
              id: info.recipient,
              window: MAX_WINDOW,
              packetSize: PACKET_SIZE,
              state: "open"
            },
            outgoing: {
              id: info.sender,
              window: info.window,
              packetSize: info.packetSize,
              state: "open"
            }
          };
          const instance = new Channel2(this, chanInfo, { server: true });
          this._chanMgr.update(info.recipient, instance);
          channel(void 0, instance);
        },
        CHANNEL_OPEN_FAILURE: (p, recipient, reason, description2) => {
          const channel = this._chanMgr.get(recipient);
          if (typeof channel !== "function")
            return;
          const info = { reason, description: description2 };
          onChannelOpenFailure(this, recipient, info, channel);
        },
        CHANNEL_DATA: (p, recipient, data) => {
          let channel = this._chanMgr.get(recipient);
          if (typeof channel !== "object" || channel === null)
            return;
          if (channel.constructor === Session) {
            channel = channel._channel;
            if (!channel)
              return;
          }
          if (channel.incoming.window === 0)
            return;
          channel.incoming.window -= data.length;
          if (channel.push(data) === false) {
            channel._waitChanDrain = true;
            return;
          }
          if (channel.incoming.window <= WINDOW_THRESHOLD)
            windowAdjust(channel);
        },
        CHANNEL_EXTENDED_DATA: (p, recipient, data, type2) => {
        },
        CHANNEL_WINDOW_ADJUST: (p, recipient, amount) => {
          let channel = this._chanMgr.get(recipient);
          if (typeof channel !== "object" || channel === null)
            return;
          if (channel.constructor === Session) {
            channel = channel._channel;
            if (!channel)
              return;
          }
          channel.outgoing.window += amount;
          if (channel._waitWindow) {
            channel._waitWindow = false;
            if (channel._chunk) {
              channel._write(channel._chunk, null, channel._chunkcb);
            } else if (channel._chunkcb) {
              channel._chunkcb();
            } else if (channel._chunkErr) {
              channel.stderr._write(
                channel._chunkErr,
                null,
                channel._chunkcbErr
              );
            } else if (channel._chunkcbErr) {
              channel._chunkcbErr();
            }
          }
        },
        CHANNEL_SUCCESS: (p, recipient) => {
          let channel = this._chanMgr.get(recipient);
          if (typeof channel !== "object" || channel === null)
            return;
          if (channel.constructor === Session) {
            channel = channel._channel;
            if (!channel)
              return;
          }
          if (channel._callbacks.length)
            channel._callbacks.shift()(false);
        },
        CHANNEL_FAILURE: (p, recipient) => {
          let channel = this._chanMgr.get(recipient);
          if (typeof channel !== "object" || channel === null)
            return;
          if (channel.constructor === Session) {
            channel = channel._channel;
            if (!channel)
              return;
          }
          if (channel._callbacks.length)
            channel._callbacks.shift()(true);
        },
        CHANNEL_REQUEST: (p, recipient, type2, wantReply, data) => {
          const session = this._chanMgr.get(recipient);
          if (typeof session !== "object" || session === null)
            return;
          let replied = false;
          let accept;
          let reject;
          if (session.constructor !== Session) {
            if (wantReply)
              proto.channelFailure(session.outgoing.id);
            return;
          }
          if (wantReply) {
            if (type2 !== "shell" && type2 !== "exec" && type2 !== "subsystem") {
              accept = () => {
                if (replied || session._ending || session._channel)
                  return;
                replied = true;
                proto.channelSuccess(session._chanInfo.outgoing.id);
              };
            }
            reject = () => {
              if (replied || session._ending || session._channel)
                return;
              replied = true;
              proto.channelFailure(session._chanInfo.outgoing.id);
            };
          }
          if (session._ending) {
            reject && reject();
            return;
          }
          switch (type2) {
            case "env":
              if (listenerCount(session, "env")) {
                session.emit("env", accept, reject, {
                  key: data.name,
                  val: data.value
                });
                return;
              }
              break;
            case "pty-req":
              if (listenerCount(session, "pty")) {
                session.emit("pty", accept, reject, data);
                return;
              }
              break;
            case "window-change":
              if (listenerCount(session, "window-change"))
                session.emit("window-change", accept, reject, data);
              else
                reject && reject();
              break;
            case "x11-req":
              if (listenerCount(session, "x11")) {
                session.emit("x11", accept, reject, data);
                return;
              }
              break;
            case "signal":
              if (listenerCount(session, "signal")) {
                session.emit("signal", accept, reject, {
                  name: data
                });
                return;
              }
              break;
            case "auth-agent-req@openssh.com":
              if (listenerCount(session, "auth-agent")) {
                session.emit("auth-agent", accept, reject);
                return;
              }
              break;
            case "shell":
              if (listenerCount(session, "shell")) {
                accept = () => {
                  if (replied || session._ending || session._channel)
                    return;
                  replied = true;
                  if (wantReply)
                    proto.channelSuccess(session._chanInfo.outgoing.id);
                  const channel = new Channel2(
                    this,
                    session._chanInfo,
                    { server: true }
                  );
                  channel.subtype = session.subtype = type2;
                  session._channel = channel;
                  return channel;
                };
                session.emit("shell", accept, reject);
                return;
              }
              break;
            case "exec":
              if (listenerCount(session, "exec")) {
                accept = () => {
                  if (replied || session._ending || session._channel)
                    return;
                  replied = true;
                  if (wantReply)
                    proto.channelSuccess(session._chanInfo.outgoing.id);
                  const channel = new Channel2(
                    this,
                    session._chanInfo,
                    { server: true }
                  );
                  channel.subtype = session.subtype = type2;
                  session._channel = channel;
                  return channel;
                };
                session.emit("exec", accept, reject, {
                  command: data
                });
                return;
              }
              break;
            case "subsystem": {
              let useSFTP = data === "sftp";
              accept = () => {
                if (replied || session._ending || session._channel)
                  return;
                replied = true;
                if (wantReply)
                  proto.channelSuccess(session._chanInfo.outgoing.id);
                let instance;
                if (useSFTP) {
                  instance = new SFTP2(this, session._chanInfo, {
                    server: true,
                    debug: debug2
                  });
                } else {
                  instance = new Channel2(
                    this,
                    session._chanInfo,
                    { server: true }
                  );
                  instance.subtype = session.subtype = `${type2}:${data}`;
                }
                session._channel = instance;
                return instance;
              };
              if (data === "sftp") {
                if (listenerCount(session, "sftp")) {
                  session.emit("sftp", accept, reject);
                  return;
                }
                useSFTP = false;
              }
              if (listenerCount(session, "subsystem")) {
                session.emit("subsystem", accept, reject, {
                  name: data
                });
                return;
              }
              break;
            }
          }
          debug2 && debug2(
            `Automatic rejection of incoming channel request: ${type2}`
          );
          reject && reject();
        },
        CHANNEL_EOF: (p, recipient) => {
          let channel = this._chanMgr.get(recipient);
          if (typeof channel !== "object" || channel === null)
            return;
          if (channel.constructor === Session) {
            if (!channel._ending) {
              channel._ending = true;
              channel.emit("eof");
              channel.emit("end");
            }
            channel = channel._channel;
            if (!channel)
              return;
          }
          if (channel.incoming.state !== "open")
            return;
          channel.incoming.state = "eof";
          if (channel.readable)
            channel.push(null);
        },
        CHANNEL_CLOSE: (p, recipient) => {
          let channel = this._chanMgr.get(recipient);
          if (typeof channel !== "object" || channel === null)
            return;
          if (channel.constructor === Session) {
            channel._ending = true;
            channel.emit("close");
            channel = channel._channel;
            if (!channel)
              return;
          }
          onCHANNEL_CLOSE(this, recipient, channel);
        },
        // Begin service/auth-related ==========================================
        SERVICE_REQUEST: (p, service) => {
          if (exchanges === 0 || acceptedAuthSvc || this.authenticated || service !== "ssh-userauth") {
            proto.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);
            socket.end();
            return;
          }
          acceptedAuthSvc = true;
          proto.serviceAccept(service);
        },
        USERAUTH_REQUEST: (p, username, service, method, methodData) => {
          if (exchanges === 0 || this.authenticated || authCtx && (authCtx.username !== username || authCtx.service !== service) || method !== "password" && method !== "publickey" && method !== "hostbased" && method !== "keyboard-interactive" && method !== "none" || pendingAuths.length === MAX_PENDING_AUTHS) {
            proto.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);
            socket.end();
            return;
          } else if (service !== "ssh-connection") {
            proto.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);
            socket.end();
            return;
          }
          let ctx;
          switch (method) {
            case "keyboard-interactive":
              ctx = new KeyboardAuthContext(
                proto,
                username,
                service,
                method,
                methodData,
                onAuthDecide
              );
              break;
            case "publickey":
              ctx = new PKAuthContext(
                proto,
                username,
                service,
                method,
                methodData,
                onAuthDecide
              );
              break;
            case "hostbased":
              ctx = new HostbasedAuthContext(
                proto,
                username,
                service,
                method,
                methodData,
                onAuthDecide
              );
              break;
            case "password":
              if (authCtx && authCtx instanceof PwdAuthContext && authCtx._changeCb) {
                const cb = authCtx._changeCb;
                authCtx._changeCb = void 0;
                cb(methodData.newPassword);
                return;
              }
              ctx = new PwdAuthContext(
                proto,
                username,
                service,
                method,
                methodData,
                onAuthDecide
              );
              break;
            case "none":
              ctx = new AuthContext(
                proto,
                username,
                service,
                method,
                onAuthDecide
              );
              break;
          }
          if (authCtx) {
            if (!authCtx._initialResponse) {
              return pendingAuths.push(ctx);
            } else if (authCtx._multistep && !authCtx._finalResponse) {
              authCtx._cleanup && authCtx._cleanup();
              authCtx.emit("abort");
            }
          }
          authCtx = ctx;
          if (listenerCount(this, "authentication"))
            this.emit("authentication", authCtx);
          else
            authCtx.reject();
        },
        USERAUTH_INFO_RESPONSE: (p, responses) => {
          if (authCtx && authCtx instanceof KeyboardAuthContext)
            authCtx._onInfoResponse(responses);
        },
        // End service/auth-related ============================================
        GLOBAL_REQUEST: (p, name, wantReply, data) => {
          const reply = {
            type: null,
            buf: null
          };
          function setReply(type2, buf) {
            reply.type = type2;
            reply.buf = buf;
            sendReplies();
          }
          if (wantReply)
            unsentGlobalRequestsReplies.push(reply);
          if ((name === "tcpip-forward" || name === "cancel-tcpip-forward" || name === "no-more-sessions@openssh.com" || name === "streamlocal-forward@openssh.com" || name === "cancel-streamlocal-forward@openssh.com") && listenerCount(this, "request") && this.authenticated) {
            let accept;
            let reject;
            if (wantReply) {
              let replied = false;
              accept = (chosenPort) => {
                if (replied)
                  return;
                replied = true;
                let bufPort;
                if (name === "tcpip-forward" && data.bindPort === 0 && typeof chosenPort === "number") {
                  bufPort = Buffer.allocUnsafe(4);
                  writeUInt32BE(bufPort, chosenPort, 0);
                }
                setReply("SUCCESS", bufPort);
              };
              reject = () => {
                if (replied)
                  return;
                replied = true;
                setReply("FAILURE");
              };
            }
            if (name === "no-more-sessions@openssh.com") {
              this.noMoreSessions = true;
              accept && accept();
              return;
            }
            this.emit("request", accept, reject, name, data);
          } else if (wantReply) {
            setReply("FAILURE");
          }
        }
      }
    });
    socket.pause();
    cryptoInit.then(() => {
      proto.start();
      socket.on("data", (data) => {
        try {
          proto.parse(data, 0, data.length);
        } catch (ex) {
          this.emit("error", ex);
          try {
            if (isWritable(socket))
              socket.end();
          } catch {
          }
        }
      });
      socket.resume();
    }).catch((err) => {
      this.emit("error", err);
      try {
        if (isWritable(socket))
          socket.end();
      } catch {
      }
    });
    socket.on("error", (err) => {
      err.level = "socket";
      this.emit("error", err);
    }).once("end", () => {
      debug2 && debug2("Socket ended");
      proto.cleanup();
      this.emit("end");
    }).once("close", () => {
      debug2 && debug2("Socket closed");
      proto.cleanup();
      this.emit("close");
      const err = new Error("No response from server");
      this._chanMgr.cleanup(err);
    });
    const onAuthDecide = (ctx, allowed, methodsLeft, isPartial) => {
      if (authCtx === ctx && !this.authenticated) {
        if (allowed) {
          authCtx = void 0;
          this.authenticated = true;
          proto.authSuccess();
          pendingAuths = [];
          this.emit("ready");
        } else {
          proto.authFailure(methodsLeft, isPartial);
          if (pendingAuths.length) {
            authCtx = pendingAuths.pop();
            if (listenerCount(this, "authentication"))
              this.emit("authentication", authCtx);
            else
              authCtx.reject();
          }
        }
      }
    };
    function sendReplies() {
      while (unsentGlobalRequestsReplies.length > 0 && unsentGlobalRequestsReplies[0].type) {
        const reply = unsentGlobalRequestsReplies.shift();
        if (reply.type === "SUCCESS")
          proto.requestSuccess(reply.buf);
        if (reply.type === "FAILURE")
          proto.requestFailure();
      }
    }
  }
  end() {
    if (this._sock && isWritable(this._sock)) {
      this._protocol.disconnect(DISCONNECT_REASON.BY_APPLICATION);
      this._sock.end();
    }
    return this;
  }
  x11(originAddr, originPort, cb) {
    const opts = { originAddr, originPort };
    openChannel(this, "x11", opts, cb);
    return this;
  }
  forwardOut(boundAddr, boundPort, remoteAddr, remotePort, cb) {
    const opts = { boundAddr, boundPort, remoteAddr, remotePort };
    openChannel(this, "forwarded-tcpip", opts, cb);
    return this;
  }
  openssh_forwardOutStreamLocal(socketPath, cb) {
    const opts = { socketPath };
    openChannel(this, "forwarded-streamlocal@openssh.com", opts, cb);
    return this;
  }
  rekey(cb) {
    let error2;
    try {
      this._protocol.rekey();
    } catch (ex) {
      error2 = ex;
    }
    if (typeof cb === "function") {
      if (error2)
        process.nextTick(cb, error2);
      else
        this.once("rekey", cb);
    }
  }
  setNoDelay(noDelay) {
    if (this._sock && typeof this._sock.setNoDelay === "function")
      this._sock.setNoDelay(noDelay);
    return this;
  }
}
function openChannel(self2, type2, opts, cb) {
  const initWindow = MAX_WINDOW;
  const maxPacket = PACKET_SIZE;
  if (typeof opts === "function") {
    cb = opts;
    opts = {};
  }
  const wrapper = (err, stream) => {
    cb(err, stream);
  };
  wrapper.type = type2;
  const localChan = self2._chanMgr.add(wrapper);
  if (localChan === -1) {
    cb(new Error("No free channels available"));
    return;
  }
  switch (type2) {
    case "forwarded-tcpip":
      self2._protocol.forwardedTcpip(localChan, initWindow, maxPacket, opts);
      break;
    case "x11":
      self2._protocol.x11(localChan, initWindow, maxPacket, opts);
      break;
    case "forwarded-streamlocal@openssh.com":
      self2._protocol.openssh_forwardedStreamLocal(
        localChan,
        initWindow,
        maxPacket,
        opts
      );
      break;
    default:
      throw new Error(`Unsupported channel type: ${type2}`);
  }
}
function compareNumbers(a, b) {
  return a - b;
}
server.exports = Server;
server.exports.IncomingClient = Client2;
const {
  createCipheriv,
  generateKeyPair: generateKeyPair_,
  generateKeyPairSync: generateKeyPairSync_,
  getCurves,
  randomBytes
} = require$$0$3;
const { Ber } = lib$1;
const bcrypt_pbkdf = bcryptPbkdf.pbkdf;
const { CIPHER_INFO } = requireCrypto();
const SALT_LEN = 16;
const DEFAULT_ROUNDS = 16;
const curves = getCurves();
const ciphers = new Map(Object.entries(CIPHER_INFO));
function makeArgs(type2, opts) {
  if (typeof type2 !== "string")
    throw new TypeError("Key type must be a string");
  const publicKeyEncoding = { type: "spki", format: "der" };
  const privateKeyEncoding = { type: "pkcs8", format: "der" };
  switch (type2.toLowerCase()) {
    case "rsa": {
      if (typeof opts !== "object" || opts === null)
        throw new TypeError("Missing options object for RSA key");
      const modulusLength = opts.bits;
      if (!Number.isInteger(modulusLength))
        throw new TypeError("RSA bits must be an integer");
      if (modulusLength <= 0 || modulusLength > 16384)
        throw new RangeError("RSA bits must be non-zero and <= 16384");
      return ["rsa", { modulusLength, publicKeyEncoding, privateKeyEncoding }];
    }
    case "ecdsa": {
      if (typeof opts !== "object" || opts === null)
        throw new TypeError("Missing options object for ECDSA key");
      if (!Number.isInteger(opts.bits))
        throw new TypeError("ECDSA bits must be an integer");
      let namedCurve;
      switch (opts.bits) {
        case 256:
          namedCurve = "prime256v1";
          break;
        case 384:
          namedCurve = "secp384r1";
          break;
        case 521:
          namedCurve = "secp521r1";
          break;
        default:
          throw new Error("ECDSA bits must be 256, 384, or 521");
      }
      if (!curves.includes(namedCurve))
        throw new Error("Unsupported ECDSA bits value");
      return ["ec", { namedCurve, publicKeyEncoding, privateKeyEncoding }];
    }
    case "ed25519":
      return ["ed25519", { publicKeyEncoding, privateKeyEncoding }];
    default:
      throw new Error(`Unsupported key type: ${type2}`);
  }
}
function parseDERs(keyType, pub, priv) {
  switch (keyType) {
    case "rsa": {
      let reader2 = new Ber.Reader(priv);
      reader2.readSequence();
      if (reader2.readInt() !== 0)
        throw new Error("Unsupported version in RSA private key");
      reader2.readSequence();
      if (reader2.readOID() !== "1.2.840.113549.1.1.1")
        throw new Error("Bad RSA private OID");
      if (reader2.readByte() !== Ber.Null)
        throw new Error("Malformed RSA private key (expected null)");
      if (reader2.readByte() !== 0) {
        throw new Error(
          "Malformed RSA private key (expected zero-length null)"
        );
      }
      reader2 = new Ber.Reader(reader2.readString(Ber.OctetString, true));
      reader2.readSequence();
      if (reader2.readInt() !== 0)
        throw new Error("Unsupported version in RSA private key");
      const n = reader2.readString(Ber.Integer, true);
      const e = reader2.readString(Ber.Integer, true);
      const d = reader2.readString(Ber.Integer, true);
      const p = reader2.readString(Ber.Integer, true);
      const q = reader2.readString(Ber.Integer, true);
      reader2.readString(Ber.Integer, true);
      reader2.readString(Ber.Integer, true);
      const iqmp = reader2.readString(Ber.Integer, true);
      const keyName = Buffer.from("ssh-rsa");
      const privBuf = Buffer.allocUnsafe(
        4 + keyName.length + 4 + n.length + 4 + e.length + 4 + d.length + 4 + iqmp.length + 4 + p.length + 4 + q.length
      );
      let pos = 0;
      privBuf.writeUInt32BE(keyName.length, pos += 0);
      privBuf.set(keyName, pos += 4);
      privBuf.writeUInt32BE(n.length, pos += keyName.length);
      privBuf.set(n, pos += 4);
      privBuf.writeUInt32BE(e.length, pos += n.length);
      privBuf.set(e, pos += 4);
      privBuf.writeUInt32BE(d.length, pos += e.length);
      privBuf.set(d, pos += 4);
      privBuf.writeUInt32BE(iqmp.length, pos += d.length);
      privBuf.set(iqmp, pos += 4);
      privBuf.writeUInt32BE(p.length, pos += iqmp.length);
      privBuf.set(p, pos += 4);
      privBuf.writeUInt32BE(q.length, pos += p.length);
      privBuf.set(q, pos += 4);
      const pubBuf = Buffer.allocUnsafe(
        4 + keyName.length + 4 + e.length + 4 + n.length
      );
      pos = 0;
      pubBuf.writeUInt32BE(keyName.length, pos += 0);
      pubBuf.set(keyName, pos += 4);
      pubBuf.writeUInt32BE(e.length, pos += keyName.length);
      pubBuf.set(e, pos += 4);
      pubBuf.writeUInt32BE(n.length, pos += e.length);
      pubBuf.set(n, pos += 4);
      return { sshName: keyName.toString(), priv: privBuf, pub: pubBuf };
    }
    case "ec": {
      let reader2 = new Ber.Reader(pub);
      reader2.readSequence();
      reader2.readSequence();
      if (reader2.readOID() !== "1.2.840.10045.2.1")
        throw new Error("Bad ECDSA public OID");
      reader2.readOID();
      let pubBin = reader2.readString(Ber.BitString, true);
      {
        let i = 0;
        for (; i < pubBin.length && pubBin[i] === 0; ++i) ;
        if (i > 0)
          pubBin = pubBin.slice(i);
      }
      reader2 = new Ber.Reader(priv);
      reader2.readSequence();
      if (reader2.readInt() !== 0)
        throw new Error("Unsupported version in ECDSA private key");
      reader2.readSequence();
      if (reader2.readOID() !== "1.2.840.10045.2.1")
        throw new Error("Bad ECDSA private OID");
      const curveOID = reader2.readOID();
      let sshCurveName;
      switch (curveOID) {
        case "1.2.840.10045.3.1.7":
          sshCurveName = "nistp256";
          break;
        case "1.3.132.0.34":
          sshCurveName = "nistp384";
          break;
        case "1.3.132.0.35":
          sshCurveName = "nistp521";
          break;
        default:
          throw new Error("Unsupported curve in ECDSA private key");
      }
      reader2 = new Ber.Reader(reader2.readString(Ber.OctetString, true));
      reader2.readSequence();
      if (reader2.readInt() !== 1)
        throw new Error("Unsupported version in ECDSA private key");
      const privBin = Buffer.concat([
        Buffer.from([0]),
        reader2.readString(Ber.OctetString, true)
      ]);
      const keyName = Buffer.from(`ecdsa-sha2-${sshCurveName}`);
      sshCurveName = Buffer.from(sshCurveName);
      const privBuf = Buffer.allocUnsafe(
        4 + keyName.length + 4 + sshCurveName.length + 4 + pubBin.length + 4 + privBin.length
      );
      let pos = 0;
      privBuf.writeUInt32BE(keyName.length, pos += 0);
      privBuf.set(keyName, pos += 4);
      privBuf.writeUInt32BE(sshCurveName.length, pos += keyName.length);
      privBuf.set(sshCurveName, pos += 4);
      privBuf.writeUInt32BE(pubBin.length, pos += sshCurveName.length);
      privBuf.set(pubBin, pos += 4);
      privBuf.writeUInt32BE(privBin.length, pos += pubBin.length);
      privBuf.set(privBin, pos += 4);
      const pubBuf = Buffer.allocUnsafe(
        4 + keyName.length + 4 + sshCurveName.length + 4 + pubBin.length
      );
      pos = 0;
      pubBuf.writeUInt32BE(keyName.length, pos += 0);
      pubBuf.set(keyName, pos += 4);
      pubBuf.writeUInt32BE(sshCurveName.length, pos += keyName.length);
      pubBuf.set(sshCurveName, pos += 4);
      pubBuf.writeUInt32BE(pubBin.length, pos += sshCurveName.length);
      pubBuf.set(pubBin, pos += 4);
      return { sshName: keyName.toString(), priv: privBuf, pub: pubBuf };
    }
    case "ed25519": {
      let reader2 = new Ber.Reader(pub);
      reader2.readSequence();
      reader2.readSequence();
      if (reader2.readOID() !== "1.3.101.112")
        throw new Error("Bad ED25519 public OID");
      let pubBin = reader2.readString(Ber.BitString, true);
      {
        let i = 0;
        for (; i < pubBin.length && pubBin[i] === 0; ++i) ;
        if (i > 0)
          pubBin = pubBin.slice(i);
      }
      reader2 = new Ber.Reader(priv);
      reader2.readSequence();
      if (reader2.readInt() !== 0)
        throw new Error("Unsupported version in ED25519 private key");
      reader2.readSequence();
      if (reader2.readOID() !== "1.3.101.112")
        throw new Error("Bad ED25519 private OID");
      reader2 = new Ber.Reader(reader2.readString(Ber.OctetString, true));
      const privBin = reader2.readString(Ber.OctetString, true);
      const keyName = Buffer.from("ssh-ed25519");
      const privBuf = Buffer.allocUnsafe(
        4 + keyName.length + 4 + pubBin.length + 4 + (privBin.length + pubBin.length)
      );
      let pos = 0;
      privBuf.writeUInt32BE(keyName.length, pos += 0);
      privBuf.set(keyName, pos += 4);
      privBuf.writeUInt32BE(pubBin.length, pos += keyName.length);
      privBuf.set(pubBin, pos += 4);
      privBuf.writeUInt32BE(
        privBin.length + pubBin.length,
        pos += pubBin.length
      );
      privBuf.set(privBin, pos += 4);
      privBuf.set(pubBin, pos += privBin.length);
      const pubBuf = Buffer.allocUnsafe(
        4 + keyName.length + 4 + pubBin.length
      );
      pos = 0;
      pubBuf.writeUInt32BE(keyName.length, pos += 0);
      pubBuf.set(keyName, pos += 4);
      pubBuf.writeUInt32BE(pubBin.length, pos += keyName.length);
      pubBuf.set(pubBin, pos += 4);
      return { sshName: keyName.toString(), priv: privBuf, pub: pubBuf };
    }
  }
}
function convertKeys(keyType, pub, priv, opts) {
  let format2 = "new";
  let encrypted;
  let comment = "";
  if (typeof opts === "object" && opts !== null) {
    if (typeof opts.comment === "string" && opts.comment)
      comment = opts.comment;
    if (typeof opts.format === "string" && opts.format)
      format2 = opts.format;
    if (opts.passphrase) {
      let passphrase;
      if (typeof opts.passphrase === "string")
        passphrase = Buffer.from(opts.passphrase);
      else if (Buffer.isBuffer(opts.passphrase))
        passphrase = opts.passphrase;
      else
        throw new Error("Invalid passphrase");
      if (opts.cipher === void 0)
        throw new Error("Missing cipher name");
      const cipher = ciphers.get(opts.cipher);
      if (cipher === void 0)
        throw new Error("Invalid cipher name");
      if (format2 === "new") {
        let rounds = DEFAULT_ROUNDS;
        if (opts.rounds !== void 0) {
          if (!Number.isInteger(opts.rounds))
            throw new TypeError("rounds must be an integer");
          if (opts.rounds > 0)
            rounds = opts.rounds;
        }
        const gen = Buffer.allocUnsafe(cipher.keyLen + cipher.ivLen);
        const salt = randomBytes(SALT_LEN);
        const r = bcrypt_pbkdf(
          passphrase,
          passphrase.length,
          salt,
          salt.length,
          gen,
          gen.length,
          rounds
        );
        if (r !== 0)
          return new Error("Failed to generate information to encrypt key");
        const kdfOptions = Buffer.allocUnsafe(4 + salt.length + 4);
        {
          let pos = 0;
          kdfOptions.writeUInt32BE(salt.length, pos += 0);
          kdfOptions.set(salt, pos += 4);
          kdfOptions.writeUInt32BE(rounds, pos += salt.length);
        }
        encrypted = {
          cipher,
          cipherName: opts.cipher,
          kdfName: "bcrypt",
          kdfOptions,
          key: gen.slice(0, cipher.keyLen),
          iv: gen.slice(cipher.keyLen)
        };
      }
    }
  }
  switch (format2) {
    case "new": {
      let privateB64 = "-----BEGIN OPENSSH PRIVATE KEY-----\n";
      let publicB64;
      const cipherName = Buffer.from(encrypted ? encrypted.cipherName : "none");
      const kdfName = Buffer.from(encrypted ? encrypted.kdfName : "none");
      const kdfOptions = encrypted ? encrypted.kdfOptions : Buffer.alloc(0);
      const blockLen = encrypted ? encrypted.cipher.blockLen : 8;
      const parsed = parseDERs(keyType, pub, priv);
      const checkInt = randomBytes(4);
      const commentBin = Buffer.from(comment);
      const privBlobLen = 4 + 4 + parsed.priv.length + 4 + commentBin.length;
      let padding = [];
      for (let i = 1; (privBlobLen + padding.length) % blockLen; ++i)
        padding.push(i & 255);
      padding = Buffer.from(padding);
      let privBlob = Buffer.allocUnsafe(privBlobLen + padding.length);
      let extra;
      {
        let pos = 0;
        privBlob.set(checkInt, pos += 0);
        privBlob.set(checkInt, pos += 4);
        privBlob.set(parsed.priv, pos += 4);
        privBlob.writeUInt32BE(commentBin.length, pos += parsed.priv.length);
        privBlob.set(commentBin, pos += 4);
        privBlob.set(padding, pos += commentBin.length);
      }
      if (encrypted) {
        const options = { authTagLength: encrypted.cipher.authLen };
        const cipher = createCipheriv(
          encrypted.cipher.sslName,
          encrypted.key,
          encrypted.iv,
          options
        );
        cipher.setAutoPadding(false);
        privBlob = Buffer.concat([cipher.update(privBlob), cipher.final()]);
        if (encrypted.cipher.authLen > 0)
          extra = cipher.getAuthTag();
        else
          extra = Buffer.alloc(0);
        encrypted.key.fill(0);
        encrypted.iv.fill(0);
      } else {
        extra = Buffer.alloc(0);
      }
      const magicBytes = Buffer.from("openssh-key-v1\0");
      const privBin = Buffer.allocUnsafe(
        magicBytes.length + 4 + cipherName.length + 4 + kdfName.length + 4 + kdfOptions.length + 4 + 4 + parsed.pub.length + 4 + privBlob.length + extra.length
      );
      {
        let pos = 0;
        privBin.set(magicBytes, pos += 0);
        privBin.writeUInt32BE(cipherName.length, pos += magicBytes.length);
        privBin.set(cipherName, pos += 4);
        privBin.writeUInt32BE(kdfName.length, pos += cipherName.length);
        privBin.set(kdfName, pos += 4);
        privBin.writeUInt32BE(kdfOptions.length, pos += kdfName.length);
        privBin.set(kdfOptions, pos += 4);
        privBin.writeUInt32BE(1, pos += kdfOptions.length);
        privBin.writeUInt32BE(parsed.pub.length, pos += 4);
        privBin.set(parsed.pub, pos += 4);
        privBin.writeUInt32BE(privBlob.length, pos += parsed.pub.length);
        privBin.set(privBlob, pos += 4);
        privBin.set(extra, pos += privBlob.length);
      }
      {
        const b64 = privBin.base64Slice(0, privBin.length);
        let formatted = b64.replace(/.{64}/g, "$&\n");
        if (b64.length & 63)
          formatted += "\n";
        privateB64 += formatted;
      }
      {
        const b64 = parsed.pub.base64Slice(0, parsed.pub.length);
        publicB64 = `${parsed.sshName} ${b64}${comment ? ` ${comment}` : ""}`;
      }
      privateB64 += "-----END OPENSSH PRIVATE KEY-----\n";
      return {
        private: privateB64,
        public: publicB64
      };
    }
    default:
      throw new Error("Invalid output key format");
  }
}
function noop() {
}
var keygen = {
  generateKeyPair: (keyType, opts, cb) => {
    if (typeof opts === "function") {
      cb = opts;
      opts = void 0;
    }
    if (typeof cb !== "function")
      cb = noop;
    const args = makeArgs(keyType, opts);
    generateKeyPair_(...args, (err, pub, priv) => {
      if (err)
        return cb(err);
      let ret;
      try {
        ret = convertKeys(args[0], pub, priv, opts);
      } catch (ex) {
        return cb(ex);
      }
      cb(null, ret);
    });
  },
  generateKeyPairSync: (keyType, opts) => {
    const args = makeArgs(keyType, opts);
    const { publicKey: pub, privateKey: priv } = generateKeyPairSync_(...args);
    return convertKeys(args[0], pub, priv, opts);
  }
};
const {
  AgentProtocol,
  BaseAgent: BaseAgent2,
  createAgent,
  CygwinAgent,
  OpenSSHAgent: OpenSSHAgent2,
  PageantAgent
} = agent;
const {
  SSHTTPAgent: HTTPAgent,
  SSHTTPSAgent: HTTPSAgent
} = httpAgents;
const { parseKey } = keyParser;
const {
  flagsToString,
  OPEN_MODE,
  STATUS_CODE,
  stringToFlags
} = SFTP_1;
var lib = {
  Client: client,
  utils: {
    ...keygen
  }
};
class SSHService {
  constructor() {
    this.connected = false;
    this.client = new lib.Client();
  }
  async connect(config) {
    return new Promise((resolve2, reject) => {
      const connConfig = {
        host: config.host,
        port: config.port,
        username: config.username
      };
      if (config.privateKeyPath) {
        connConfig.privateKey = fs.readFileSync(config.privateKeyPath);
      } else if (config.password) {
        connConfig.password = config.password;
      } else ;
      this.client.on("ready", () => {
        this.connected = true;
        resolve2();
      }).on("error", (err) => {
        this.connected = false;
        reject(err);
      }).connect(connConfig);
    });
  }
  async exec(command, onData) {
    if (!this.connected) throw new Error("Not connected");
    return new Promise((resolve2, reject) => {
      this.client.exec(command, (err, stream) => {
        if (err) return reject(err);
        stream.on("close", (code2, signal) => {
          if (code2 === 0) resolve2();
          else reject(new Error(`Command failed with code ${code2}`));
        }).on("data", (data) => {
          if (onData) onData(data.toString());
        }).stderr.on("data", (data) => {
          if (onData) onData(data.toString());
        });
      });
    });
  }
  async uploadFile(localPath, remotePath) {
    if (!this.connected) throw new Error("Not connected");
    return new Promise((resolve2, reject) => {
      this.client.sftp((err, sftp) => {
        if (err) return reject(err);
        sftp.fastPut(localPath, remotePath, (err2) => {
          if (err2) reject(err2);
          else resolve2();
        });
      });
    });
  }
  disconnect() {
    this.client.end();
    this.connected = false;
  }
}
const sshService = new SSHService();
class DeployOrchestrator {
  constructor() {
    this.swapFile = "/temp_deploy_swap";
  }
  async deploy(appId, targetEnv, onStatus) {
    const apps = ConfigStore.get("apps");
    const appConfig = apps[appId];
    const vpsConfig = ConfigStore.get("vps");
    const envConfig = appConfig.environments[targetEnv];
    if (!appConfig) throw new Error(`App ${appId} not found`);
    const { exec: localExec } = await import("node:child_process");
    const { exec: localExecSync } = await import("node:child_process");
    const { unlink } = await import("node:fs/promises");
    const fs2 = await import("node:fs");
    try {
      onStatus(` Iniciando deploy em ${targetEnv.toUpperCase()} para ${appConfig.name}...\r
`);
      onStatus(` Branch alvo: ${envConfig.branch}\r
`);
      onStatus(" Conectando  VPS...\r\n");
      await sshService.connect(vpsConfig);
      const repoDir = envConfig.remotePath;
      if (appConfig.sourceType === "local") {
        onStatus(` Comprimindo e enviando arquivos locais (Ambiente: ${targetEnv.toUpperCase()})...\r
`);
        let localPath = appConfig.localPath;
        const tarName = `deploy_${appId}.tar`;
        const tempDir = process.env.TEMP || process.env.TMP || "/tmp";
        const localTarPath = path$6.join(tempDir, tarName);
        const remoteTarPath = `/tmp/${tarName}`;
        const { exec: localExec2 } = await import("node:child_process");
        const tarCmd = `tar --force-local --exclude="node_modules" --exclude=".git" -cvf "${localTarPath}" -C "${localPath}" .`;
        await new Promise((resolve2, reject) => {
          localExec2(tarCmd, (err) => {
            if (err) reject(new Error(`Falha na compresso local: ${err.message}`));
            else resolve2(true);
          });
        });
        onStatus(" Transferindo arquivo para VPS...\r\n");
        await sshService.uploadFile(localTarPath, remoteTarPath);
        onStatus(" Extraindo arquivos no servidor...\r\n");
        const extractCmd = `
          mkdir -p ${repoDir}
          tar -xvf ${remoteTarPath} -C ${repoDir}
          rm ${remoteTarPath}
        `;
        await sshService.exec(extractCmd, onStatus);
        const { unlink: unlink2 } = await import("node:fs/promises");
        await unlink2(localTarPath).catch(() => {
        });
      } else {
        onStatus(` Preparando repositrio Git na VPS (Branch: ${envConfig.branch})...`);
        const repoUrl = appConfig.repoUrl;
        const branch = envConfig.branch;
        const gitCmd = `
          if [ ! -d "${repoDir}/.git" ]; then
            mkdir -p ${repoDir}
            git clone -b ${branch} ${repoUrl} ${repoDir}
          else
            cd ${repoDir} && git fetch origin ${branch} && git checkout ${branch} && git pull origin ${branch}
          fi
        `;
        await sshService.exec(gitCmd, onStatus);
      }
      onStatus(" Alocando swap temporrio (2GB) para estabilidade do build...");
      const swapSetupCmd = `
        sudo fallocate -l 2G ${this.swapFile}
        sudo chmod 600 ${this.swapFile}
        sudo mkswap ${this.swapFile}
        sudo swapon ${this.swapFile}
      `;
      try {
        await sshService.exec(swapSetupCmd, onStatus);
      } catch (e) {
        onStatus(" Falha ao configurar swap (isso pode ser normal se j existir ou sem permisso sudo). Continuando...");
      }
      if (appConfig.buildLocation === "local") {
        onStatus(" Estratgia de Build: LOCAL selecionada.\r\n");
        onStatus(" Verificando se o Docker est rodando no seu PC...\r\n");
        const { exec: localExec2 } = await import("node:child_process");
        try {
          await new Promise((resolve2, reject) => {
            localExec2("docker info", (err) => {
              if (err) reject(new Error("Docker Desktop no encontrado ou no est rodando. Por favor, inicie o Docker para prosseguir com o build local."));
              else resolve2(true);
            });
          });
          onStatus(" Docker detectado localmente.\r\n");
        } catch (dockerErr) {
          onStatus(` ERRO: ${dockerErr.message}\r
`);
          throw dockerErr;
        }
        onStatus(" Iniciando build Docker LOCAL no seu PC...");
        const localPath = appConfig.sourceType === "local" ? appConfig.localPath : path$6.join(process.env.TEMP || process.env.TMP || "/tmp", `repo_${appId}_${targetEnv}`);
        if (appConfig.sourceType === "github") {
          onStatus(` Clonando branch ${envConfig.branch} localmente para o build...`);
          if (fs2.existsSync(localPath)) fs2.rmSync(localPath, { recursive: true, force: true });
          const { execSync } = await import("node:child_process");
          execSync(`git clone -b ${envConfig.branch} ${appConfig.repoUrl} ${localPath}`);
        }
        const buildArgs = [
          ...Object.entries(envConfig.envVars || {}),
          ["APP_ENV", targetEnv],
          ["NODE_ENV", targetEnv === "production" ? "production" : "development"]
        ].map(([k, v]) => `--build-arg ${k}="${v}"`).join(" ");
        const imageName = `deploy_${appId.toLowerCase()}:${targetEnv}`;
        const localImagePath = path$6.join(process.env.TEMP || process.env.TMP || "/tmp", `image_${appId}.tar`);
        const remoteImagePath = `/tmp/image_${appId}.tar`;
        onStatus(" Construindo imagem Docker...");
        await new Promise((resolve2, reject) => {
          localExec2(`docker build ${buildArgs} -t ${imageName} "${localPath}"`, (err) => {
            if (err) reject(new Error(`Falha no build Docker local: ${err.message}`));
            else resolve2(true);
          });
        });
        onStatus(" Salvando imagem Docker para transferncia...");
        await new Promise((resolve2, reject) => {
          localExec2(`docker save -o "${localImagePath}" ${imageName}`, (err) => {
            if (err) reject(new Error(`Falha ao salvar imagem Docker: ${err.message}`));
            else resolve2(true);
          });
        });
        onStatus(" Transferindo imagem para VPS (isso pode demorar dependendo do tamanho)...");
        await sshService.uploadFile(localImagePath, remoteImagePath);
        onStatus(" Carregando imagem na VPS...");
        await sshService.exec(`docker load -i ${remoteImagePath} && rm ${remoteImagePath}`, onStatus);
        const { unlink: unlink2 } = await import("node:fs/promises");
        await unlink2(localImagePath).catch(() => {
        });
        onStatus(" Subindo containers na VPS...");
        const deployCmd = `
          cd ${repoDir}
          export IMAGE_TAG=${targetEnv}
          docker compose up -d --force-recreate
        `;
        await sshService.exec(deployCmd, onStatus);
      } else {
        onStatus(` Estratgia de Build: REMOTA (VPS) selecionada (${targetEnv.toUpperCase()}).\r
`);
        onStatus(" Iniciando build Docker diretamente no servidor...\r\n");
        const buildArgs = [
          ...Object.entries(envConfig.envVars || {}),
          ["APP_ENV", targetEnv],
          ["NODE_ENV", targetEnv === "production" ? "production" : "development"]
        ].map(([k, v]) => `--build-arg ${k}="${v}"`).join(" ");
        const deployCmd = `
          cd ${repoDir}
          export IMAGE_TAG=${targetEnv}
          docker compose build ${buildArgs}
          docker compose up -d --force-recreate
        `;
        await sshService.exec(deployCmd, onStatus);
      }
      onStatus(` Deploy em ${targetEnv.toUpperCase()} concludo com sucesso!`);
      appConfig.lastDeploy = (/* @__PURE__ */ new Date()).toISOString();
      appConfig.lastEnv = targetEnv;
      appConfig.status = "running";
      ConfigStore.set("apps", { ...apps, [appId]: appConfig });
    } catch (err) {
      onStatus(` ERRO NO DEPLOY: ${err.message}`);
      throw err;
    } finally {
      onStatus(" Limpando recursos temporrios...\r\n");
      const cleanupCmd = `
        sudo swapoff ${this.swapFile} 2>/dev/null || true
        sudo rm ${this.swapFile} 2>/dev/null || true
      `;
      try {
        await sshService.exec(cleanupCmd, onStatus);
      } catch (e) {
      }
      sshService.disconnect();
    }
  }
}
const deployOrchestrator = new DeployOrchestrator();
class EnvDetector {
  static async detect(projectPath) {
    const envPath = path$6.join(projectPath, ".env");
    const examplePath = path$6.join(projectPath, ".env.example");
    let content = "";
    if (fs.existsSync(envPath)) {
      content = fs.readFileSync(envPath, "utf8");
    } else if (fs.existsSync(examplePath)) {
      content = fs.readFileSync(examplePath, "utf8");
    } else {
      return {};
    }
    const envVars = {};
    const lines = content.split("\n");
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith("#")) continue;
      const [key2, ...valueParts] = trimmed.split("=");
      if (key2) {
        envVars[key2.trim()] = valueParts.join("=").trim().replace(/^['"]|['"]$/g, "");
      }
    }
    return envVars;
  }
  static async getProjectInfo(projectPath) {
    const pkgPath = path$6.join(projectPath, "package.json");
    const gitConfigPath = path$6.join(projectPath, ".git", "config");
    const formatName = (s) => {
      return s.split(/[_-]/).map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
    };
    let name = formatName(path$6.basename(projectPath));
    if (fs.existsSync(pkgPath)) {
      try {
        const pkg = JSON.parse(fs.readFileSync(pkgPath, "utf8"));
        const folderName = path$6.basename(projectPath).toLowerCase();
        if (pkg.name && (folderName === "src" || folderName === "app" || folderName === "project")) {
          name = formatName(pkg.name);
        }
      } catch (e) {
      }
    }
    let repoUrl = "";
    if (fs.existsSync(gitConfigPath)) {
      const gitConfig = fs.readFileSync(gitConfigPath, "utf8");
      const match = gitConfig.match(/\[remote "origin"\][\s\S]*?url = (.*)/);
      if (match) {
        repoUrl = match[1].trim();
      }
    }
    return { name, repoUrl };
  }
}
node_module.createRequire(typeof document === "undefined" ? require("url").pathToFileURL(__filename).href : _documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === "SCRIPT" && _documentCurrentScript.src || new URL("main.js", document.baseURI).href);
const __dirname$1 = path$6.dirname(node_url.fileURLToPath(typeof document === "undefined" ? require("url").pathToFileURL(__filename).href : _documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === "SCRIPT" && _documentCurrentScript.src || new URL("main.js", document.baseURI).href));
process.env.APP_ROOT = path$6.join(__dirname$1, "..");
const VITE_DEV_SERVER_URL = process.env["VITE_DEV_SERVER_URL"];
const MAIN_DIST = path$6.join(process.env.APP_ROOT, "dist-electron");
const RENDERER_DIST = path$6.join(process.env.APP_ROOT, "dist");
process.env.VITE_PUBLIC = VITE_DEV_SERVER_URL ? path$6.join(process.env.APP_ROOT, "public") : RENDERER_DIST;
let win;
function createWindow() {
  win = new require$$1$2.BrowserWindow({
    icon: path$6.join(process.env.VITE_PUBLIC || "", "electron-vite.svg"),
    webPreferences: {
      preload: path$6.join(__dirname$1, "preload.js")
    },
    titleBarStyle: "hidden",
    titleBarOverlay: {
      color: "#09090b",
      symbolColor: "#10b981",
      height: 35
    },
    width: 1200,
    height: 800,
    backgroundColor: "#09090b"
    // dark background
  });
  win.webContents.on("did-finish-load", () => {
    win == null ? void 0 : win.webContents.send("main-process-message", (/* @__PURE__ */ new Date()).toLocaleString());
  });
  if (VITE_DEV_SERVER_URL) {
    win.loadURL(VITE_DEV_SERVER_URL);
  } else {
    win.loadFile(path$6.join(RENDERER_DIST, "index.html"));
  }
}
require$$1$2.ipcMain.handle("config:get", (_event, key2) => ConfigStore.get(key2));
require$$1$2.ipcMain.handle("config:set", (_event, key2, value) => ConfigStore.set(key2, value));
require$$1$2.ipcMain.handle("ssh:connect", async (_event, config) => sshService.connect(config));
require$$1$2.ipcMain.handle("ssh:exec", async (event, cmd) => {
  return sshService.exec(cmd, (data) => {
    event.sender.send("terminal:data", data);
  });
});
require$$1$2.ipcMain.handle("deploy:start", async (event, appId, env2) => {
  return deployOrchestrator.deploy(appId, env2, (data) => {
    event.sender.send("terminal:data", data);
  });
});
require$$1$2.ipcMain.handle("dialog:openDirectory", async () => {
  const { canceled, filePaths } = await require$$1$2.dialog.showOpenDialog({
    properties: ["openDirectory", "createDirectory"]
  });
  if (canceled) return null;
  return filePaths[0];
});
require$$1$2.ipcMain.handle("dialog:openFile", async (_event, options) => {
  const { canceled, filePaths } = await require$$1$2.dialog.showOpenDialog({
    properties: ["openFile"],
    ...options
  });
  if (canceled) return null;
  return filePaths[0];
});
require$$1$2.ipcMain.handle("ssh:detectLocalKeys", async () => {
  const sshDir = path$6.join(os$1.homedir(), ".ssh");
  if (!fs.existsSync(sshDir)) return [];
  const files = fs.readdirSync(sshDir);
  const privateKeys = files.filter((file) => {
    const isPublic = file.endsWith(".pub") || file.endsWith(".pub.ppk");
    const hasKnownName = file.startsWith("id_") || file.endsWith(".pem") || file.endsWith(".ppk");
    return hasKnownName && !isPublic;
  });
  return privateKeys.map((name) => ({
    name,
    path: path$6.join(sshDir, name)
  }));
});
const execAsync = node_util.promisify(node_child_process.exec);
require$$1$2.ipcMain.handle("ssh:generateKey", async (_event, { email }) => {
  const keyPath = path$6.join(os$1.homedir(), ".ssh", "id_fresta_ed25519");
  const comment = email || "fresta-deploy";
  try {
    if (fs.existsSync(keyPath)) {
      throw new Error('Uma chave "id_fresta_ed25519" j existe em ~/.ssh/. Por favor, use a existente ou renomeie-a.');
    }
    const sshDir = path$6.join(os$1.homedir(), ".ssh");
    if (!fs.existsSync(sshDir)) fs.mkdirSync(sshDir, { recursive: true });
    await execAsync(`ssh-keygen -t ed25519 -C "${comment}" -f "${keyPath}" -N ""`);
    return {
      success: true,
      path: keyPath,
      publicKey: fs.readFileSync(`${keyPath}.pub`, "utf-8")
    };
  } catch (err) {
    console.error(err);
    return { success: false, error: err.message };
  }
});
require$$1$2.ipcMain.handle("env:detect", async (_event, projectPath) => {
  const targetPath = projectPath || path$6.join(process.env.APP_ROOT || "", "..");
  return EnvDetector.detect(targetPath);
});
require$$1$2.ipcMain.handle("project:detect", async (_event, projectPath) => {
  const targetPath = projectPath || path$6.join(process.env.APP_ROOT || "", "..");
  const info = await EnvDetector.getProjectInfo(targetPath);
  const envVars = await EnvDetector.detect(targetPath);
  return { ...info, envVars, path: targetPath };
});
require$$1$2.app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    require$$1$2.app.quit();
    win = null;
  }
});
require$$1$2.app.on("activate", () => {
  if (require$$1$2.BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});
require$$1$2.app.whenReady().then(createWindow);
exports.MAIN_DIST = MAIN_DIST;
exports.RENDERER_DIST = RENDERER_DIST;
exports.VITE_DEV_SERVER_URL = VITE_DEV_SERVER_URL;
